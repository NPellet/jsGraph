(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Graph"] = factory();
	else
		root["Graph"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 144);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var core = __webpack_require__(19);
var hide = __webpack_require__(12);
var redefine = __webpack_require__(13);
var ctx = __webpack_require__(20);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 2 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(exports);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports);
    global.graphUtil = mod.exports;
  }
})(this, function (exports) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.setAttributeTo = setAttributeTo;
  exports.mapEventEmission = mapEventEmission;
  exports.guid = guid;
  exports.throwError = throwError;
  exports.warn = warn;
  exports.isNumeric = isNumeric;
  exports.hue2rgb = hue2rgb;
  exports.hslToRgb = hslToRgb;
  exports.saveDomAttributes = saveDomAttributes;
  exports.hasSavedAttribute = hasSavedAttribute;
  exports.overwriteDomAttribute = overwriteDomAttribute;
  exports.restoreDomAttributes = restoreDomAttributes;
  exports.debounce = debounce;
  exports.SVGParser = SVGParser;
  exports.reverseArray = reverseArray;
  exports.getOffset = getOffset;
  exports.setCSS = setCSS;
  exports.ajaxGet = ajaxGet;
  exports.extend = extend;
  exports.mix = mix;
  exports.emptyDom = emptyDom;

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  /**
   * Easy set attribute method to apply to a SVG Element the attributes listed. Optional namespacing
   * @param {SVGElement} to - The SVG element to apply the attributes to
   * @param {Object<String,Any>} attr - A key/value hashmap of attributes
   * @param {String} [ ns = undefined ] - The namespace to use (with <code>setAttributeNS</code>). Default if without namespacing
   */
  function setAttributeTo(to, params, ns) {
    var i;

    if (ns) {
      for (i in params) {
        to.setAttributeNS(ns, i, params[i]);
      }
    } else {
      for (i in params) {
        to.setAttribute(i, params[i]);
      }
    }
  }

  /**
   * Maps old-style events defined within the creation (i.e. <code>{ onMouseOver: function() }</code>) to modern event listening <code>.on("mouseover")</code>
   * The function will read any object and select the ones starting with "on"
   * @params {Object} options - An option object to read the events from
   * @param {Object} source - The source object to which the options belong
   * @example util.mapEventEmission( this.options, this );
   */
  function mapEventEmission(options, source) {

    if (!source) {
      source = this;
    }

    var eventName;

    for (var i in options) {

      // Starts with onXXX
      if (i.indexOf('on') == 0 && typeof options[i] == 'function') {
        eventName = i.substring(2);
        eventName = eventName.substring(0, 1).toLowerCase() + eventName.substring(1);

        if (source.on) {

          (function (j) {

            source.on(eventName, function () {
              options[j].apply(source, arguments);
            });
          })(i);
        }
      }
    }
  }

  /**
   * @link http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
   * @return {String} a random id
   */
  function guid() {
    //
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
      var r = Math.random() * 16 | 0,
          v = c == 'x' ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  }

  function throwError(message) {
    console.error(message);
  }

  function warn(message) {
    console.warn(message);
  }

  /**
   * Checks if a variable is a numeric or not
   * @return {Boolean} <code>true</code> for a numeric value, false otherwise
   */
  function isNumeric(obj) {
    return !Array.isArray(obj) && obj - parseFloat(obj) + 1 >= 0;
  }

  /**
   * @see http://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion
   * Converts an HSL color value to RGB. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes h, s, and l are contained in the set [0, 1] and
   * returns r, g, and b in the set [0, 255].
   *
   * @param   Number  h       The hue
   * @param   Number  s       The saturation
   * @param   Number  l       The lightness
   * @return  Array           The RGB representation
   */
  function hue2rgb(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  }

  function hslToRgb(h, s, l) {
    var r, g, b;

    if (s == 0) {
      r = g = b = l; // achromatic
    } else {

      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }

    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
  }

  function saveDomAttributes(to, attributes, identification) {

    if (!to) return;

    to._savedAttributesIds = to._savedAttributesIds || [];

    if (to._savedAttributesIds.indexOf(identification) > -1) {
      restoreDomAttributes(to, identification);
    }

    to._savedAttributes = to._savedAttributes || {};
    to._attributes = to._attributes || {};
    to._attributes[identification] = attributes;

    to._savedAttributesIds.push(identification);

    for (var i in attributes) {

      if (!to._savedAttributes[i]) {
        to._savedAttributes[i] = to.getAttribute(i);
      }

      to.setAttribute(i, attributes[i]);
    }
  }

  function hasSavedAttribute(dom, attr) {
    return dom._savedAttributes && dom._savedAttributes[attr] !== undefined;
  }

  function overwriteDomAttribute(dom, attribute, newValue) {
    if (hasSavedAttribute(dom, attribute)) {
      dom._savedAttributes[attribute] = newValue;
    }
  }

  function restoreDomAttributes(to, identification) {

    if (!to || !to._savedAttributesIds) {
      return;
    }

    to._savedAttributesIds.splice(to._savedAttributesIds.indexOf(identification), 1);
    delete to._attributes[identification];

    var attrs = {};

    for (var i in to._savedAttributes) {
      attrs[i] = to._savedAttributes[i];
    }

    for (var i = 0, l = to._savedAttributesIds.length; i < l; i++) {

      for (var j in to._attributes[to._savedAttributesIds[i]]) {
        attrs[j] = to._attributes[to._savedAttributesIds[i]][j];
      }
    }

    for (var j in attrs) {
      to.setAttribute(j, attrs[j]);
    }
  }

  // https://davidwalsh.name/function-debounce
  function debounce(func, wait, immediate) {
    var timeout;
    return function () {
      var context = this,
          args = arguments;
      var later = function later() {
        timeout = null;
        if (!immediate) func.apply(context, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) func.apply(context, args);
    };
  }

  function SVGParser(svgString) {

    var parser = new DOMParser();
    var doc = parser.parseFromString(svgString, 'image/svg+xml');
    // returns a SVGDocument, which also is a Document.

    return doc;
  }

  // http://stackoverflow.com/questions/5276953/what-is-the-most-efficient-way-to-reverse-an-array-in-javascript
  function reverseArray(array) {
    var left = null;
    var right = null;
    var length = array.length;
    for (left = 0, right = length - 1; left < right; left += 1, right -= 1) {
      var temporary = array[left];
      array[left] = array[right];
      array[right] = temporary;
    }
    return array;
  }

  // jQuery.fn.offset
  function getOffset(el) {
    var rect = el.getBoundingClientRect();
    return {
      top: rect.top,
      left: rect.left
    };
  }

  // jQuery.fn.css
  function setCSS(element, values) {
    var style = element.style;
    for (var i in values) {
      style[i] = values[i];
    }
  }

  function ajaxGet(options) {
    return new Promise(function (resolve, reject) {
      var request = new XMLHttpRequest();
      request.open(options.type || 'GET', options.url, true);
      if (options.json) request.setRequestHeader('Accept', 'application/json');
      request.onload = function () {
        if (request.status === 200) {
          var response = request.responseText;
          if (options.json) response = JSON.parse(response);
          resolve(response);
        } else {
          reject(new Error('Request error: ' + request.status));
        }
      };
      request.onerror = function () {
        reject(new Error('Network error: ' + request.status));
      };
      request.send();
    });
  }

  // https://raw.githubusercontent.com/justmoon/node-extend/888f153645115d1c6aa9a7e346e8e9cd9a83de9b/index.js
  // Copyright (c) 2014 Stefan Thomas
  var hasOwn = Object.prototype.hasOwnProperty;
  var toStr = Object.prototype.toString;

  var isArray = function isArray(arr) {
    if (typeof Array.isArray === 'function') {
      return Array.isArray(arr);
    }

    return toStr.call(arr) === '[object Array]';
  };

  var isPlainObject = function isPlainObject(obj) {
    if (!obj || toStr.call(obj) !== '[object Object]') {
      return false;
    }

    var hasOwnConstructor = hasOwn.call(obj, 'constructor');
    var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
    // Not own constructor property must be Object
    if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
      return false;
    }

    // Own properties are enumerated firstly, so to speed up,
    // if last one is own, then all properties are own.
    var key;
    for (key in obj) {/**/}

    return typeof key === 'undefined' || hasOwn.call(obj, key);
  };

  function extend() {
    var options, name, src, copy, copyIsArray, clone;
    var target = arguments[0];
    var i = 1;
    var length = arguments.length;
    var deep = false;

    // Handle a deep copy situation
    if (typeof target === 'boolean') {
      deep = target;
      target = arguments[1] || {};
      // skip the boolean and the target
      i = 2;
    } else if ((typeof target === 'undefined' ? 'undefined' : _typeof(target)) !== 'object' && typeof target !== 'function' || target == null) {
      target = {};
    }

    for (; i < length; ++i) {
      options = arguments[i];
      // Only deal with non-null/undefined values
      if (options != null) {
        // Extend the base object
        for (name in options) {
          src = target[name];
          copy = options[name];

          // Prevent never-ending loop
          if (target !== copy) {
            // Recurse if we're merging plain objects or arrays
            if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && isArray(src) ? src : [];
              } else {
                clone = src && isPlainObject(src) ? src : {};
              }

              // Never move original objects, clone them
              target[name] = extend(deep, clone, copy);

              // Don't bring in undefined values
            } else if (typeof copy !== 'undefined') {
              target[name] = copy;
            }
          }
        }
      }
    }

    // Return the modified object
    return target;
  }

  exports.default = {};
  exports.isArray = isArray;
  exports.isPlainObject = isPlainObject;
  function mix(baseClass, mixin) {

    for (var prop in mixin) {

      if (mixin.hasOwnProperty(prop)) {
        baseClass.prototype[prop] = mixin[prop];
      }
    }
  }

  function emptyDom(dom) {
    while (dom.firstChild) {
      dom.removeChild(dom.firstChild);
    }
  }
});

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(58)('wks');
var uid = __webpack_require__(36);
var Symbol = __webpack_require__(2).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(3)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(1);
var IE8_DOM_DEFINE = __webpack_require__(104);
var toPrimitive = __webpack_require__(23);
var dP = Object.defineProperty;

exports.f = __webpack_require__(7) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(25);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(24);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(8);
var createDesc = __webpack_require__(35);
module.exports = __webpack_require__(7) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var hide = __webpack_require__(12);
var has = __webpack_require__(15);
var SRC = __webpack_require__(36)('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__(19).inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var fails = __webpack_require__(3);
var defined = __webpack_require__(24);
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};


/***/ }),
/* 15 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(52);
var defined = __webpack_require__(24);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(53);
var createDesc = __webpack_require__(35);
var toIObject = __webpack_require__(16);
var toPrimitive = __webpack_require__(23);
var has = __webpack_require__(15);
var IE8_DOM_DEFINE = __webpack_require__(104);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(7) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(15);
var toObject = __webpack_require__(10);
var IE_PROTO = __webpack_require__(77)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 19 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.7' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(11);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 21 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__(3);

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(4);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 24 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 25 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(0);
var core = __webpack_require__(19);
var fails = __webpack_require__(3);
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(20);
var IObject = __webpack_require__(52);
var toObject = __webpack_require__(10);
var toLength = __webpack_require__(9);
var asc = __webpack_require__(94);
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(55), __webpack_require__(5), __webpack_require__(56)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('../graph.position.js'), require('../graph.util.js'), require('../dependencies/eventEmitter/EventEmitter.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphPosition, global.graphUtil, global.EventEmitter);
    global.graphShape = mod.exports;
  }
})(this, function (module, exports, _graphPosition, _graphUtil, _EventEmitter2) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _graphPosition2 = _interopRequireDefault(_graphPosition);

  var util = _interopRequireWildcard(_graphUtil);

  var _EventEmitter3 = _interopRequireDefault(_EventEmitter2);

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var Shape = function (_EventEmitter) {
    _inherits(Shape, _EventEmitter);

    function Shape() {
      _classCallCheck(this, Shape);

      return _possibleConstructorReturn(this, (Shape.__proto__ || Object.getPrototypeOf(Shape)).call(this));
    }

    /**
     * Initializes the shape
     * @param {Graph} graph - The graph containing the shape
     * @param {Object} properties - The properties object (not copied)
     * @return {Shape} The current shape
     */


    _createClass(Shape, [{
      key: 'init',
      value: function init(graph, properties) {

        var self = this;

        this.graph = graph;
        this.properties = properties || {};
        this.handles = [];
        this.options = this.options || {};

        this.group = document.createElementNS(this.graph.ns, 'g');

        this.group.setAttribute('clip-path', 'url(#_clipplot' + graph._creation + ')');

        this._selected = false;
        this.createDom();

        if (this._dom) {
          this._dom.jsGraphIsShape = this;
        }

        this.group.jsGraphIsShape = this;

        this.classes = [];
        this.transforms = [];

        if (this._data.masker) {

          var maskPath = document.createElementNS(this.graph.ns, 'mask');
          this.maskingId = Math.random();
          maskPath.setAttribute('id', this.maskingId);

          this.maskDomWrapper = document.createElementNS(this.graph.ns, 'rect');
          this.maskDomWrapper.setAttribute('fill', 'white');
          maskPath.appendChild(this.maskDomWrapper);

          var maskDom = this._dom.cloneNode();
          maskPath.appendChild(maskDom);

          this.maskDom = maskDom;

          this.graph.defs.appendChild(maskPath);
        }

        if (this.group) {

          if (this._dom && !this.isHTML()) {
            this.group.appendChild(this._dom);
          }

          this.group.addEventListener('mouseover', function (e) {

            self.handleMouseOver(e);
          });

          this.group.addEventListener('mouseout', function (e) {

            self.handleMouseOut(e);
          });

          this.group.addEventListener('mousedown', function (e) {

            self.graph.focus();

            self.handleMouseDown(e);
          });

          this.group.addEventListener('click', this.handleClick.bind(this));

          this.group.addEventListener('dblclick', function (e) {

            //e.preventDefault();
            // e.stopPropagation();

            self.handleDblClick(e);
          });
        }

        //			this.group.appendChild(this.rectEvent);

        this.initImpl();

        this.graph.emit('shapeNew', this);

        return this;
      }
    }, {
      key: 'initImpl',
      value: function initImpl() {}
    }, {
      key: 'getData',
      value: function getData() {
        return this._data;
      }
    }, {
      key: 'getType',
      value: function getType() {
        return this.type;
      }
    }, {
      key: 'kill',
      value: function kill(keepDom) {

        if (this._inDom && !keepDom) {
          this.graph.removeShapeFromDom(this);
        }

        if (!keepDom) {
          this.graph._removeShape(this);
        }

        this.graph.stopElementMoving(this);
        this.graph.emit('shapeRemoved', this);
        this.emit('removed', this);

        this._inDom = false;
      }
    }, {
      key: 'hide',
      value: function hide() {

        if (this.hidden) {
          return this;
        }

        this.hidden = true;
        if (!this.isHTML()) {
          this.group.style.display = 'none';
        } else {
          this._dom.style.display = 'none';
        }
        return this;
      }
    }, {
      key: 'isHidden',
      value: function isHidden() {
        return this.hidden;
      }
    }, {
      key: 'isVisible',
      value: function isVisible() {
        return !this.hidden;
      }
    }, {
      key: 'show',
      value: function show() {

        if (!this.hidden) {
          return this;
        }

        this.hidden = false;
        if (!this.isHTML()) {
          this.group.style.display = 'initial';
        } else {
          this._dom.style.display = 'initial';
        }

        this.redraw();
        return this;
      }
    }, {
      key: 'addClass',
      value: function addClass(className) {
        this.classes = this.classes || [];
        if (this.classes.indexOf(className) == -1) {
          this.classes.push(className);
        }
        this.makeClasses();
        return this;
      }
    }, {
      key: 'removeClass',
      value: function removeClass(className) {
        this.classes.splice(this.classes.indexOf(className), 1);
        this.makeClasses();
        return this;
      }
    }, {
      key: 'makeClasses',
      value: function makeClasses() {

        if (this._dom) {
          this._dom.setAttribute('class', this.classes.join(' '));
        }

        return this;
      }
    }, {
      key: 'changed',
      value: function changed(event, parameters) {

        if (event) {
          this.graph.emit(event, this, parameters);
          this.emit(event, this, parameters);
        }

        this.emit('changed', this, parameters);
        this.graph.emit('shapeChanged', this, parameters);
        return this;
      }
    }, {
      key: 'setEventReceptacle',
      value: function setEventReceptacle() {

        if (!this.rectEvent) {
          this.rectEvent = document.createElementNS(this.graph.ns, 'rect');
          this.rectEvent.setAttribute('pointer-events', 'fill');
          this.rectEvent.setAttribute('fill', 'transparent');
          this.group.appendChild(this.rectEvent);
          this.rectEvent.jsGraphIsShape = this;
        }

        var box = this.group.getBBox();
        this.rectEvent.setAttribute('x', box.x);
        this.rectEvent.setAttribute('y', box.y - 10);
        this.rectEvent.setAttribute('width', box.width);
        this.rectEvent.setAttribute('height', box.height + 20);
      }
    }, {
      key: 'setSerie',
      value: function setSerie(serie) {

        if (!serie) {
          return;
        }

        this.serie = serie;

        if (!serie.getXAxis || !serie.getYAxis) {
          console.error(serie);
          throw 'Serie does not implement the getXAxis or getYAxis method';
        }
        this.xAxis = serie.getXAxis();
        this.yAxis = serie.getYAxis();
        return this;
      }
    }, {
      key: 'getSerie',
      value: function getSerie() {
        return this.serie;
      }
    }, {
      key: 'autoAxes',
      value: function autoAxes() {

        if (!this.xAxis) {
          this.xAxis = this.graph.getXAxis();
        }

        if (!this.yAxis) {
          this.yAxis = this.graph.getYAxis();
        }

        return this;
      }
    }, {
      key: 'setXAxis',
      value: function setXAxis(axis) {
        this.xAxis = axis;
        return this;
      }
    }, {
      key: 'setYAxis',
      value: function setYAxis(axis) {
        this.yAxis = axis;
      }
    }, {
      key: 'getXAxis',
      value: function getXAxis() {

        if (!this.xAxis) {
          this.autoAxes();
        }

        return this.xAxis;
      }
    }, {
      key: 'getYAxis',
      value: function getYAxis() {

        if (!this.yAxis) {
          this.autoAxes();
        }

        return this.yAxis;
      }
    }, {
      key: 'setLayer',
      value: function setLayer(layer) {
        this.setProp('layer', layer);
        return this;
      }
    }, {
      key: 'getLayer',
      value: function getLayer() {
        var layer = this.getProp('layer');

        if (layer !== undefined) {
          return layer;
        }

        return 1;
      }
    }, {
      key: 'draw',
      value: function draw(force, preventRedraw) {

        if (!this._inDom || force) {

          this.appendToDom();
          this._inDom = true;
        }

        this.makeLabels();

        if (!preventRedraw) {
          this.redraw();
        }

        this.applyStyle();

        return this;
      }
    }, {
      key: 'redraw',
      value: function redraw() {

        if (this.hidden) {
          return this;
        }

        this.position = this.applyPosition();

        this.redrawImpl();
        if (!this.position) {
          this.updateLabels();
          return this;
        }

        this.updateLabels();
        this._applyTransforms();
        return this;
      }
    }, {
      key: 'redrawImpl',
      value: function redrawImpl() {}
    }, {
      key: 'setProperties',
      value: function setProperties(properties) {
        this.properties = properties;

        if (!Array.isArray(this.properties.position)) {
          this.properties.position = [this.properties.position];
        }
        var self = this;
        for (var i = 0, l = this.properties.position.length; i < l; i++) {

          var pos = _graphPosition2.default.check(this.properties.position[i], function (relativeTo) {
            return self.getRelativePosition(relativeTo);
          });

          this.properties.position[i] = pos;
        }

        this.emit('propertiesChanged');
        return this;
      }
    }, {
      key: 'getRelativePosition',
      value: function getRelativePosition(relativePosition) {

        var result;
        if ((result = /position([0-9]*)/.exec(relativePosition)) !== null) {
          return this.getPosition(result[1]);
        } else if ((result = /labelPosition([0-9]*)/.exec(relativePosition)) !== null) {
          return this.getLabelPosition(result[1]);
        }
      }
    }, {
      key: 'getProperties',
      value: function getProperties(properties) {
        return this.properties;
      }
    }, {
      key: 'setProp',
      value: function setProp(prop, val, index) {
        this.properties = this.properties || {};
        this.properties[prop] = this.properties[prop] || [];
        this.properties[prop][index || 0] = val;
        this.emit('propertyChanged', prop);
        return this;
      }
    }, {
      key: 'getProp',
      value: function getProp(prop, index) {
        return (this.properties[prop] || [])[index || 0];
      }
    }, {
      key: 'getProps',
      value: function getProps(prop, index) {
        return this.properties[prop] || [];
      }
    }, {
      key: 'addProp',
      value: function addProp(prop, value) {
        this.properties[prop] = this.properties[prop] || [];
        this.properties[prop].push(value);
      }
    }, {
      key: 'resetProp',
      value: function resetProp(prop) {
        this.properties[prop] = [];
      }
    }, {
      key: 'setDom',
      value: function setDom(prop, val, noForce) {
        if (this._dom) {

          if (!noForce || !util.hasSavedAttribute(this._dom, prop)) {
            this._dom.setAttribute(prop, val);
          }
        }
      }
    }, {
      key: 'setDomGroup',
      value: function setDomGroup(prop, val) {
        if (this.group) {
          this.group.setAttribute(prop, val);
        }
      }
    }, {
      key: 'setStrokeColor',
      value: function setStrokeColor(color) {
        this.setProp('strokeColor', color);
        this.overwriteSavedProp('stroke', color);
        this.applySelectedStyle();
        return this;
      }
    }, {
      key: 'getStrokeColor',
      value: function getStrokeColor() {
        return this.getProp('strokeColor');
      }
    }, {
      key: 'setFillColor',
      value: function setFillColor(color) {

        this.setProp('fillColor', color);
        this.overwriteSavedProp('fill', color);
        this.applySelectedStyle();
        return this;
      }
    }, {
      key: 'getFillColor',
      value: function getFillColor() {
        return this.getProp('fillColor');
      }
    }, {
      key: 'setFillOpacity',
      value: function setFillOpacity(opacity) {
        this.setProp('fillOpacity', opacity);
        this.overwriteSavedProp('fill-opacity', opacity);
        this.applySelectedStyle();
        return this;
      }
    }, {
      key: 'setStrokeWidth',
      value: function setStrokeWidth(width) {
        this.setProp('strokeWidth', width);
        this.overwriteSavedProp('stroke-width', width);
        this.applySelectedStyle();
        return this;
      }
    }, {
      key: 'getStrokeWidth',
      value: function getStrokeWidth() {
        return this.getProp('strokeWidth');
      }
    }, {
      key: 'setStrokeDasharray',
      value: function setStrokeDasharray(dasharray) {
        this.setProp('strokeDasharray', dasharray);
        this.overwriteSavedProp('stroke-dasharray', dasharray);
        this.applySelectedStyle();
        return this;
      }
    }, {
      key: 'setAttributes',
      value: function setAttributes(attributes) {
        this.setProp('attributes', attributes);
        return this;
      }
    }, {
      key: 'overwriteSavedProp',
      value: function overwriteSavedProp(prop, newValue) {
        util.overwriteDomAttribute(this._dom, prop, newValue);
      }
    }, {
      key: 'addAttribute',
      value: function addAttribute(attributeName, attributeValue) {
        var added = {};
        added[attributeName] = attributeValue;
        this.addProp('attributes', added);
        return this;
      }
    }, {
      key: 'addTransform',
      value: function addTransform(type, args) {
        this.addProp('transforms', {
          type: type,
          arguments: Array.isArray(args) ? args : [args]
        });
        return this;
      }
    }, {
      key: 'resetTransforms',
      value: function resetTransforms() {
        this.resetProp('transforms');
        return this;
      }
    }, {
      key: 'setLabelText',
      value: function setLabelText(text) {
        var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        this.setProp('labelText', text, index);
        return this;
      }
    }, {
      key: 'setLabelData',
      value: function setLabelData(data, text) {
        var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

        this.setProp('labelData', text, index);
        return this;
      }
    }, {
      key: 'getLabelText',
      value: function getLabelText(text) {
        var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        return this.getProp('labelText', index);
      }
    }, {
      key: 'displayLabel',
      value: function displayLabel() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        this.setProp('labelVisible', true, index);
        return this;
      }
    }, {
      key: 'hideLabel',
      value: function hideLabel() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        this.setProp('labelVisible', false, index);
        return this;
      }
    }, {
      key: 'setLabelColor',
      value: function setLabelColor(color) {
        var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        this.setProp('labelColor', color, index);
        return this;
      }
    }, {
      key: 'setLabelFontSize',
      value: function setLabelFontSize(size) {
        var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        this.setProp('labelFontSize', size, index);
        return this;
      }
    }, {
      key: 'getLabelPosition',
      value: function getLabelPosition() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        return this.getProp('labelPosition', index);
      }
    }, {
      key: 'setLabelPosition',
      value: function setLabelPosition(position, index) {

        var self;
        var pos = _graphPosition2.default.check(position, function (relativeTo) {
          return self.getRelativePosition(relativeTo);
        });

        this.setProp('labelPosition', pos, index || 0);
        return this;
      }
    }, {
      key: 'setLabelAngle',
      value: function setLabelAngle(angle, index) {
        this.setProp('labelAngle', angle, index || 0);
        return this;
      }
    }, {
      key: 'setLabelBaseline',
      value: function setLabelBaseline(baseline, index) {
        this.setProp('labelBaseline', baseline, index || 0);
        return this;
      }
    }, {
      key: 'setLabelAnchor',
      value: function setLabelAnchor(anchor, index) {
        this.setProp('labelAnchor', anchor, index || 0);
        return this;
      }
    }, {
      key: 'setLabelSize',
      value: function setLabelSize(size, index) {
        this.setProp('labelSize', size, index || 0);
        return this;
      }
    }, {
      key: 'setLabelStrokeColor',
      value: function setLabelStrokeColor(color, index) {
        this.setProp('labelStrokeColor', color, index || 0);
        return this;
      }
    }, {
      key: 'setLabelStrokeWidth',
      value: function setLabelStrokeWidth(width, index) {
        this.setProp('labelStrokeWidth', width, index || 0);
        return this;
      }
    }, {
      key: 'setLabelBackgroundColor',
      value: function setLabelBackgroundColor(color, index) {
        this.setProp('labelBackgroundColor', color, index || 0);
        return this;
      }
    }, {
      key: 'setLabelBackgroundOpacity',
      value: function setLabelBackgroundOpacity(opacity, index) {
        this.setProp('labelBackgroundOpacity', opacity, index || 0);
        return this;
      }
    }, {
      key: 'applyGenericStyle',
      value: function applyGenericStyle() {

        this.setDom('fill', this.getProp('fillColor'), true);
        this.setDom('fill-opacity', this.getProp('fillOpacity'), true);
        this.setDom('stroke', this.getProp('strokeColor'), true);
        this.setDom('stroke-width', this.getProp('strokeWidth'), true);
        this.setDom('stroke-dasharray', this.getProp('strokeDasharray'), true);

        var attributes = this.getProps('attributes');
        for (var j = 0, l = attributes.length; j < l; j++) {

          for (var i in attributes[j]) {
            this.setDom(i, typeof attributes[j][i] == 'function' ? attributes[j][i].call(this, i) : attributes[j][i], true);
          }
        }

        this._applyTransforms();

        return this;
      }
    }, {
      key: 'applyStyle',
      value: function applyStyle() {

        return this.applyGenericStyle();
      }
    }, {
      key: 'calculatePosition',
      value: function calculatePosition(index) {

        var position;

        position = index instanceof _graphPosition2.default ? index : this.getPosition(index);

        if (!position) {
          return;
        }

        if (position && position.compute) {
          return position.compute(this.graph, this.getXAxis(), this.getYAxis(), this.getSerie());
        }

        this.graph.throw();
      }
    }, {
      key: 'getPosition',
      value: function getPosition(index) {

        var pos = this.getProp('position', index || 0);
        this.setProp('position', pos = _graphPosition2.default.check(pos), index);
        return pos;
      }
    }, {
      key: 'setPosition',
      value: function setPosition(position, index) {

        var self = this;
        var pos = _graphPosition2.default.check(position, function (relativeTo) {
          return self.getRelativePosition(relativeTo);
        });

        return this.setProp('position', pos, index || 0);
      }
    }, {
      key: 'sortPositions',
      value: function sortPositions(sortFunction) {
        this.getProps('position').sort(sortFunction);
        return this;
      }
    }, {
      key: '_applyTransforms',
      value: function _applyTransforms() {

        var transforms = this.getProp('transforms'),
            transformString = '';

        if (!transforms) {
          return;
        }
        transforms = Array.isArray(transforms) ? transforms : [transforms];

        if (transforms.length == 0) {
          return;
        }

        for (var i = 0; i < transforms.length; i++) {

          transformString += transforms[i].type + '(';

          switch (transforms[i].type) {

            case 'translate':

              var transform = transforms[i].arguments[0].compute(this.graph, this.getXAxis(), this.getYAxis(), this.getSerie());

              transformString += transform.x;
              transformString += ', ';
              transformString += transform.y;
              break;

            case 'rotate':

              transformString += transforms[i].arguments[0];
              transformString += ', ';

              if (transforms[i].arguments.length == 1) {
                var p = this.computePosition(0);
                transformString += p.x + ', ' + p.y;
              } else {

                transformString += _graphPosition2.default.getDeltaPx(transforms[i].arguments[1], this.getXAxis()).replace('px', '');
                transformString += ', ';
                transformString += _graphPosition2.default.getDeltaPx(transforms[i].arguments[2], this.getYAxis()).replace('px', '');
              }

              break;
          }

          transformString += ') ';
        }

        this.setDomGroup('transform', transformString);
        return this;
      }
    }, {
      key: 'makeLabels',
      value: function makeLabels() {
        var _this2 = this;

        this._labels = this._labels || [];
        this._labelsBackground = this._labelsBackground || [];

        this._labels.map(function (label) {
          _this2.group.removeChild(label);
        });

        this._labelsBackground.map(function (bg) {
          _this2.group.removeChild(bg);
        });

        this._labels = [];
        this._labelsBackground[i] = [];

        var i = 0;

        while (this.getProp('labelText', i) !== undefined) {

          if (!this._labels[i]) {

            this._labels[i] = document.createElementNS(this.graph.ns, 'text');
            this._labels[i].setAttribute('data-label-i', i);
            this._labels[i].jsGraphIsShape = this;

            this._labelsBackground[i] = document.createElementNS(this.graph.ns, 'rect');
            this._labelsBackground[i].setAttribute('data-label-i', i);
            this._labelsBackground[i].jsGraphIsShape = this;

            this.group.appendChild(this._labelsBackground[i]);
            this.group.appendChild(this._labels[i]);

            this._labels[i].addEventListener('dblclick', function (e) {
              e.stopPropagation();

              _this2.labelDblClickListener(e);
            });

            this._labelsBackground[i].addEventListener('dblclick', function (e) {
              e.stopPropagation();

              _this2.labelDblClickListener(e);
            });
          }

          i++;
        }

        this.updateLabels();

        return this;
      }
    }, {
      key: 'isLabelEditable',
      value: function isLabelEditable(labelIndex) {
        return this.getProp('labelEditable', labelIndex || 0);
      }
    }, {
      key: 'updateLabels',
      value: function updateLabels() {

        var self = this;
        this._labels = this._labels || [];

        for (var i = 0, l = this._labels.length; i < l; i++) {
          this._applyLabelData(i);
        }
      }
    }, {
      key: '_applyLabelData',
      value: function _applyLabelData(labelIndex) {

        labelIndex = labelIndex || 0;

        /** Sets the position */

        var visible = this.getProp('labelVisible', labelIndex);

        if (visible === false) {
          this._labels[labelIndex].setAttribute('display', 'none');
          this._labelsBackground[labelIndex].setAttribute('display', 'none');
          return;
        } else {
          this._labels[labelIndex].setAttribute('display', 'initial');
          this._labelsBackground[labelIndex].setAttribute('display', 'initial');
        }

        var position = this.calculatePosition(_graphPosition2.default.check(this.getProp('labelPosition', labelIndex)));

        if (isNaN(position.x) || isNaN(position.y) || position.y === false || position.x === false) {
          /*console.warn( "Cannot compute positioning for labelIndex " + labelIndex + " with text " + this.getProp( "labelText", labelIndex ) );
          console.log( this, this._labels );
          console.trace();*/
          return;
        }

        if (position.x != 'NaNpx' && !isNaN(position.x) && position.x !== 'NaN' && position.x !== false) {

          this._labels[labelIndex].setAttribute('x', position.x);
          this._labels[labelIndex].setAttribute('y', position.y);
        }

        /** Sets the angle */
        var currAngle = this.getProp('labelAngle', labelIndex) || 0;
        if (currAngle != 0) {

          var x = this._labels[labelIndex].getAttribute('x'),
              y = this._labels[labelIndex].getAttribute('y');

          this._labels[labelIndex].setAttribute('transform', 'rotate(' + currAngle + ' ' + x + ' ' + y + ')');
          //  this._labelsBackground[ labelIndex ].setAttribute( 'transform', 'rotate(' + currAngle + ' ' + x + ' ' + y + ')' );
        }

        var labelData = this.getProp('labelHTMLData', labelIndex) || {};

        for (var i in labelData) {

          this._labels[labelIndex].setAttribute(i, labelData[i]);
          this._labelsBackground[labelIndex].setAttribute(i, labelData[i]);
        }

        /** Sets the baseline */
        this._labels[labelIndex].setAttribute('dominant-baseline', this.getProp('labelBaseline', labelIndex) || 'no-change');

        /** Sets the text */
        this._labels[labelIndex].textContent = this.getProp('labelText', labelIndex);

        /** Sets the color */
        this._labels[labelIndex].setAttribute('fill', this.getProp('labelColor', labelIndex) || 'black');

        /** Sets the size */
        this._labels[labelIndex].setAttribute('font-size', this.getProp('labelSize', labelIndex) + 'px' || '12px');

        /** Sets the anchor */
        this._labels[labelIndex].setAttribute('text-anchor', this._getLabelAnchor(labelIndex));

        /** Sets the stroke */
        this._labels[labelIndex].setAttribute('stroke', this.getProp('labelStrokeColor', labelIndex) || 'black');

        /** Sets the stroke */
        this._labels[labelIndex].setAttribute('stroke-width', this.getProp('labelStrokeWidth', labelIndex) || 0 + 'px');

        this._labels[labelIndex].setAttribute('stroke-location', 'outside');

        var rect = this._labels[labelIndex].getBBox();

        this._labelsBackground[labelIndex].setAttribute('x', rect.x);
        this._labelsBackground[labelIndex].setAttribute('y', rect.y);
        this._labelsBackground[labelIndex].setAttribute('width', rect.width);
        this._labelsBackground[labelIndex].setAttribute('height', rect.height);

        this._labelsBackground[labelIndex].setAttribute('fill', this.getProp('labelBackgroundColor') || 'transparent');
        this._labelsBackground[labelIndex].setAttribute('fill-opacity', this.getProp('labelBackgroundOpacity') || 1);

        return this;
      }
    }, {
      key: 'emptyLabels',
      value: function emptyLabels() {

        for (var i = 0, l = this._labels.length; i < l; i++) {
          /** Sets the baseline */
          this._labels[i].textContent = '';
        }

        return this;
      }
    }, {
      key: '_getLabelAnchor',
      value: function _getLabelAnchor(labelIndex) {
        var anchor = this.getProp('labelAnchor', labelIndex);
        switch (anchor) {
          case 'middle':
          case 'start':
          case 'end':
            return anchor;
            break;

          case 'right':
            return 'end';
            break;

          case 'left':
            return 'start';
            break;

          default:
            return 'start';
            break;
        }
      }
    }, {
      key: 'isSelected',
      value: function isSelected() {
        return this._selectStatus || false;
      }
    }, {
      key: 'hasHandles',
      value: function hasHandles(setter) {

        if (setter !== undefined) {
          this.setProp('handles', setter);
        }

        return !!this.getProp('handles') || !!this.getProp('staticHandles');
      }
    }, {
      key: 'addHandles',
      value: function addHandles() {

        if (this.isLocked()) {
          return;
        }

        if (!this.handlesInDom) {

          this.handlesInDom = true;

          for (var i = 1; i < this.handles.length; i++) {

            if (this.handles[i]) {
              this.group.appendChild(this.handles[i]);
            }
          }
        }

        return this;
      }
    }, {
      key: 'removeHandles',
      value: function removeHandles() {

        this.hideHandles();
        this.handles = [];
      }
    }, {
      key: 'hideHandles',
      value: function hideHandles() {

        if (!this.handlesInDom) {
          return this;
        }

        for (var i = 1; i < this.handles.length; i++) {
          this.group.removeChild(this.handles[i]);
        }

        this.handlesInDom = false;
        return this;
      }
    }, {
      key: 'areHandlesInDom',
      value: function areHandlesInDom() {

        return this.handlesInDom;
      }
    }, {
      key: '_select',
      value: function _select(mute) {

        if (!this.isSelectable()) {
          return false;
        }

        // Put on the stack
        this.appendToDom();
        //this.graph.appendShapeToDom( this ); // Put the shape on top of the stack !

        this._selectStatus = true;

        this.applySelectedStyle();

        if (this.hasHandles() && !this.hasStaticHandles()) {

          this.addHandles();
          this.setHandles();
        }

        if (!mute) {
          this.graph.emit('shapeSelected', this);
        }
      }
    }, {
      key: 'applySelectedStyle',
      value: function applySelectedStyle() {

        if (!this._selectStatus) {
          return;
        }

        var style = this.getSelectStyle();
        var style2 = {};
        for (var i in style) {
          if (typeof style[i] == 'function') {
            style2[i] = style[i].call(this);
          } else {
            style2[i] = style[i];
          }
        }

        util.saveDomAttributes(this._dom, style2, 'select');
      }
    }, {
      key: '_unselect',
      value: function _unselect(mute) {

        this._selectStatus = false;

        util.restoreDomAttributes(this._dom, 'select');

        if (this.hasHandles() && !this.hasStaticHandles()) {
          this.hideHandles();
        }

        if (!mute) {
          this.graph.emit('shapeUnselected', this);
        }
      }
    }, {
      key: 'getSelectStyle',
      value: function getSelectStyle() {
        return this.selectStyle;
      }
    }, {
      key: 'setSelectStyle',
      value: function setSelectStyle(attr) {
        this.selectStyle = attr;
        this.applySelectedStyle(); // Maybe the shape is already selected
        return this;
      }
    }, {
      key: 'setStaticHandles',
      value: function setStaticHandles(staticHandles) {
        this.setProp('staticHandles', staticHandles);
      }
    }, {
      key: 'hasStaticHandles',
      value: function hasStaticHandles(staticHandles) {
        return !!this.getProp('staticHandles');
      }
    }, {
      key: '_createHandles',
      value: function _createHandles(nb, type, attr, callbackEach) {
        var _this3 = this;

        if (this.handles && this.handles.length > 0) {
          return;
        }

        var self = this;

        for (var i = 1, l = nb; i <= l; i++) {

          (function (j) {

            var self = _this3;

            var handle = document.createElementNS(self.graph.ns, type);
            handle.jsGraphIsShape = true;

            if (attr) {
              for (var k in attr) {
                handle.setAttribute(k, attr[k]);
              }
            }

            handle.addEventListener('mousedown', function (e) {

              if (self.isResizable()) {

                e.preventDefault();
                e.stopPropagation();

                self.graph.emit('beforeShapeResize', self);
                _this3.emit('beforeShapeResize');

                if (!self.graph.prevent(false)) {

                  self.resizing = true;
                  self.handleSelected = j;
                  self.handleMouseDown(e);
                }
              }
            });

            if (callbackEach) {
              callbackEach(self.handles[j]);
            }

            self.handles[j] = handle;
          }).call(this, i);
        }

        return this.handles;
      }
    }, {
      key: 'createHandles',
      value: function createHandles() {

        if (this.hasStaticHandles()) {
          this.addHandles();
          this.setHandles();
        }
      }
    }, {
      key: 'handleMouseDownImpl',
      value: function handleMouseDownImpl() {}
    }, {
      key: 'handleMouseMoveImpl',
      value: function handleMouseMoveImpl() {}
    }, {
      key: 'handleMouseUpImpl',
      value: function handleMouseUpImpl() {}
    }, {
      key: 'handleCreateImpl',
      value: function handleCreateImpl() {}
    }, {
      key: 'handleMouseDown',
      value: function handleMouseDown(e) {

        //this.handleSelected = false;

        if (this.isLocked()) {
          return;
        }

        if (this.isMovable() || this.isResizable()) {

          this.graph.elementMoving(this);
        }

        if (this.getProp('selectOnMouseDown')) {
          this.graph.selectShape(this);
        }

        if (this.isMovable()) {
          if (!this.resizing) {

            this.graph.emit('beforeShapeMove', self);

            if (!this.graph.prevent(false)) {

              this.moving = true;
              this.moved = false;
            }
          }
        }

        this._mouseCoords = this.graph._getXY(e);
        return this.handleMouseDownImpl(e, this._mouseCoords);
      }
    }, {
      key: 'handleClick',
      value: function handleClick(e) {

        this.graph.emit('shapeClicked', this);
        this.emit('shapeClicked');

        if (!this.isSelectable()) {
          return false;
        }

        if (!e.shiftKey) {
          this.graph.unselectShapes();
        }

        if (this.getProp('selectOnClick')) {

          this.graph.selectShape(this);
        }
      }
    }, {
      key: 'handleMouseMove',
      value: function handleMouseMove(e) {
        //console.log( this.resizinh, this.moving, this.isSelected(), this._mouseCoords );
        if ((this.resizing || this.moving) && !this.isSelected()) {
          this.graph.selectShape(this);
        }

        this.graph.emit('beforeShapeMouseMove', this);
        this.emit('beforeShapeMouseMove');

        if (this.graph.prevent(false) || !this._mouseCoords) {
          return false;
        }

        this.moved = true;
        var coords = this.graph._getXY(e);
        var deltaX = this.getXAxis().getRelVal(coords.x - this._mouseCoords.x),
            deltaY = this.getYAxis().getRelVal(coords.y - this._mouseCoords.y);

        if (deltaX != 0 || deltaY !== 0) {
          this.preventUnselect = true;
        }

        this._mouseCoords = coords;

        var ret = this.handleMouseMoveImpl(e, deltaX, deltaY, coords.x - this._mouseCoords.x, coords.y - this._mouseCoords.y);

        return ret;
      }
    }, {
      key: 'handleMouseUp',
      value: function handleMouseUp(e) {

        if (this.moving && this.moved) {

          this.graph.emit('shapeMoved', this);
          this.emit('shapeMoved');
        }

        if (this.handleSelected || this.resize) {

          this.graph.emit('shapeResized', this);
          this.emit('shapeResized');
        }

        this.moving = false;
        this.resizing = false;
        this.handleSelected = false;
        this.graph.elementMoving(false);

        return this.handleMouseUpImpl(e);
      }
    }, {
      key: 'handleDblClick',
      value: function handleDblClick(e) {}
    }, {
      key: 'handleMouseOver',
      value: function handleMouseOver() {

        if (this.getProp('highlightOnMouseOver')) {

          if (!this.moving && !this.resizing) {
            this.highlight();
          }
        }

        this.graph.emit('shapeMouseOver', this);
      }
    }, {
      key: 'handleMouseOut',
      value: function handleMouseOut() {

        if (this.getProp('highlightOnMouseOver')) {
          this.unHighlight();
        }

        this.graph.emit('shapeMouseOut', this);
      }
    }, {
      key: 'lock',
      value: function lock() {
        this.setProp('locked', true);
        return this;
      }
    }, {
      key: 'unlock',
      value: function unlock() {
        this.setProp('locked', false);
        return this;
      }
    }, {
      key: 'isLocked',
      value: function isLocked() {
        return this.getProp('locked') || this.graph.shapesLocked;
      }
    }, {
      key: 'movable',
      value: function movable(bln) {
        this.setProp('movable', true);
      }
    }, {
      key: 'unmovable',
      value: function unmovable() {
        this.setProp('movable', false);
        return false;
      }
    }, {
      key: 'isMovable',
      value: function isMovable() {
        return this.getProp('movable');
      }
    }, {
      key: 'resizable',
      value: function resizable() {
        this.setProp('resizable', true);
      }
    }, {
      key: 'unresizable',
      value: function unresizable() {
        this.setProp('resizable', false);
      }
    }, {
      key: 'isResizable',
      value: function isResizable() {
        return this.getProp('resizable');
      }
    }, {
      key: 'selectable',
      value: function selectable() {
        this.setProp('selectable', true);
      }
    }, {
      key: 'unselectable',
      value: function unselectable() {
        this.graph.unselectShape(this);
        this.setProp('selectable', false);
      }
    }, {
      key: 'isSelectable',
      value: function isSelectable() {
        return this.getProp('selectable');
      }
    }, {
      key: 'highlight',
      value: function highlight(attributes, saveDomName) {

        if (!attributes) {
          attributes = this.getHighlightAttributes();
        }

        if (!saveDomName) {
          saveDomName = 'highlight';
        }

        util.saveDomAttributes(this._dom, attributes, saveDomName);
        this.highlightImpl();
        return this;
      }
    }, {
      key: 'unHighlight',
      value: function unHighlight(saveDomName) {

        if (!saveDomName) {
          saveDomName = 'highlight';
        }

        util.restoreDomAttributes(this._dom, saveDomName);
        this.unHighlightImpl();
        return this;
      }
    }, {
      key: 'highlightImpl',
      value: function highlightImpl() {}
    }, {
      key: 'unHighlightImpl',
      value: function unHighlightImpl() {}
    }, {
      key: 'getHighlightAttributes',
      value: function getHighlightAttributes() {
        return this._highlightAttributes;
      }
    }, {
      key: 'setHighlightAttributes',
      value: function setHighlightAttributes(attributes) {
        this._highlightAttributes = attributes;
        return this;
      }
    }, {
      key: 'getMaskingID',
      value: function getMaskingID() {
        return this.maskingId;
      }
    }, {
      key: 'maskWith',
      value: function maskWith(maskingShape) {

        var maskingId = maskingShape.getMaskingID();

        if (maskingId) {

          this._dom.setAttribute('mask', 'url(#' + maskingId + ')');
        } else {

          this._dom.removeAttribute('mask');
        }
      }
    }, {
      key: 'updateMask',
      value: function updateMask() {
        return;
        if (!this.maskDom) {
          return; // eslint-disable-line no-useless-return
        }

        var position = {
          x: 'min',
          y: 'min'
        };
        var position2 = {
          x: 'max',
          y: 'max'
        };

        position = this._getPosition(position);
        position2 = this._getPosition(position2);

        this.maskDomWrapper.setAttribute('x', Math.min(position.x, position2.x));
        this.maskDomWrapper.setAttribute('y', Math.min(position.y, position2.y));

        this.maskDomWrapper.setAttribute('width', Math.abs(position2.x - position.x));
        this.maskDomWrapper.setAttribute('height', Math.abs(position2.y - position.y));

        for (var i = 0; i < this._dom.attributes.length; i++) {
          this.maskDom.setAttribute(this._dom.attributes[i].name, this._dom.attributes[i].value);
        }

        this.maskDom.setAttribute('fill', 'black');

        return this;
      }
    }, {
      key: 'labelDblClickListener',
      value: function labelDblClickListener(e) {

        var i = parseInt(e.target.getAttribute('data-label-i'));

        var self = this;

        if (isNaN(i)) {
          return;
        }

        if (!this.isLabelEditable(i)) {
          return;
        }

        e.preventDefault();
        e.stopPropagation();

        var shapeLabel = document.createElement('input');
        shapeLabel.setAttribute('type', 'text');
        shapeLabel.setAttribute('value', self.getProp('labelText', i));

        self.graph.wrapper.prepend(shapeLabel);
        shapeLabel.select();

        util.setCSS(shapeLabel, {
          position: 'absolute',
          marginTop: parseInt(e.target.getAttribute('y').replace('px', '')) + this.graph.getPaddingTop() - 10 + 'px',
          marginLeft: parseInt(e.target.getAttribute('x').replace('px', '')) + this.graph.getPaddingLeft() - 50 + 'px',
          textAlign: 'center',
          width: '100px'
        });

        var previousValue = self.getLabelText(i);

        var blurEvent = function blurEvent() {

          self.setLabelText(shapeLabel.value, i);
          self._labels[i].textContent = shapeLabel.value;

          var nextValue = shapeLabel.value;

          shapeLabel.remove();
          shapeLabel.removeEventListener('blur', blurEvent);
          shapeLabel = false;

          self.changed('shapeLabelChanged', {
            previousValue: previousValue,
            nextValue: nextValue
          });
        };

        shapeLabel.addEventListener('blur', blurEvent);

        shapeLabel.addEventListener('keyup', function (e) {

          if (e.keyCode === 13) {
            blurEvent();
          }
        });
        shapeLabel.addEventListener('keypress', function (e) {
          e.stopPropagation();
        });
        shapeLabel.addEventListener('keydown', function (e) {
          e.stopPropagation();
        });
        shapeLabel.focus();
      }
    }, {
      key: 'appendToDom',
      value: function appendToDom() {

        if (this._forcedParentDom) {

          this._forcedParentDom.appendChild(this.group);
        } else {
          this.graph.appendShapeToDom(this);
        }
        return this;
      }
    }, {
      key: 'forceParentDom',
      value: function forceParentDom(dom) {

        this._forcedParentDom = dom;

        return this;
      }
    }, {
      key: 'isHTML',
      value: function isHTML() {
        return false;
      }
    }]);

    return Shape;
  }(_EventEmitter3.default);

  /**
   * @alias Shape#calculatePosition
   */
  Shape.prototype.computePosition = Shape.prototype.calculatePosition;

  /**
   * @alias Shape#displayLabel
   */
  Shape.prototype.showLabel = Shape.prototype.displayLabel;

  /**
   * @alias Shape#kill
   */
  Shape.prototype.remove = Shape.prototype.kill;

  exports.default = Shape;
  module.exports = exports['default'];
});

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(56)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('../dependencies/eventEmitter/EventEmitter.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.EventEmitter);
    global.graphPlugin = mod.exports;
  }
})(this, function (module, exports, _EventEmitter2) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _EventEmitter3 = _interopRequireDefault(_EventEmitter2);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var Plugin = function (_EventEmitter) {
    _inherits(Plugin, _EventEmitter);

    _createClass(Plugin, null, [{
      key: 'default',
      value: function _default() {
        return {};
      }
    }]);

    function Plugin(options) {
      _classCallCheck(this, Plugin);

      var _this = _possibleConstructorReturn(this, (Plugin.__proto__ || Object.getPrototypeOf(Plugin)).apply(this, arguments));

      _this.options = Object.assign({}, Plugin.default(), _this.constructor.default(), options);
      return _this;
    }

    /**
     * Init function called by jsGraph on load
     */


    _createClass(Plugin, [{
      key: 'init',
      value: function init(graph) {
        this.graph = graph;
      }
    }, {
      key: 'onMouseDown',
      value: function onMouseDown() {}
    }, {
      key: 'onMouseUp',
      value: function onMouseUp() {}
    }, {
      key: 'onMouseMove',
      value: function onMouseMove() {}
    }]);

    return Plugin;
  }(_EventEmitter3.default);

  exports.default = Plugin;
  module.exports = exports['default'];
});

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

if (__webpack_require__(7)) {
  var LIBRARY = __webpack_require__(33);
  var global = __webpack_require__(2);
  var fails = __webpack_require__(3);
  var $export = __webpack_require__(0);
  var $typed = __webpack_require__(69);
  var $buffer = __webpack_require__(100);
  var ctx = __webpack_require__(20);
  var anInstance = __webpack_require__(42);
  var propertyDesc = __webpack_require__(35);
  var hide = __webpack_require__(12);
  var redefineAll = __webpack_require__(44);
  var toInteger = __webpack_require__(25);
  var toLength = __webpack_require__(9);
  var toIndex = __webpack_require__(130);
  var toAbsoluteIndex = __webpack_require__(38);
  var toPrimitive = __webpack_require__(23);
  var has = __webpack_require__(15);
  var classof = __webpack_require__(54);
  var isObject = __webpack_require__(4);
  var toObject = __webpack_require__(10);
  var isArrayIter = __webpack_require__(91);
  var create = __webpack_require__(39);
  var getPrototypeOf = __webpack_require__(18);
  var gOPN = __webpack_require__(40).f;
  var getIterFn = __webpack_require__(93);
  var uid = __webpack_require__(36);
  var wks = __webpack_require__(6);
  var createArrayMethod = __webpack_require__(27);
  var createArrayIncludes = __webpack_require__(59);
  var speciesConstructor = __webpack_require__(66);
  var ArrayIterators = __webpack_require__(96);
  var Iterators = __webpack_require__(49);
  var $iterDetect = __webpack_require__(63);
  var setSpecies = __webpack_require__(41);
  var arrayFill = __webpack_require__(95);
  var arrayCopyWithin = __webpack_require__(120);
  var $DP = __webpack_require__(8);
  var $GOPD = __webpack_require__(17);
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

var Map = __webpack_require__(125);
var $export = __webpack_require__(0);
var shared = __webpack_require__(58)('metadata');
var store = shared.store || (shared.store = new (__webpack_require__(128))());

var getOrCreateMetadataMap = function (target, targetKey, create) {
  var targetMetadata = store.get(target);
  if (!targetMetadata) {
    if (!create) return undefined;
    store.set(target, targetMetadata = new Map());
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if (!keyMetadata) {
    if (!create) return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  } return keyMetadata;
};
var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function (target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });
  return keys;
};
var toMetaKey = function (it) {
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function (O) {
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(36)('meta');
var isObject = __webpack_require__(4);
var has = __webpack_require__(15);
var setDesc = __webpack_require__(8).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(3)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),
/* 33 */
/***/ (function(module, exports) {

module.exports = false;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(6)('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(12)(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};


/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 36 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(106);
var enumBugKeys = __webpack_require__(78);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(25);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(1);
var dPs = __webpack_require__(107);
var enumBugKeys = __webpack_require__(78);
var IE_PROTO = __webpack_require__(77)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(75)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(79).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(106);
var hiddenKeys = __webpack_require__(78).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(2);
var dP = __webpack_require__(8);
var DESCRIPTORS = __webpack_require__(7);
var SPECIES = __webpack_require__(6)('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(20);
var call = __webpack_require__(118);
var isArrayIter = __webpack_require__(91);
var anObject = __webpack_require__(1);
var toLength = __webpack_require__(9);
var getIterFn = __webpack_require__(93);
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(13);
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(55), __webpack_require__(5), __webpack_require__(56), __webpack_require__(46)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('./graph.position.js'), require('./graph.util.js'), require('./dependencies/eventEmitter/EventEmitter.js'), require('./util/waveform.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphPosition, global.graphUtil, global.EventEmitter, global.waveform);
    global.graphCore = mod.exports;
  }
})(this, function (module, exports, _graphPosition, _graphUtil, _EventEmitter2, _waveform) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _graphPosition2 = _interopRequireDefault(_graphPosition);

  var util = _interopRequireWildcard(_graphUtil);

  var _EventEmitter3 = _interopRequireDefault(_EventEmitter2);

  var _waveform2 = _interopRequireDefault(_waveform);

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  var _slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  /**
   * Default graph parameters
   * @name Graph~GraphOptionsDefault
   * @name GraphOptions
   * @object
   * @static
   * @memberof Graph
   * @prop {String} title - Title of the graph
   * @prop {Number} paddingTop - The top padding
   * @prop {Number} paddingLeft - The left padding
   * @prop {Number} paddingRight - The right padding
   * @prop {Number} paddingBottom - The bottom padding
   * @prop {(Number|Boolean)} padding - A common padding value for top, bottom, left and right
   * @prop {Number} fontSize - The basic text size of the graphs
   * @prop {Number} fontFamily - The basic font family. Should be installed on the computer of the user
   * @prop {Object.<String,Object>} plugins - A list of plugins to import with their options
   * @prop {Object.<String,Object>} pluginAction - The default key combination to access those actions
   * @prop {Object.<String,Object>} mouseActions - Alias of pluginActions
   * @prop {Object.<String,Object>} keyActions - Defines what happens when keys are pressed
   * @prop {Object} wheel - Define the mouse wheel action
   * @prop {Object} dblclick - Define the double click action
   * @prop {Boolean} shapesUniqueSelection - true to allow only one shape to be selected at the time
   * @prop {Boolean} shapesUnselectOnClick - true to unselect all shapes on click
   */
  var GraphOptionsDefault = {

    title: '',

    paddingTop: 30,
    paddingBottom: 5,
    paddingLeft: 20,
    paddingRight: 20,

    close: {
      left: true,
      right: true,
      top: true,
      bottom: true
    },

    closeColor: 'black',

    fontSize: 12,
    fontFamily: 'Myriad Pro, Helvetica, Arial',

    plugins: {},
    pluginAction: {},
    mouseActions: [],
    keyActions: [],
    wheel: {},
    dblclick: {},

    shapesUnselectOnClick: true,
    shapesUniqueSelection: true
  };

  var defaultScatterStyle = {
    shape: 'circle',
    r: 4
  };

  var _constructors = new Map();

  /**
   * Entry class of jsGraph that creates a new graph.
   * @extends EventEmitter
   * @tutorial basic
   */

  var Graph = function (_EventEmitter) {
    _inherits(Graph, _EventEmitter);

    /**
     * Graph constructor
     * @param {(HTMLElement|String)} [wrapper ] - The DOM Wrapper element its ```id``` property. If you do not use the wrapper during the graph creation, use it with the @link{Graph.setWrapper} method
     * @param {GraphOptions} [ options ] - The options of the graph
     * @param {Object} [ axis ] - The list of axes
     * @param {Array} axis.left - The list of left axes
     * @param {Array} axis.bottom - The list of bottom axes
     * @param {Array} axis.top - The list of top axes
     * @param {Array} axis.right - The list of right axes
     * @example var graph = new Graph("someDomID");
     * @example var graph = new Graph("someOtherDomID", { title: 'Graph title', paddingRight: 100 } );
     */
    function Graph(wrapper, options, axis) {
      _classCallCheck(this, Graph);

      var _this = _possibleConstructorReturn(this, (Graph.__proto__ || Object.getPrototypeOf(Graph)).call(this));

      /*
        The unique ID of the graph
        @name Graph#uniqueid
        @type String
      */
      _this._creation = util.guid();
      _this._drawn = false;

      if (wrapper === Object(wrapper) && !(wrapper instanceof HTMLElement)) {
        // Wrapper is options
        axis = options;
        options = wrapper;
        wrapper = null;
      } else if (typeof wrapper == 'string') {
        wrapper = document.getElementById(wrapper);
      } else if (typeof wrapper.length == 'number') {
        wrapper = wrapper[0];
      }

      /**
       * @object
       * @memberof Graph
       * @name Graph#options
       * @type GraphOptions
       * @default {@link GraphOptionsDefault}
       * Access directly the options of the graph using this public object.
       * @example graph.options.mouseActions.push( {  } );
       */
      _this.options = util.extend({}, GraphOptionsDefault, options);
      // Options declaration must be placed before the doDom operation

      // doDom is a private method. We bind it to this thanks to ES6 features
      doDom.bind(_this)();

      if (wrapper) {
        _this.setWrapper(wrapper);
      }

      _this.prevented = false;

      _this.axis = {
        left: [],
        top: [],
        bottom: [],
        right: []
      };

      _this.shapes = [];
      _this.shapesLocked = false;
      _this.plugins = {};

      for (var i in _this.options.pluginAction) {
        _this.options.pluginAction.plugin = i;
        _this.options.mouseActions.push(_this.options.pluginAction);
      }

      _this.selectedShapes = [];

      _this.series = [];
      //this._dom = wrapper;
      _this._axesHaveChanged = true;

      if (_this.options.hasOwnProperty('padding') && util.isNumeric(_this.options.padding)) {
        _this.options.paddingTop = _this.options.paddingBottom = _this.options.paddingLeft = _this.options.paddingRight = _this.options.padding;
      }

      _this.currentAction = false;

      _this.ns = Graph.ns;
      _this.nsxlink = Graph.nsxlink;

      // Load all axes
      if (axis) {
        for (var i in axis) {
          for (var j = 0, l = axis[i].length; j < l; j++) {

            switch (i) {

              case 'top':
                _this.getTopAxis(j, axis[i][j]);
                break;
              case 'left':
                _this.getLeftAxis(j, axis[i][j]);
                break;
              case 'right':
                _this.getRightAxis(j, axis[i][j]);
                break;
              case 'bottom':
                _this.getBottomAxis(j, axis[i][j]);
                break;

              default:
                // Do not do anything
                break;
            }
          }
        }
      }

      _this._pluginsInit();

      return _this;
    }

    _createClass(Graph, [{
      key: 'setWrapper',
      value: function setWrapper(wrapper) {

        if (!wrapper) {
          throw new Error('The wrapper DOM element was not found.');
        }

        if (!wrapper.appendChild) {
          throw new Error('The wrapper appears to be an invalid HTMLElement');
        }

        wrapper.style['-webkit-user-select'] = 'none';
        wrapper.style['-moz-user-select'] = 'none';
        wrapper.style['-o-user-select'] = 'none';
        wrapper.style['-ms-user-select'] = 'none';
        wrapper.style['user-select'] = 'none';

        wrapper.style.position = 'relative';
        wrapper.style.outline = 'none';

        // Why would that be necessary ?
        // wrapper.setAttribute( 'tabindex', 1 );

        this.wrapper = wrapper;

        // DOM

        if (!this.height || !this.width) {
          var wrapperStyle = getComputedStyle(wrapper);
          var w = parseInt(wrapperStyle.width, 10);
          var h = parseInt(wrapperStyle.height, 10);
          this.setSize(w, h);
          this._resize();
        }

        wrapper.appendChild(this.dom);

        _registerEvents(this);
      }
    }, {
      key: 'getDom',
      value: function getDom() {
        return this.dom;
      }
    }, {
      key: 'getId',
      value: function getId() {
        return this._creation;
      }
    }, {
      key: 'getWrapper',
      value: function getWrapper() {
        return this.wrapper;
      }
    }, {
      key: 'setOption',
      value: function setOption(name, val) {
        this.options[name] = val;
        return this;
      }
    }, {
      key: 'setTitle',
      value: function setTitle(title) {
        this.options.title = title;
        this.domTitle.textContent = title;
      }
    }, {
      key: 'displayTitle',
      value: function displayTitle() {
        this.domTitle.setAttribute('display', 'inline');
      }
    }, {
      key: 'hideTitle',
      value: function hideTitle() {
        this.domTitle.setAttribute('display', 'none');
      }
    }, {
      key: 'hide',
      value: function hide() {
        if (this.dom.style.display !== 'none') {
          this.dom.style.display = 'none';
        }
      }
    }, {
      key: 'show',
      value: function show() {
        if (this.dom.style.display == 'none') {
          this.dom.style.display = 'initial';
        }
      }
    }, {
      key: 'redraw',
      value: function redraw(onlyIfAxesHaveChanged, force) {

        if (!this.width || !this.height) {
          return;
        }

        if (!this.sizeSet) {
          this._resize();
          this.executeRedrawSlaves();
          return true;
        } else {

          if (!onlyIfAxesHaveChanged || force || haveAxesChanged(this) || hasSizeChanged(this)) {
            this.executeRedrawSlaves();
            refreshDrawingZone(this);
            return true;
          }
        }

        this.executeRedrawSlaves(true);
        return false;
      }
    }, {
      key: 'executeRedrawSlaves',
      value: function executeRedrawSlaves() {
        this._pluginsExecute('preDraw');
      }
    }, {
      key: 'draw',
      value: function draw(force) {

        this.drawn = true;
        this.updateLegend(true);
        this.drawSeries(this.redraw(true, force));

        this._pluginsExecute('postDraw');
      }
    }, {
      key: 'delayUpdate',
      value: function delayUpdate() {
        this._lockUpdate = true;
        return this;
      }
    }, {
      key: 'doUpdate',
      value: function doUpdate() {
        if (this.legend) {
          this.legend.update();
        }
        this.draw();
        if (this.legend) {
          this.legend.update();
        }
        return this;
      }
    }, {
      key: 'resumeUpdate',
      value: function resumeUpdate() {
        this._lockUpdate = false;
        return this;
      }
    }, {
      key: 'isDelayedUpdate',
      value: function isDelayedUpdate() {
        return this._lockUpdate;
      }
    }, {
      key: 'setWidth',
      value: function setWidth(width, skipResize) {
        this.width = width;
        if (!skipResize) {
          this._resize();
        }
      }
    }, {
      key: 'setHeight',
      value: function setHeight(height, skipResize) {
        this.height = height;
        if (!skipResize) {
          this._resize();
        }
      }
    }, {
      key: 'resize',
      value: function resize(w, h) {
        if (w && h) {
          this.setSize(w, h);
        }

        this._resize();
        return this;
      }
    }, {
      key: 'setSize',
      value: function setSize(w, h) {
        this.setWidth(w, true);
        this.setHeight(h, true);
        this.getDrawingHeight();
        this.getDrawingWidth();
      }
    }, {
      key: 'getWidth',
      value: function getWidth() {
        return this.width;
      }
    }, {
      key: 'getHeight',
      value: function getHeight() {
        return this.height;
      }
    }, {
      key: 'getPaddingTop',
      value: function getPaddingTop() {
        return this.options.paddingTop;
      }
    }, {
      key: 'getPaddingLeft',
      value: function getPaddingLeft() {
        return this.options.paddingLeft;
      }
    }, {
      key: 'getPaddingBottom',
      value: function getPaddingBottom() {
        return this.options.paddingBottom;
      }
    }, {
      key: 'getPaddingRight',
      value: function getPaddingRight() {
        return this.options.paddingRight;
      }
    }, {
      key: 'getDrawingHeight',
      value: function getDrawingHeight(useCache) {
        if (useCache && this.innerHeight) {
          return this.innerHeight;
        }
        return this.innerHeight = this.height - this.options.paddingTop - this.options.paddingBottom;
      }
    }, {
      key: 'getDrawingWidth',
      value: function getDrawingWidth(useCache) {
        if (useCache && this.innerWidth) {
          return this.innerWidth;
        }
        return this.innerWidth = this.width - this.options.paddingLeft - this.options.paddingRight;
      }
    }, {
      key: 'cacheOffset',
      value: function cacheOffset() {
        this.offsetCached = util.getOffset(this.wrapper);
      }
    }, {
      key: 'uncacheOffset',
      value: function uncacheOffset() {
        this.offsetCached = false;
      }
    }, {
      key: 'getXAxis',
      value: function getXAxis(index, options) {
        if (this.axis.top.length > 0 && this.axis.bottom.length == 0) {
          return this.getTopAxis(index, options);
        }

        return this.getBottomAxis(index, options);
      }
    }, {
      key: 'getYAxis',
      value: function getYAxis(index, options) {

        if (this.axis.right.length > 0 && this.axis.left.length == 0) {
          return this.getRightAxis(index, options);
        }

        return this.getLeftAxis(index, options);
      }
    }, {
      key: 'getTopAxis',
      value: function getTopAxis(index, options) {
        return _getAxis(this, index, options, 'top');
      }
    }, {
      key: 'getBottomAxis',
      value: function getBottomAxis(index, options) {
        return _getAxis(this, index, options, 'bottom');
      }
    }, {
      key: 'getLeftAxis',
      value: function getLeftAxis(index, options) {
        return _getAxis(this, index, options, 'left');
      }
    }, {
      key: 'getRightAxis',
      value: function getRightAxis(index, options) {
        return _getAxis(this, index, options, 'right');
      }
    }, {
      key: 'setXAxis',
      value: function setXAxis(axis, index) {
        this.setBottomAxis(axis, index);
      }
    }, {
      key: 'setYAxis',
      value: function setYAxis(axis, index) {
        this.setLeftAxis(axis, index);
      }
    }, {
      key: 'setLeftAxis',
      value: function setLeftAxis(axis, index) {
        index = index || 0;

        if (this.axis.left[index]) {
          this.axis.left[index].kill();
        }
        this.axis.left[index] = axis;
      }
    }, {
      key: 'setRightAxis',
      value: function setRightAxis(axis, index) {
        index = index || 0;

        if (this.axis.right[index]) {
          this.axis.right[index].kill();
        }
        this.axis.right[index] = axis;
      }
    }, {
      key: 'setTopAxis',
      value: function setTopAxis(axis, index) {
        index = index || 0;

        if (this.axis.top[index]) {
          this.axis.top[index].kill();
        }
        this.axis.top[index] = axis;
      }
    }, {
      key: 'setBottomAxis',
      value: function setBottomAxis(axis, index) {
        index = index || 0;

        if (this.axis.bottom[index]) {
          this.axis.bottom[index].kill();
        }
        this.axis.bottom[index] = axis;
      }
    }, {
      key: 'killAxis',
      value: function killAxis(axis) {
        var noRedraw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var noSerieKill = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;


        var index;

        if (axis.isX()) {

          if ((index = this.axis.bottom.indexOf(axis)) > -1) {
            this.axis.bottom.splice(index, 1);
          }

          if ((index = this.axis.top.indexOf(axis)) > -1) {
            this.axis.top.splice(index, 1);
          }

          if (!noSerieKill) {
            this.series.forEach(function (serie) {

              if (serie.getXAxis() == axis) {
                serie.kill();
              }
            });
          }
        }

        if (axis.isY()) {

          if ((index = this.axis.left.indexOf(axis)) > -1) {
            this.axis.left.splice(index, 1);
          }

          if ((index = this.axis.right.indexOf(axis)) > -1) {
            this.axis.right.splice(index, 1);
          }

          if (!noSerieKill) {
            this.series.forEach(function (serie) {

              if (serie.getYAxis() == axis) {
                serie.kill();
              }
            });
          }
        }

        this.axisGroup.removeChild(axis.group); // Removes all DOM
        this.groupPrimaryGrids.removeChild(axis.gridPrimary);
        this.groupSecondaryGrids.removeChild(axis.gridSecondary);

        if (!noRedraw) {
          this.draw(true);
        }
      }
    }, {
      key: 'hasXAxis',
      value: function hasXAxis(axis) {
        return this.hasTopAxis(axis) || this.hasBottomAxis(axis);
      }
    }, {
      key: 'hasYAxis',
      value: function hasYAxis(axis) {
        return this.hasLeftAxis(axis) || this.hasRightAxis(axis);
      }
    }, {
      key: 'hasTopAxis',
      value: function hasTopAxis(axis) {
        return this.hasAxis(axis, this.axis.top);
      }
    }, {
      key: 'hasBottomAxis',
      value: function hasBottomAxis(axis) {
        return this.hasAxis(axis, this.axis.bottom);
      }
    }, {
      key: 'hasLeftAxis',
      value: function hasLeftAxis(axis) {
        return this.hasAxis(axis, this.axis.left);
      }
    }, {
      key: 'hasRightAxis',
      value: function hasRightAxis(axis) {
        return this.hasAxis(axis, this.axis.right);
      }
    }, {
      key: 'hasAxis',
      value: function hasAxis(axis, axisList) {
        for (var i = 0, l = axisList.length; i < l; i++) {
          if (axisList[i] == axis) {
            return true;
          }

          if (axisList[i].hasAxis(axis)) {
            return true;
          }
        }

        return false;
      }
    }, {
      key: 'autoscaleAxes',
      value: function autoscaleAxes() {

        this._applyToAxes('setMinMaxToFitSeries', null, true, true);

        //this._applyToAxes( "scaleToFitAxis", [ this.getYAxis() ], false, true )
        // X is not always ascending...
        return this;
      }
    }, {
      key: 'autoscale',
      value: function autoscale() {
        return this.autoscaleAxes.apply(this, arguments);
      }
    }, {
      key: 'autoScale',
      value: function autoScale() {
        return this.autoscaleAxes.apply(this, arguments);
      }
    }, {
      key: 'autoScaleAxes',
      value: function autoScaleAxes() {
        return this.autoscaleAxes.apply(this, arguments);
      }
    }, {
      key: 'autoScaleAxis',
      value: function autoScaleAxis(axis) {
        if (!axis) {
          return this;
        }

        axis.setMinMaxToFitSeries();
        return this;
      }
    }, {
      key: 'setBackgroundColor',
      value: function setBackgroundColor(color) {

        this.rectEvent.setAttribute('fill', color);
        return this;
      }
    }, {
      key: 'getAxisState',
      value: function getAxisState() {

        var state = {};
        for (var i in this.axis) {
          state[i] = this.axis[i].map(function (axis) {
            return [axis.getCurrentMin(), axis.getCurrentMax()];
          });
        }
        return state;
      }
    }, {
      key: 'setAxisState',
      value: function setAxisState(state) {

        var j, l;
        for (var i in state) {

          if (!this.axis[i]) {
            continue;
          }

          for (j = 0, l = state[i].length; j < l; j++) {

            if (!this.axis[i][j]) {
              continue;
            }

            this.axis[i][j].setCurrentMin(state[i][j][0]);
            this.axis[i][j].setCurrentMax(state[i][j][1]);
          }
        }

        this.draw();
      }
    }, {
      key: 'saveAxisState',
      value: function saveAxisState(savedName) {
        this.savedAxisState = this.savedAxisState || {};
        this.savedAxisState[savedName] = this.getAxisState();
        return this;
      }
    }, {
      key: 'recallAxisState',
      value: function recallAxisState(savedName) {
        if (this.savedAxisState[savedName]) {
          this.recallAxisState(this.savedAxisState[savedName]);
        }
        return this;
      }
    }, {
      key: '_applyToAxis',
      value: function _applyToAxis(type) {

        switch (type) {

          case 'string':
            return function (type, func, params) {
              //    params.splice(1, 0, type);

              for (var i = 0; i < this.axis[type].length; i++) {
                this.axis[type][i][func].apply(this.axis[type][i], params);
              }
            };

          case 'function':
            return function (type, func, params) {
              for (var i = 0; i < this.axis[type].length; i++) {
                func.call(this, this.axis[type][i], type, params);
              }
            };

          default:
            throw new Error('You must either execute a function or provide a string that registers a function');
        }
      }
    }, {
      key: 'getBoundaryAxis',
      value: function getBoundaryAxis(axis, minmax, usingZValues) {

        var valSeries = this.getBoundaryAxisFromSeries(axis, minmax, usingZValues);
        //  var valShapes = this.getBoundaryAxisFromShapes( axis, xy, minmax );
        return valSeries;
        //return Math[ minmax ]( valSeries, valShapes );
      }
    }, {
      key: 'getBoundaryAxisFromSeries',
      value: function getBoundaryAxisFromSeries(axis, minmax, usingZValues) {

        var min = minmax == 'min',
            val,
            func = axis.isX() ? ['getMinX', 'getMaxX'] : ['getMinY', 'getMaxY'],
            func2use = func[min ? 0 : 1],
            infinity2use = min ? +Infinity : -Infinity,
            serie,
            series,
            serieValue,
            i,
            l;

        val = infinity2use;
        series = this.getSeriesFromAxis(axis);

        for (i = 0, l = series.length; i < l; i++) {

          serie = series[i];

          if (!serie.isShown()) {
            continue;
          }

          serieValue = serie[func2use](usingZValues);
          val = Math[minmax](isNaN(val) ? infinity2use : val, isNaN(serieValue) ? infinity2use : serieValue);
        }

        return val;
      }
    }, {
      key: 'getSeriesFromAxis',
      value: function getSeriesFromAxis(axis) {
        var series = [],
            i = this.series.length - 1;

        for (; i >= 0; i--) {
          if (this.series[i].getXAxis() == axis || this.series[i].getYAxis() == axis) {
            series.push(this.series[i]);
          }
        }

        return series;
      }
    }, {
      key: 'updateDataMinMaxAxes',
      value: function updateDataMinMaxAxes(usingZValues) {

        var axisvars = ['bottom', 'top', 'left', 'right'],
            axis,
            j,
            l,
            i;

        for (j = 0, l = axisvars.length; j < l; j++) {

          for (i = this.axis[axisvars[j]].length - 1; i >= 0; i--) {

            axis = this.axis[axisvars[j]][i];

            // 25.10.2017. Wait a second, this cannot be real. Even hidden axes must have min max values.
            // The data can be displayed while the axis is hidden
            // I assume this was added to cover another bug, but another approach must be chosen
            if (!axis.isShown()) {}
            //          continue;


            //console.log( axisvars[ j ], this.getBoundaryAxisFromSeries( this.axis[ axisvars[ j ] ][ i ], xy, 'min'), this.getBoundaryAxisFromSeries( this.axis[ axisvars[ j ] ][ i ], xy, 'max') );

            var min = this.getBoundaryAxis(this.axis[axisvars[j]][i], 'min', usingZValues);
            var max = this.getBoundaryAxis(this.axis[axisvars[j]][i], 'max', usingZValues);

            if (isFinite(max)) {
              axis.setMaxValueData(max);
            }
            if (isFinite(min)) {
              axis.setMinValueData(min);
            }
          }
        }
      }
    }, {
      key: '_applyToAxes',
      value: function _applyToAxes(func, params, tb, lr) {

        var ax = [],
            i = 0,
            l;

        if (tb || tb == undefined) {
          ax.push('top');
          ax.push('bottom');
        }
        if (lr || lr == undefined) {
          ax.push('left');
          ax.push('right');
        }

        for (l = ax.length; i < l; i++) {
          this._applyToAxis(typeof func === 'undefined' ? 'undefined' : _typeof(func)).call(this, ax[i], func, params);
        }
      }
    }, {
      key: 'findAxesLinkedTo',
      value: function findAxesLinkedTo(axis) {

        var axes = [];
        this._applyToAxes(function (a) {

          if (a.linkedToAxis && a.linkedToAxis.axis == axis) {
            axes.push(a);
          }
        }, {}, axis instanceof this.getConstructor('graph.axis.x'), axis instanceof this.getConstructor('graph.axis.y'));

        return axes;
      }
    }, {
      key: '_axisHasChanged',
      value: function _axisHasChanged() {
        this._axesHaveChanged = true;
      }
    }, {
      key: 'newSerie',
      value: function newSerie(name, options, type) {

        var serie = void 0;

        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object' && !type) {
          type = options;
          options = {};
        }

        if (!type) {
          type = Graph.SERIE_LINE;
        }

        if (serie = this.getSerie(name)) {
          return serie;
        }

        if (!(serie = makeSerie(this, name, options, type))) {
          return;
        }

        this.series.push(serie);

        serie.postInit();
        this.emit('newSerie', serie);
        return serie;
      }
    }, {
      key: 'getSerie',
      value: function getSerie(name) {

        if (typeof name == 'number') {
          return this.series[name] || false;
        }

        if (typeof name == 'function') {
          name = name();
        }

        var i = 0,
            l = this.series.length;

        for (; i < l; i++) {

          if (this.series[i].getName() == name || this.series[i] == name) {

            return this.series[i];
          }
        }

        return false;
      }
    }, {
      key: 'getSeries',
      value: function getSeries() {
        return this.series;
      }
    }, {
      key: 'allSeries',
      value: function allSeries() {
        for (var _len = arguments.length, types = Array(_len), _key = 0; _key < _len; _key++) {
          types[_key] = arguments[_key];
        }

        return this.series.filter(function (serie) {
          return types.include(serie.getType());
        });
      }
    }, {
      key: 'drawSerie',
      value: function drawSerie(serie, force) {

        if (!serie.draw) {
          throw new Error('Serie has no method draw');
        }

        serie.draw(force);
      }
    }, {
      key: 'drawSeries',
      value: function drawSeries(force) {

        if (!this.width || !this.height) {
          return;
        }

        var i = this.series.length - 1;
        for (; i >= 0; i--) {
          if (this.series[i].isShown()) {
            this.drawSerie(this.series[i], force);
          }
        }
      }
    }, {
      key: 'resetSeries',
      value: function resetSeries() {
        this.removeSeries();
      }
    }, {
      key: 'killSeries',
      value: function killSeries() {
        this.resetSeries();
      }
    }, {
      key: 'removeSeries',
      value: function removeSeries() {
        while (this.series[0]) {
          this.series[0].kill(true);
        }
        this.series = [];

        if (this.legend) {
          this.legend.update();
        }
      }
    }, {
      key: 'selectSerie',
      value: function selectSerie(serie, selectName) {

        if (!((typeof serie === 'undefined' ? 'undefined' : _typeof(serie)) == 'object')) {
          serie = this.getSerie(serie);
        }

        if (this.selectedSerie == serie && this.selectedSerie.selectionType == selectName) {
          return;
        }

        if (this.selectedSerie !== serie && this.selectedSerie) {
          this.unselectSerie(this.selectedSerie);
        }

        this.selectedSerie = serie;
        this.triggerEvent('onSelectSerie', serie);

        serie.select(selectName || 'selected');
      }
    }, {
      key: 'getSelectedSerie',
      value: function getSelectedSerie() {
        return this.selectedSerie;
      }
    }, {
      key: 'unselectSerie',
      value: function unselectSerie(serie) {

        if (!serie.unselect) {
          return;
        }

        serie.unselect();
        this.selectedSerie = false;
        this.triggerEvent('onUnselectSerie', serie);
      }
    }, {
      key: 'getShapesOfSerie',
      value: function getShapesOfSerie(serie) {

        var shapes = [];
        var i = this.shapes.length - 1;

        for (; i >= 0; i--) {

          if (this.shapes[i].getSerie() == serie) {
            shapes.push(this.shapes[i]);
          }
        }

        return shapes;
      }
    }, {
      key: 'makeToolbar',
      value: function makeToolbar(toolbarData) {

        var constructor = this.getConstructor('graph.toolbar');
        if (constructor) {
          return this.toolbar = new constructor(this, toolbarData);
        } else {
          return util.throwError('No constructor exists for toolbar');
        }
      }
    }, {
      key: 'getShapes',
      value: function getShapes() {
        return this.shapes || [];
      }
    }, {
      key: 'newShape',
      value: function newShape(shapeType, shapeData) {
        var mute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var shapeProperties = arguments[3];


        this.prevent(false);

        if (!mute) {

          this.emit('beforeNewShape', shapeData);

          if (this.prevent(false)) {
            return false;
          }
        }

        // Backward compatibility
        if ((typeof shapeType === 'undefined' ? 'undefined' : _typeof(shapeType)) == 'object') {
          mute = shapeData;
          shapeData = shapeType;
          shapeType = shapeData.type;
        }

        shapeData = shapeData || {};
        shapeData._id = util.guid();

        var constructor;
        if (typeof shapeType == 'function') {
          constructor = shapeType;
        } else {
          constructor = this.getConstructor('graph.shape.' + shapeType);
        }

        if (!constructor) {
          return util.throwError('No constructor for this shape');
        }

        var shape = new constructor(this, shapeData);

        if (!shape) {
          return util.throwError('Failed to construct shape.');
        }

        shape.type = shapeType;
        shape.graph = this;
        shape._data = shapeData;

        if (shapeData.properties !== undefined) {
          shape.setProperties(shapeData.properties);
        }

        shape.init(this, shapeProperties);

        if (shapeData.props !== undefined) {
          for (var i in shapeData.props) {
            shape.setProp(i, shapeData.props[i]);
          }
        }

        if (shapeData.position) {

          for (var i = 0, l = shapeData.position.length; i < l; i++) {
            shape.setPosition(new _graphPosition2.default(shapeData.position[i]), i);
          }
        }

        /* Setting shape properties */
        if (shapeData.fillColor !== undefined) {
          shape.setFillColor(shapeData.fillColor);
        }

        if (shapeData.fillOpacity !== undefined) {
          shape.setFillOpacity(shapeData.fillOpacity);
        }

        if (shapeData.strokeColor !== undefined) {
          shape.setStrokeColor(shapeData.strokeColor);
        }

        if (shapeData.strokeWidth !== undefined) {
          shape.setStrokeWidth(shapeData.strokeWidth);
        }

        if (shapeData.layer !== undefined) {
          shape.setLayer(shapeData.layer);
        }

        if (shapeData.locked == true) {
          shape.lock();
        }

        if (shapeData.movable == true) {
          shape.movable();
        }

        if (shapeData.selectable == true) {
          shape.selectable();
        }

        if (shapeData.resizable == true) {
          shape.resizable();
        }

        if (shapeData.attributes !== undefined) {
          shape.setProp('attributes', shapeData.attributes);
        }

        if (shapeData.handles !== undefined) {
          shape.setProp('handles', shapeData.handles);
        }

        if (shapeData.selectOnMouseDown !== undefined) {
          shape.setProp('selectOnMouseDown', true);
        }

        if (shapeData.selectOnClick !== undefined) {
          shape.setProp('selectOnClick', true);
        }

        if (shapeData.transforms !== undefined && Array.isArray(shapeData.transforms)) {

          shapeData.transforms.forEach(function (_ref) {
            var type = _ref.type,
                value = _ref.value;


            shape.addTransform(type, value);
          });
        }

        if (shapeData.highlightOnMouseOver !== undefined) {
          shape.setProp('highlightOnMouseOver', true);
        }

        if (shapeData.labelEditable) {
          shape.setProp('labelEditable', shapeData.labelEditable);
        }

        if (shapeData.labels && !shapeData.label) {
          shapeData.label = shapeData.labels;
        }

        if (shapeData.label !== undefined) {

          if (!Array.isArray(shapeData.label)) {
            shapeData.label = [shapeData.label];
          }

          for (var i = 0, l = shapeData.label.length; i < l; i++) {

            shape.showLabel(i);
            shape.setLabelText(shapeData.label[i].text, i);
            shape.setLabelPosition(shapeData.label[i].position, i);
            shape.setLabelColor(shapeData.label[i].color || 'black', i);
            shape.setLabelSize(shapeData.label[i].size, i);
            shape.setLabelAngle(shapeData.label[i].angle || 0, i);
            shape.setLabelBaseline(shapeData.label[i].baseline || 'no-change', i);
            shape.setLabelAnchor(shapeData.label[i].anchor || 'start', i);
            shape.setLabelBackgroundColor(shapeData.label[i].backgroundColor || 'transparent', i);
            shape.setLabelBackgroundOpacity(shapeData.label[i].backgroundOpacity || 1, i);
          }
        }

        if (shapeData.serie) {
          shape.setSerie(this.getSerie(shapeData.serie));
        }
        shape.createHandles();
        shape.applyStyle();

        this.shapes.push(shape);

        if (!mute) {
          this.emit('newShape', shape, shapeData);
        }

        return shape;
      }
    }, {
      key: 'newPosition',
      value: function newPosition(varArgs) {

        return new (Function.prototype.bind.apply(_graphPosition2.default, [null].concat(Array.prototype.slice.call(arguments))))();

        // 18 September 2016 Norman: What is that ?
        //Array.prototype.unshift.call( arguments, null );
        //return new( Function.prototype.bind.apply( GraphPosition, arguments ) )();
      }
    }, {
      key: 'redrawShapes',
      value: function redrawShapes() {

        //this.graphingZone.removeChild(this.shapeZone);
        for (var i = 0, l = this.shapes.length; i < l; i++) {
          this.shapes[i].redraw();
        }
        //this.graphingZone.insertBefore(this.shapeZone, this.axisGroup);
      }
    }, {
      key: 'removeShapes',
      value: function removeShapes() {
        for (var i = 0, l = this.shapes.length; i < l; i++) {
          if (this.shapes[i] && this.shapes[i].kill) {
            this.shapes[i].kill(true);
          }
        }
        this.shapes = [];
      }
    }, {
      key: 'selectShape',
      value: function selectShape(shape, mute) {

        // Already selected. Returns false

        if (!shape) {
          return;
        }

        if (this.selectedShapes.indexOf(shape) > -1) {
          return false;
        }

        if (!shape.isSelectable()) {
          return false;
        }

        if (!mute) {
          this.emit('beforeShapeSelect', shape);
        }

        if (this.prevent(false)) {
          return;
        }

        if (this.selectedShapes.length > 0 && this.options.shapesUniqueSelection) {
          // Only one selected shape at the time

          this.unselectShapes(mute);
        }

        shape._select(mute);
        this.selectedShapes.push(shape);

        if (!mute) {
          this.emit('shapeSelect', shape);
        }
      }
    }, {
      key: 'getSelectedShapes',
      value: function getSelectedShapes() {
        return this.selectedShapes;
      }
    }, {
      key: 'unselectShape',
      value: function unselectShape(shape, mute) {

        if (this.selectedShapes.indexOf(shape) == -1) {
          return;
        }

        if (!mute) {
          this.emit('beforeShapeUnselect', shape);
        }

        if (this.cancelUnselectShape) {
          this.cancelUnselectShape = false;
          return;
        }

        shape._unselect();

        this.selectedShapes.splice(this.selectedShapes.indexOf(shape), 1);

        if (!mute) {
          this.emit('shapeUnselect', shape);
        }
      }
    }, {
      key: 'unselectShapes',
      value: function unselectShapes(mute) {

        while (this.selectedShapes[0]) {
          this.unselectShape(this.selectedShapes[0], mute);
        }

        return this;
      }
    }, {
      key: '_removeShape',
      value: function _removeShape(shape) {
        this.shapes.splice(this.shapes.indexOf(shape), 1);
      }
    }, {
      key: 'appendShapeToDom',
      value: function appendShapeToDom(shape) {

        if (shape.isHTML()) {
          this.wrapper.insertBefore(shape._dom, this.dom);
        }

        this.getLayer(shape.getLayer(), 'shape').appendChild(shape.group);
      }
    }, {
      key: 'removeShapeFromDom',
      value: function removeShapeFromDom(shape) {

        if (shape.isHTML()) {
          this.wrapper.removeChild(shape._dom);
        }

        this.getLayer(shape.getLayer(), 'shape').removeChild(shape.group);
      }
    }, {
      key: 'appendSerieToDom',
      value: function appendSerieToDom(serie) {
        this.getLayer(serie.getLayer(), 'serie').appendChild(serie.groupMain);
      }
    }, {
      key: 'removeSerieFromDom',
      value: function removeSerieFromDom(serie) {
        this.getLayer(serie.getLayer(), 'serie').removeChild(serie.groupMain);
      }
    }, {
      key: 'getLayer',
      value: function getLayer(layer, mode) {

        if (!this.layers[layer]) {

          this.layers[layer] = [];

          this.layers[layer][0] = document.createElementNS(Graph.ns, 'g');
          this.layers[layer][0].setAttribute('data-layer', layer);
          this.layers[layer][1] = document.createElementNS(Graph.ns, 'g');
          this.layers[layer][2] = document.createElementNS(Graph.ns, 'g');

          this.layers[layer][0].appendChild(this.layers[layer][1]);
          this.layers[layer][0].appendChild(this.layers[layer][2]);

          var i = 1,
              prevLayer;

          while (!(prevLayer = this.layers[layer - i]) && layer - i >= 0) {
            i++;
          }

          if (!prevLayer) {

            this.plotGroup.insertBefore(this.layers[layer][0], this.plotGroup.firstChild);
          } else if (prevLayer.nextSibling) {

            this.plotGroup.insertBefore(this.layers[layer][0], prevLayer.nextSibling);
          } else {

            this.plotGroup.appendChild(this.layers[layer][0]);
          }
        }

        return this.layers[layer][mode == 'shape' ? 2 : 1];
      }
    }, {
      key: 'focus',
      value: function focus() {
        this.wrapper.focus();
      }
    }, {
      key: 'elementMoving',
      value: function elementMoving(movingElement) {
        this.bypassHandleMouse = movingElement;
      }
    }, {
      key: 'stopElementMoving',
      value: function stopElementMoving(element) {

        if (element && element == this.bypassHandleMouse) {
          this.bypassHandleMouse = false;
        } else if (!element) {
          this.bypassHandleMouse = false;
        }
      }
    }, {
      key: '_makeClosingLines',
      value: function _makeClosingLines() {

        this.closingLines = {};
        var els = ['top', 'bottom', 'left', 'right'],
            i = 0,
            l = 4;
        for (; i < l; i++) {
          var line = document.createElementNS(Graph.ns, 'line');
          line.setAttribute('stroke', this.options.closeColor);
          line.setAttribute('shape-rendering', 'crispEdges');
          line.setAttribute('stroke-linecap', 'square');
          line.setAttribute('display', 'none');
          this.closingLines[els[i]] = line;
          this.graphingZone.appendChild(line);
        }
      }
    }, {
      key: 'isActionAllowed',
      value: function isActionAllowed(e, action) {

        if (action.type !== e.type && (action.type !== undefined || e.type !== 'mousedown') && !((e.type === 'wheel' || e.type === 'mousewheel') && action.type == 'mousewheel')) {
          return;
        }

        if (action.enabled && (typeof action.enabled == 'function' ? !action.enabled(this) : !action.enabled)) {
          return;
        }

        if (action.key) {

          if (action.key !== e.keyCode) {

            var keyCheck = {
              'backspace': 8,
              'enter': 13,
              'tab': 9,
              'shift': 16,
              'ctrl': 17,
              'alt': 18,
              'pause': 19,
              'escape': 27,
              'up': 33,
              'down': 34,
              'left': 37,
              'right': 39
            };

            if (keyCheck[action.key] !== e.keyCode) {
              return;
            }
          }
        }

        if (action.shift === undefined) {
          action.shift = false;
        }

        if (action.ctrl === undefined) {
          action.ctrl = false;
        }

        if (action.meta === undefined) {
          action.meta = false;
        }

        if (action.alt === undefined) {
          action.alt = false;
        }

        return e.shiftKey == action.shift && e.ctrlKey == action.ctrl && e.metaKey == action.meta && e.altKey == action.alt;
      }
    }, {
      key: 'forcePlugin',
      value: function forcePlugin(plugin) {
        this.forcedPlugin = plugin;
      }
    }, {
      key: 'unforcePlugin',
      value: function unforcePlugin() {
        this.forcedPlugin = false;
      }
    }, {
      key: '_pluginsExecute',
      value: function _pluginsExecute(funcName) {
        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        //			Array.prototype.splice.apply(args, [0, 0, this]);

        for (var i in this.plugins) {

          if (this.plugins[i] && this.plugins[i][funcName]) {

            this.plugins[i][funcName].apply(this.plugins[i], args);
          }
        }
      }
    }, {
      key: '_pluginExecute',
      value: function _pluginExecute(which, func, args) {

        //Array.prototype.splice.apply( args, [ 0, 0, this ] );
        if (!which) {
          return;
        }

        if (this.plugins[which] && this.plugins[which][func]) {

          this.plugins[which][func].apply(this.plugins[which], args);
          return true;
        }
      }
    }, {
      key: 'pluginYieldActiveState',
      value: function pluginYieldActiveState() {
        this.activePlugin = false;
      }
    }, {
      key: '_serieExecute',
      value: function _serieExecute(serie, func, args) {

        if ((typeof serie === 'undefined' ? 'undefined' : _typeof(serie)) !== 'object') {
          serie = this.getSerie(serie);
        }

        if (typeof serie[func] == 'function') {
          serie.apply(serie, args);
        }
      }
    }, {
      key: '_pluginsInit',
      value: function _pluginsInit() {

        var constructor, pluginName, pluginOptions;

        for (var i in this.options.plugins) {

          pluginName = i;
          console.log(pluginName);
          pluginOptions = this.options.plugins[i];

          constructor = this.getConstructor('graph.plugin.' + pluginName);

          if (constructor) {

            //var options = util.extend( true, {}, constructor.defaults(), pluginOptions );
            this.plugins[pluginName] = new constructor(pluginOptions);

            util.mapEventEmission(this.plugins[pluginName].options, this.plugins[pluginName]);
            this.plugins[pluginName].init(this, pluginOptions);
          } else {
            util.throwError('Plugin "' + pluginName + '" has not been registered');
          }
        }
      }
    }, {
      key: 'getPlugin',
      value: function getPlugin(pluginName) {
        var plugin = this.plugins[pluginName];

        if (!plugin) {
          return util.throwError('Plugin "' + pluginName + '" has not been loaded or properly registered');
        }

        return plugin;
      }
    }, {
      key: 'hasPlugin',
      value: function hasPlugin(pluginName) {
        return !!this.plugins[pluginName];
      }
    }, {
      key: 'triggerEvent',
      value: function triggerEvent() {
        var func = arguments[0];
        /*,
              args = Array.prototype.splice.apply( arguments, [ 0, 1 ] );
        */
        if (typeof this.options[func] == 'function') {
          return this.options[func].apply(this, arguments);
        }
      }
    }, {
      key: 'makeLegend',
      value: function makeLegend(options) {

        if (this.legend) {
          return this.legend;
        }

        var constructor = this.getConstructor('graph.legend');
        if (constructor) {
          this.legend = new constructor(this, options);
        } else {
          return util.throwError('Graph legend is not available as it has not been registered');
        }

        return this.legend;
      }
    }, {
      key: 'updateLegend',
      value: function updateLegend() {
        var onlyIfRequired = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;


        if (!this.legend) {
          return;
        }

        this.legend.update(onlyIfRequired);
        return this;
      }
    }, {
      key: 'getLegend',
      value: function getLegend() {
        if (!this.legend) {
          return;
        }

        return this.legend;
      }
    }, {
      key: 'requireLegendUpdate',
      value: function requireLegendUpdate() {

        if (!this.legend) {
          return;
        }

        this.legend.requireDelayedUpdate();
      }
    }, {
      key: 'orthogonalProjectionSetup',
      value: function orthogonalProjectionSetup() {

        this.options.zAxis = util.extend(true, {
          maxZ: 10,
          minZ: 0,
          shiftX: -25,
          shiftY: -15,
          xAxis: this.getXAxis(),
          yAxis: this.getYAxis()
        });
      }
    }, {
      key: 'orthogonalProjectionUpdate',
      value: function orthogonalProjectionUpdate() {
        var _this2 = this;

        if (!this.zAxis) {
          this.zAxis = {
            g: document.createElementNS(Graph.ns, 'g'),
            l: document.createElementNS(Graph.ns, 'line')
          };

          this.zAxis.g.appendChild(this.zAxis.l);
          this.groupGrids.appendChild(this.zAxis.g);
        }

        var refAxisX = this.options.zAxis.xAxis;
        var refAxisY = this.options.zAxis.yAxis;

        var x0 = refAxisX.getMinPx();
        var y0 = refAxisY.getMinPx();

        var dx = refAxisX.getZProj(this.options.zAxis.maxZ);
        var dy = refAxisY.getZProj(this.options.zAxis.maxZ);

        this.zAxis.l.setAttribute('stroke', 'black');
        this.zAxis.l.setAttribute('x1', x0);
        this.zAxis.l.setAttribute('x2', x0 + dx);
        this.zAxis.l.setAttribute('y1', y0);
        this.zAxis.l.setAttribute('y2', y0 + dy);

        this.updateDataMinMaxAxes(true);

        var sort = this.series.map(function (serie) {
          return [serie.getZPos(), serie];
        });

        sort.sort(function (sa, sb) {
          return sb[0] - sa[0];
        });

        var i = 0;
        sort.forEach(function (s) {
          s[1].setLayer(i);
          _this2.appendSerieToDom(s[1]);
          i++;
        });

        this.drawSeries(true);
      }
    }, {
      key: 'kill',
      value: function kill() {
        this.wrapper.removeChild(this.dom);
      }
    }, {
      key: '_removeSerie',
      value: function _removeSerie(serie) {
        this.series.splice(this.series.indexOf(serie), 1);
        this._pluginsExecute('serieRemoved', serie);
      }
    }, {
      key: 'contextListen',
      value: function contextListen(target, menuElements, callback) {

        if (this.options.onContextMenuListen) {
          return this.options.onContextMenuListen(target, menuElements, callback);
        }
      }
    }, {
      key: 'lockShapes',
      value: function lockShapes() {
        this.shapesLocked = true;

        // Removes the current actions of the shapes
        for (var i = 0, l = this.shapes.length; i < l; i++) {
          this.shapes[i].moving = false;
          this.shapes[i].resizing = false;
        }
      }
    }, {
      key: 'unlockShapes',
      value: function unlockShapes() {
        //		console.log('unlock');
        this.shapesLocked = false;
      }
    }, {
      key: 'prevent',
      value: function prevent(arg) {
        var curr = this.prevented;
        if (arg != -1) {
          this.prevented = arg == undefined || arg;
        }
        return curr;
      }
    }, {
      key: '_getXY',
      value: function _getXY(e) {

        var x = e.clientX,
            y = e.clientY;

        var pos = this.offsetCached || util.getOffset(this.wrapper);

        x -= pos.left;
        y -= pos.top;

        return {
          x: x,
          y: y
        };
      }
    }, {
      key: '_resize',
      value: function _resize() {

        if (!this.width || !this.height) {
          return;
        }

        this.getDrawingWidth();
        this.getDrawingHeight();

        this.sizeSet = true;
        this.dom.setAttribute('width', this.width);
        this.dom.setAttribute('height', this.height);
        this.domTitle.setAttribute('x', this.width / 2);

        this._sizeChanged = true;

        if (this.drawn) {
          this.requireLegendUpdate();
          this.draw(true);
        }
      }
    }, {
      key: 'updateGraphingZone',
      value: function updateGraphingZone() {
        util.setAttributeTo(this.graphingZone, {
          'transform': 'translate(' + this.options.paddingLeft + ', ' + this.options.paddingTop + ')'
        });

        this._sizeChanged = true;
      }
    }, {
      key: 'getDrawingSpaceWidth',
      value: function getDrawingSpaceWidth() {
        var _this3 = this;

        return function () {
          return _this3.drawingSpaceWidth;
        };
      }
    }, {
      key: 'getDrawingSpaceHeight',
      value: function getDrawingSpaceHeight() {
        var _this4 = this;

        return function () {
          return _this4.drawingSpaceHeight;
        };
      }
    }, {
      key: 'getDrawingSpaceMinX',
      value: function getDrawingSpaceMinX() {
        var _this5 = this;

        return function () {
          return _this5.drawingSpaceMinX;
        };
      }
    }, {
      key: 'getDrawingSpaceMinY',
      value: function getDrawingSpaceMinY() {
        var _this6 = this;

        return function () {
          return _this6.drawingSpaceMinY;
        };
      }
    }, {
      key: 'getDrawingSpaceMaxX',
      value: function getDrawingSpaceMaxX() {
        var _this7 = this;

        return function () {
          return _this7.drawingSpaceMaxX;
        };
      }
    }, {
      key: 'getDrawingSpaceMaxY',
      value: function getDrawingSpaceMaxY() {
        var _this8 = this;

        return function () {
          return _this8.drawingSpaceMaxY;
        };
      }
    }, {
      key: 'trackingLine',
      value: function trackingLine(options) {
        var _this9 = this;

        var self = this;

        if (typeof options === 'boolean') {

          if (this.options.trackingLine) {
            this.options.trackingLine.enable = options;
          }
          return;
        }

        if (options) {
          this.options.trackingLine = options;
        }

        options.series = options.series || [];
        options.enable = options.enable === undefined ? true : !!options.enable;

        // Individual tracking
        if (options.mode == 'individual') {

          if (options.series) {

            if (!Array.isArray(options.series)) {

              if (options.series == 'all') {

                options.series = this.series.map(function (serie) {
                  return {
                    serie: serie
                  };
                });
              } else {

                options.series = [options.series];
              }
            }

            options.series.forEach(function (sOptions) {

              if (_typeof(sOptions.serie) !== 'object') {

                if ((typeof sOptions === 'undefined' ? 'undefined' : _typeof(sOptions)) !== 'object') {
                  throw new Error('Misuse of the trackingLine() method. Each serie must be an object with the serie property: { series: [ { serie: jsGraphSerie, options: { ... someOptions } } ] }');
                }

                sOptions.serie = _this9.getSerie(sOptions.serie);
              }

              if (!sOptions.serie) {
                return;
              }

              self.addSerieToTrackingLine(sOptions.serie, sOptions);
            });
          }
        } else {

          options.series.forEach(function (serie) {
            serie.serie.disableTracking();
          });
        }

        if (options.noLine) {
          return;
        }

        if (!this.trackingObject) {
          // Avoid multiple creation of tracking lines

          // Creates a new shape called trackingLine, in the first layer (below everything)
          this.trackingObject = this.newShape('line', util.extend(true, {
            position: [{
              y: 'min'
            }, {
              y: 'max'
            }],
            stroke: 'black',
            layer: -1
          }, options.trackingLineShapeOptions));
        }

        this.trackingObject.draw();

        return this.trackingObject;
      }
    }, {
      key: 'addSerieToTrackingLine',
      value: function addSerieToTrackingLine(serie, options) {
        var _this10 = this;

        if (!this.options.trackingLine) {

          this.trackingLine({
            mode: 'individual'
          });
        }

        this.options.trackingLine.series.forEach(function (serieO, index) {
          if (serieO.serie == serie) {
            _this10.options.trackingLine.series.splice(index, 1);
          }
        });

        this.options.trackingLine.series.push(Object.assign({
          serie: serie
        }, options));

        serie.enableTracking(function (serie, index, x, y) {

          if (_this10.options.trackingLine.enable) {

            if (index) {

              if (_this10.trackingObject) {

                _this10.trackingObject.show();
                _this10.trackingObject.getPosition(0).x = index.trueX; //serie.getData()[ 0 ][ index.closestIndex * 2 ];
                _this10.trackingObject.getPosition(1).x = index.trueX; //serie.getData()[ 0 ][ index.closestIndex * 2 ];
                _this10.trackingObject.redraw();
              }

              serie._trackingLegend = _trackingLegendSerie(_this10, {
                serie: serie
              }, x, y, serie._trackingLegend, options.textMethod ? options.textMethod : function (output) {

                for (var i in output) {
                  return output[i].serie.serie.getName() + ': ' + output[i].serie.serie.getYAxis().valueToHtml(output[i].yValue);
                }
              }, index.trueX);

              if (serie._trackingLegend) {
                serie._trackingLegend.style.display = 'block';
              }
            }
          }
        }, function (serie) {

          if (_this10.trackingObject) {
            _this10.trackingObject.hide();
          }

          if (serie.trackingShape) {
            serie.trackingShape.hide();
          }

          if (serie._trackingLegend) {
            serie._trackingLegend.style.display = 'none';
          }

          serie._trackingLegend = _trackingLegendSerie(_this10, {

            serie: serie

          }, false, false, serie._trackingLegend, false, false);
        });
      }
    }, {
      key: 'setKatexRenderer',
      value: function setKatexRenderer(renderer) {
        this._katexRenderer = renderer;
      }
    }, {
      key: 'hasKatexRenderer',
      value: function hasKatexRenderer() {
        return !!this._katexRenderer;
      }
    }, {
      key: 'renderWithKatex',
      value: function renderWithKatex(katexValue, katexElement) {

        if (this._katexRenderer) {

          if (katexElement) {
            katexElement.removeChild(katexElement.firstChild);
          } else {
            katexElement = document.createElementNS(Graph.ns, 'foreignObject');
          }

          var div = document.createElement('div');

          katexElement.appendChild(div);
          this._katexRenderer(katexValue, div);

          return katexElement;
        }

        return false;
      }
    }, {
      key: 'exportToSchema',
      value: function exportToSchema() {
        var _this11 = this;

        var schema = {};

        schema.title = this.options.title;

        schema.width = this.getWidth();
        schema.height = this.getHeight();

        var axesPositions = ['top', 'bottom', 'left', 'right'];
        var axesExport = [];
        var allaxes = {
          x: [],
          y: []
        };

        axesPositions.map(function (axisPosition) {

          if (!_this11.axis[axisPosition]) {
            return;
          }

          axesExport = axesExport.concat(_this11.axis[axisPosition].map(function (axis) {
            return {

              type: axisPosition,
              label: axis.options.label,
              unit: axis.options.unit,
              min: axis.options.forcedMin,
              max: axis.options.forcedMax,
              flip: axis.options.flipped

            };
          }));

          if (axisPosition == 'top' || axisPosition == 'bottom') {
            allaxes.x = allaxes.x.concat(_this11.axis[axisPosition]);
          } else {
            allaxes.y = allaxes.y.concat(_this11.axis[axisPosition]);
          }
        });

        schema.axis = axesExport;

        var seriesExport = [];

        var toType = function toType(type) {
          switch (type) {

            case Graph.SERIE_LINE:
              return 'line';
              break;

            case Graph.SERIE_BAR:
              return 'bar';
              break;

            case Graph.SERIE_LINE_COLORED:
              return 'color';
              break;

            case Graph.SERIE_SCATTER:
              return 'scatter';
              break;
          }
        };

        var exportData = function exportData(serie, x) {

          var data = [];

          switch (serie.getType()) {

            case Graph.SERIE_LINE:

              for (var i = 0; i < serie.data.length; i++) {

                for (var j = 0; j < serie.data[i].length - 1; j += 2) {

                  data.push(serie.data[i][j + (x && serie.isFlipped() || !x && !serie.isFlipped() ? 1 : 0)]);
                }
              }
              break;

            case Graph.SERIE_SCATTER:

              for (var j = 0; j < serie.data.length - 1; j += 2) {

                data.push(serie.data[i + (x && serie.isFlipped() || !x && !serie.isFlipped() ? 1 : 0)]);
              }

              break;
          }

          return data;
        };

        schema.data = seriesExport.concat(this.series.map(function (serie) {

          var style = [];
          var linestyle = [];

          if (serie.getType() == Graph.SERIE_LINE) {

            for (var stylename in serie.styles) {
              linestyle.push({
                styleName: stylename,
                color: serie.styles[stylename].lineColor,
                lineWidth: serie.styles[stylename].lineWidth,
                lineStyle: serie.styles[stylename].lineStyle
              });

              var styleObj = {
                styleName: stylename,
                styles: []
              };
              style.push(styleObj);

              styleObj.styles = styleObj.styles.concat((serie.styles[stylename].markers || []).map(function (markers) {
                return {
                  shape: markers.type,
                  zoom: markers.zoom,
                  lineWidth: markers.strokeWidth,
                  lineColor: markers.strokeColor,
                  color: markers.fillColor,
                  points: markers.points
                };
              }));
            }
          }

          return {
            label: serie.getLabel(),
            id: serie.getName(),
            type: toType(serie.getType()),
            x: exportData(serie, true),
            y: exportData(serie, false),
            xAxis: allaxes.x.indexOf(serie.getXAxis()),
            yAxis: allaxes.y.indexOf(serie.getYAxis()),
            style: style,
            lineStyle: linestyle
          };
        }));

        return schema;
      }
    }], [{
      key: 'fromJSON',
      value: function fromJSON(schema, wrapper) {

        var graph = void 0,
            options = {},
            axes = {
          left: [],
          top: [],
          right: [],
          bottom: []
        },
            style = void 0;

        if (schema.title) {
          options.title = schema.title;
        }

        if (schema.axis) {

          schema.axis.forEach(function (schemaAxis) {

            if (!schemaAxis.type) {
              util.throwError('Axis type is required (top, bottom, left or right)');
            }

            var axisOptions = {};
            if (schemaAxis.label) {
              axisOptions.labelValue = schemaAxis.label;
            }

            if (schemaAxis.unit !== undefined) {
              axisOptions.unit = schemaAxis.unit;
            }

            if (schemaAxis.unitWrapperAfter !== undefined) {
              axisOptions.unitWrapperAfter = schemaAxis.unitWrapperAfter;
            }

            if (schemaAxis.unitWrapperBefore !== undefined) {
              axisOptions.unitWrapperBefore = schemaAxis.unitWrapperBefore;
            }

            if (schemaAxis.min !== undefined) {
              axisOptions.forcedMin = schemaAxis.min;
            }

            if (schemaAxis.max !== undefined) {
              axisOptions.forcedMax = schemaAxis.max;
            }

            if (schemaAxis.flip !== undefined) {
              axisOptions.flipped = schemaAxis.flip;
            }

            axes[schemaAxis.type].push(axisOptions);
            schemaAxis._jsGraphIndex = axes[schemaAxis.type].length - 1;
          });
        }

        graph = new Graph(wrapper, options, axes);

        if (schema.width) {
          graph.setWidth(schema.width);
        }

        if (schema.height) {
          graph.setHeight(schema.width);
        }

        graph._resize();

        if (schema.data) {

          schema.data.forEach(function (schemaSerie) {

            var serieType = schemaSerie.type,
                serie,
                serieOptions = {},
                serieAxis;

            var waveform = void 0;

            switch (schemaSerie.type) {

              case 'bar':
                util.throwError('Bar charts not supported');
                serieType = false;
                break;

              case 'color':
                serieType = Graph.SERIE_LINE_COLORED;
                break;

              case 'scatter':
                serieType = Graph.SERIE_SCATTER;
                break;

              case 'box':
                serieType = Graph.SERIE_BOX;

                if (schemaSerie.orientation == 'x' || schemaSerie.orientation == 'y') {
                  serieOptions.orientation = schemaSerie.orientation;
                }
                break;

              default:
                serieType = Graph.SERIE_LINE;
                break;
            }

            if (serieType !== Graph.SERIE_BOX) {
              waveform = Graph.newWaveform();
            }

            if (!serieType) {
              util.throwError('No valid serie type was found');
              return;
            }

            serie = graph.newSerie(schemaSerie.id || schemaSerie.label || util.guid(), serieOptions, serieType);

            if (schemaSerie.lineStyle) {

              var lineStyle = schemaSerie.lineStyle;

              if (Array.isArray(lineStyle)) {
                lineStyle = {
                  unselected: lineStyle
                };
              }

              Object.entries(lineStyle).forEach(function (_ref2) {
                var _ref3 = _slicedToArray(_ref2, 2),
                    styleName = _ref3[0],
                    style = _ref3[1];

                var styleSerie = {};

                switch (serieType) {

                  case Graph.SERIE_LINE:
                    if (style.lineWidth !== undefined) {
                      styleSerie.lineWidth = style.lineWidth;
                    }

                    if (style.color !== undefined) {
                      styleSerie.lineColor = style.color;
                    }

                    if (style.lineStyle) {
                      styleSerie.lineStyle = style.lineStyle;
                    }

                    serie.setStyle(styleSerie, styleName);
                    break;
                }
              });
            }

            var defaultStyle = {};
            var defaultStyles = {};

            if (schemaSerie.defaultStyle) {
              defaultStyle = schemaSerie.defaultStyle;
            }

            if (schemaSerie.defaultStyles) {
              defaultStyles = schemaSerie.defaultStyles;
            }

            if (schemaSerie.styles) {

              var individualStyles = void 0;

              if (Array.isArray(schemaSerie.styles)) {
                individualStyles = {
                  unselected: schemaSerie.styles
                };
              } else {
                individualStyles = schemaSerie.styles;
              }

              var styleNames = new Set(Object.keys(defaultStyles).concat(Object.keys(individualStyles)));

              styleNames.forEach(function (styleName) {

                var styleSerie = {};
                var style = [],
                    styles = void 0;

                if (individualStyles && individualStyles[styleName]) {

                  style = individualStyles[styleName];

                  if (!Array.isArray(style)) {
                    style = [style];
                  }

                  styles = style.map(function (eachStyleElement) {

                    switch (serieType) {

                      case Graph.SERIE_LINE:

                        return {
                          type: eachStyleElement.shape,
                          zoom: eachStyleElement.zoom,
                          strokeWidth: eachStyleElement.lineWidth,
                          strokeColor: eachStyleElement.lineColor,
                          fillColor: eachStyleElement.color,
                          points: eachStyleElement.points
                        };

                        break;

                      case Graph.SERIE_BOX:

                        return eachStyleElement;

                        break;

                      case Graph.SERIE_SCATTER:
                        return eachStyleElement;

                        break;
                    }
                  });
                }

                switch (serieType) {

                  case Graph.SERIE_LINE:

                    serie.setMarkers(styles, styleName);
                    break;

                  case Graph.SERIE_SCATTER:
                    serie.setStyle(Object.assign({}, defaultScatterStyle, defaultStyle, defaultStyles[styleName] || {}), styles, styleName);
                    break;

                  case Graph.SERIE_BOX:

                    serie.setStyle(styles[0], styleName || 'unselected');
                    break;
                }
              });
            }

            if (schemaSerie.color && serieType == Graph.SERIE_LINE_COLORED) {
              serie.setColors(schemaSerie.color);
            }

            if (serieType !== Graph.SERIE_BOX) {
              waveform.setData(schemaSerie.y, schemaSerie.x);
            }

            if (!serie) {
              return;
            }

            var errorBarsXAbove = [],
                errorBarsXBelow = [],
                errorBarsYAbove = [],
                errorBarsYBelow = [],
                errorBoxesXAbove = [],
                errorBoxesXBelow = [],
                errorBoxesYAbove = [],
                errorBoxesYBelow = [];

            if (waveform !== undefined) {
              var errors = [];
              if (schemaSerie.errorX) {

                for (var i = 0, l = schemaSerie.errorX.length; i < l; i++) {

                  if (Array.isArray(schemaSerie.errorX[i])) {

                    errorBarsXAbove.push(schemaSerie.errorX[i][0]);
                    errorBarsXBelow.push(schemaSerie.errorX[i][1]);
                  } else {
                    errorBarsXAbove.push(schemaSerie.errorX[i]);
                    errorBarsXBelow.push(schemaSerie.errorX[i]);
                  }
                }
              } else if (schemaSerie.errorBarX || schemaSerie.errorBoxX) {

                if (schemaSerie.errorBarX) {

                  for (var i = 0, l = schemaSerie.errorBarX.length; i < l; i++) {

                    if (Array.isArray(schemaSerie.errorBarX[i])) {

                      errorBarsXAbove.push(schemaSerie.errorBarX[i][0]);
                      errorBarsXBelow.push(schemaSerie.errorBarX[i][1]);
                    } else {
                      errorBarsXAbove.push(schemaSerie.errorBarX[i]);
                      errorBarsXBelow.push(schemaSerie.errorBarX[i]);
                    }
                  }
                }

                if (schemaSerie.errorBoxX) {

                  for (var i = 0, l = schemaSerie.errorBoxX.length; i < l; i++) {

                    if (Array.isArray(schemaSerie.errorBoxX[i])) {

                      errorBoxesXAbove.push(schemaSerie.errorBoxX[i][0]);
                      errorBoxesXBelow.push(schemaSerie.errorBoxX[i][1]);
                    } else {
                      errorBoxesXAbove.push(schemaSerie.errorBoxX[i]);
                      errorBoxesXBelow.push(schemaSerie.errorBoxX[i]);
                    }
                  }
                }
              }

              if (schemaSerie.errorY) {

                for (var i = 0, l = schemaSerie.errorY.length; i < l; i++) {

                  if (Array.isArray(schemaSerie.errorY[i])) {

                    errorBarsYAbove.push(schemaSerie.errorY[i][0]);
                    errorBarsYBelow.push(schemaSerie.errorY[i][1]);
                  } else {
                    errorBarsYAbove.push(schemaSerie.errorY[i]);
                    errorBarsYBelow.push(schemaSerie.errorY[i]);
                  }
                }
              } else if (schemaSerie.errorBarY || schemaSerie.errorBoxY) {

                if (schemaSerie.errorBarY) {

                  for (var i = 0, l = schemaSerie.errorBarY.length; i < l; i++) {

                    if (Array.isArray(schemaSerie.errorBarY[i])) {

                      errorBarsYAbove.push(schemaSerie.errorBarY[i][0]);
                      errorBarsYBelow.push(schemaSerie.errorBarY[i][1]);
                    } else {
                      errorBarsYAbove.push(schemaSerie.errorBarY[i]);
                      errorBarsYBelow.push(schemaSerie.errorBarY[i]);
                    }
                  }
                }

                if (schemaSerie.errorBoxY) {

                  for (var i = 0, l = schemaSerie.errorBoxY.length; i < l; i++) {

                    if (Array.isArray(schemaSerie.errorBoxY[i])) {

                      errorBoxesYAbove.push(schemaSerie.errorBoxY[i][0]);
                      errorBoxesYBelow.push(schemaSerie.errorBoxY[i][1]);
                    } else {
                      errorBoxesYAbove.push(schemaSerie.errorBoxY[i]);
                      errorBoxesYBelow.push(schemaSerie.errorBoxY[i]);
                    }
                  }
                }
              }

              style = {};
              if (errorBarsXAbove.length > 0) {
                waveform.setErrorBarXAbove(Graph.newWaveform(errorBarsXAbove));
                style.right = {};
              }
              if (errorBarsXBelow.length > 0) {
                waveform.setErrorBarXAbove(Graph.newWaveform(errorBarsXAbove));
                style.left = {};
              }
              if (errorBarsYAbove.length > 0) {
                waveform.setErrorBarXAbove(Graph.newWaveform(errorBarsYAbove));
                style.top = {};
              }
              if (errorBarsYBelow.length > 0) {
                waveform.setErrorBarXAbove(Graph.newWaveform(errorBarsYAbove));
                style.bottom = {};
              }

              serie.setErrorBarStyle(style);

              style = {};
              if (errorBoxesXAbove.length > 0) {
                waveform.setErrorBoxXAbove(Graph.newWaveform(errorBoxesXAbove));
                style.right = {};
              }
              if (errorBoxesXBelow.length > 0) {
                waveform.setErrorBoxXBelow(Graph.newWaveform(errorBoxesXBelow));
                style.left = {};
              }
              if (errorBoxesYAbove.length > 0) {
                waveform.setErrorBoxAbove(Graph.newWaveform(errorBoxesYAbove));
                style.top = {};
              }
              if (errorBoxesYBelow.length > 0) {
                waveform.setErrorBoxBelow(Graph.newWaveform(errorBoxesYBelow));
                style.bottom = {};
              }
              serie.setErrorBoxStyle(style);
            }

            if (schema.axis) {
              serieAxis = schema.axis[schemaSerie.xAxis];

              if (!serieAxis || serieAxis.type !== 'top' && serieAxis.type !== 'bottom') {
                util.warn('No x axis found. Setting automatically');
                serie.setXAxis(graph.getXAxis(0));
              } else {
                if (serieAxis.type == 'top') {
                  serie.setXAxis(graph.getTopAxis(serieAxis._jsGraphIndex));
                } else if (serieAxis.type == 'bottom') {
                  serie.setXAxis(graph.getBottomAxis(serieAxis._jsGraphIndex));
                }
              }

              serieAxis = schema.axis[schemaSerie.yAxis];

              if (!serieAxis || serieAxis.type !== 'left' && serieAxis.type !== 'right') {
                util.warn('No y axis found. Setting automatically');
                serie.setYAxis(graph.getYAxis(0));
              } else {
                if (serieAxis.type == 'left') {
                  serie.setYAxis(graph.getLeftAxis(serieAxis._jsGraphIndex));
                } else if (serieAxis.type == 'right') {
                  serie.setYAxis(graph.getRightAxis(serieAxis._jsGraphIndex));
                }
              }
            } else {
              util.warn('No axes found. Setting automatically');
              serie.autoAxis();
            }

            switch (serieType) {

              case Graph.SERIE_BOX:

                serie.setData(schemaSerie.boxes);

                break;

              default:
              case Graph.SERIE_SCATTER:
              case Graph.SERIE_LINE_COLORED:
              case Graph.SERIE_LINE:

                serie.setWaveform(waveform);

                break;
            }
          });
        }

        graph.autoscaleAxes();
        graph.draw();

        return graph;
      }
    }, {
      key: 'registerConstructor',
      value: function registerConstructor(constructorName, constructor) {

        if (_constructors.has(constructorName)) {
          return util.throwError('Constructor ' + constructor + ' already exists.');
        }

        _constructors.set(constructorName, constructor);
      }
    }, {
      key: 'getConstructor',
      value: function getConstructor(constructorName) {
        var softFail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;


        if (!_constructors.has(constructorName)) {

          if (softFail) {
            return false;
          }

          return util.throwError('Constructor "' + constructorName + '" doesn\'t exist');
        }

        return _constructors.get(constructorName);
      }
    }, {
      key: 'newWaveform',
      value: function newWaveform() {
        return new (Function.prototype.bind.apply(_waveform2.default, [null].concat(Array.prototype.slice.call(arguments))))();
      }
    }, {
      key: 'waveform',
      value: function waveform() {
        return new (Function.prototype.bind.apply(_waveform2.default, [null].concat(Array.prototype.slice.call(arguments))))();
      }
    }]);

    return Graph;
  }(_EventEmitter3.default);

  // Adds getConstructor to the prototype. Cannot do that in ES6 classes
  Graph.prototype.getConstructor = Graph.getConstructor;

  function makeSerie(graph, name, options, type) {

    var constructor = graph.getConstructor(type, true);
    if (!constructor && typeof type == 'string') {
      constructor = graph.getConstructor('graph.serie.' + type, true);
    }

    if (constructor) {

      var serie = new constructor(graph, name, options);
      //serie.init( graph, name, options );
      graph.appendSerieToDom(serie);
    } else {

      return util.throwError('No constructor exists for the serie type provided. Use Graph.registerConstructor( name, constructor ) first is you use your own series');
    }

    return serie;
  }

  function getAxisLevelFromSpan(span, level) {

    for (var i = 0, l = level.length; i < l; i++) {

      var possible = true;
      for (var k = 0, m = level[i].length; k < m; k++) {

        if (!(span[0] < level[i][k][0] && span[1] < level[i][k][0] || span[0] > level[i][k][1] && span[1] > level[i][k][1])) {
          possible = false;
        }
      }

      if (possible) {

        level[i].push(span);
        return i;
      }
    }

    level.push([span]);
    return level.length - 1;
  }

  function refreshDrawingZone(graph) {

    var i, j, l, xy, min, max, axis;
    var shift = {
      top: [],
      bottom: [],
      left: [],
      right: []
    };

    var levels = {
      top: [],
      bottom: [],
      left: [],
      right: []
    };

    graph._painted = true;
    // Apply to top and bottom

    graph._applyToAxes(function (axis, position) {

      if (!axis.isShown()) {
        axis.hideGroup();
        return;
      } else {
        axis.showGroup();
      }

      if (axis.floating) {
        return;
      }

      var level = getAxisLevelFromSpan(axis.getSpan(), levels[position]);
      axis.setLevel(level);

      shift[position][level] = Math.max(axis.getAxisPosition(), shift[position][level] || 0);
    }, false, true, false);

    var shiftTop = shift.top.reduce(function (prev, curr) {
      return prev + curr;
    }, 0);

    var shiftBottom = shift.bottom.reduce(function (prev, curr) {
      return prev + curr;
    }, 0);

    graph.drawingSpaceHeight = graph.getDrawingHeight() - shiftTop - shiftBottom;

    [shift.top, shift.bottom].map(function (arr) {
      arr.reduce(function (prev, current, index) {
        arr[index] = prev + current;
        return prev + current;
      }, 0);
    });

    // Apply to top and bottom
    graph._applyToAxes(function (axis, position) {

      if (!axis.isShown() || axis.floating) {
        return;
      }

      axis.setShift(shift[position][axis.getLevel()]);
    }, false, true, false);

    // Applied to left and right
    graph._applyToAxes(function (axis, position) {

      if (!axis.isShown()) {
        axis.hideGroup();
        // Don't return here. We need to go through the draw method as the axis must be assigned minPx and maxPx values.
        // This is because some series can still be visible although the axis isn't.
      } else {
        axis.showGroup();
      }

      axis.setMinPx(shiftTop);
      axis.setMaxPx(graph.getDrawingHeight(true) - shiftBottom);

      if (axis.floating) {
        return;
      }

      // First we need to draw it in order to determine the width to allocate
      // graph is done to accomodate 0 and 100000 without overlapping any element in the DOM (label, ...)

      // Let's not draw dependant axes yet
      var drawn = !axis.linkedToAxis ? axis.draw() : 0;

      if (!axis.isShown()) {
        return;
      }
      // Get axis position gives the extra shift that is common
      var level = getAxisLevelFromSpan(axis.getSpan(), levels[position]);
      axis.setLevel(level);
      shift[position][level] = Math.max(drawn, shift[position][level] || 0);
    }, false, false, true);

    var shift2 = util.extend(true, {}, shift);

    // Applied to left and right
    graph._applyToAxes(function (axis, position) {

      if (!axis.isShown() || axis.floating) {
        return;
      }

      shift2[position][axis.getLevel()] = Math.max(shift[position][axis.getLevel()], axis.equalizePosition(shift[position][axis.getLevel()]));
    }, false, false, true);

    shift = shift2;

    var shiftLeft = shift.left.reduce(function (prev, curr) {
      return prev + curr;
    }, 0);

    var shiftRight = shift.right.reduce(function (prev, curr) {
      return prev + curr;
    }, 0);

    graph.drawingSpaceWidth = graph.getDrawingWidth() - shiftLeft - shiftRight;

    [shift.left, shift.right].map(function (arr) {
      arr.reduce(function (prev, current, index) {
        arr[index] = prev + current;
        return prev + current;
      }, 0);
    });

    // Apply to left and right
    graph._applyToAxes(function (axis, position) {

      if (!axis.isShown() || axis.floating) {
        return;
      }
      axis.setShift(shift[position][axis.getLevel()]);
    }, false, false, true);

    // Apply to top and bottom
    graph._applyToAxes(function (axis, position) {

      if (!axis.isShown()) {
        //      return;
      }

      axis.setMinPx(shiftLeft);
      axis.setMaxPx(graph.getDrawingWidth(true) - shiftRight);

      if (axis.floating) {
        return;
      }

      if (!axis.linkedToAxis) {
        axis.draw();
      }
    }, false, true, false);

    // Floating axes
    graph._applyToAxes(function (axis) {

      if (!axis.floating) {
        return;
      }

      var floatingAxis = axis.getFloatingAxis();
      var floatingValue = axis.getFloatingValue();
      var floatingPx = floatingAxis.getPx(floatingValue);

      axis.setShift(floatingPx);

      if (!axis.linkedToAxis) {
        axis.draw();
      }
    }, false, true, true);

    _closeLine(graph, 'right', graph.getDrawingWidth(true), graph.getDrawingWidth(true), shiftTop, graph.getDrawingHeight(true) - shiftBottom);
    _closeLine(graph, 'left', 0, 0, shiftTop, graph.getDrawingHeight(true) - shiftBottom);
    _closeLine(graph, 'top', shiftLeft, graph.getDrawingWidth(true) - shiftRight, 0, 0);
    _closeLine(graph, 'bottom', shiftLeft, graph.getDrawingWidth(true) - shiftRight, graph.getDrawingHeight(true) - shiftBottom, graph.getDrawingHeight(true) - shiftBottom);

    graph.clipRect.setAttribute('y', shiftTop);
    graph.clipRect.setAttribute('x', shiftLeft);
    graph.clipRect.setAttribute('width', graph.getDrawingWidth() - shiftLeft - shiftRight);
    graph.clipRect.setAttribute('height', graph.getDrawingHeight() - shiftTop - shiftBottom);

    graph.rectEvent.setAttribute('y', shiftTop + graph.getPaddingTop());
    graph.rectEvent.setAttribute('x', shiftLeft + graph.getPaddingLeft());

    graph.rectEvent.setAttribute('width', graph.drawingSpaceWidth);
    graph.rectEvent.setAttribute('height', graph.drawingSpaceHeight);

    graph.drawingSpaceMinX = shiftLeft + graph.getPaddingLeft(); // + "px";
    graph.drawingSpaceMinY = shiftTop + graph.getPaddingTop(); // + "px";
    graph.drawingSpaceMaxX = graph.getDrawingWidth() - shiftRight + graph.getPaddingLeft(); // + "px";
    graph.drawingSpaceMaxY = graph.getDrawingHeight() - shiftBottom + graph.getPaddingTop(); //  + "px";

    // Apply to top and bottom
    graph._applyToAxes(function (axis, position) {

      if (!axis.isShown()) {
        return;
      }

      axis.drawLines();
    }, false, true, true);

    /*
    graph.shapeZoneRect.setAttribute('x', shift[1]);
    graph.shapeZoneRect.setAttribute('y', shift[2]);
    graph.shapeZoneRect.setAttribute('width', graph.getDrawingWidth() - shift[2] - shift[3]);
    graph.shapeZoneRect.setAttribute('height', graph.getDrawingHeight() - shift[1] - shift[0]);
    */
    graph.shift = shift;
    graph.redrawShapes(); // Not sure this should be automatic here. The user should be clever.
  }

  function _handleKey(graph, event, type) {

    var self = graph;
    console.log(event, type);
    if (graph.forcedPlugin) {

      graph.activePlugin = graph.forcedPlugin;
      graph._pluginExecute(graph.activePlugin, type, [graph, event]);
      return;
    }

    checkKeyActions(graph, event, [graph, event], type);
  }

  // Similar to checkMouseActions
  function checkKeyActions(graph, e, parameters, methodName) {

    var keyComb = graph.options.keyActions,
        i,
        l;

    for (i = 0, l = keyComb.length; i < l; i++) {

      if (keyComb[i].plugin) {
        // Is it a plugin ?

        if (graph.forcedPlugin == keyComb[i].plugin || graph.isActionAllowed(e, keyComb[i])) {

          if (keyComb[i].options) {
            parameters.push(keyComb[i].options);
          }

          graph.activePlugin = keyComb[i].plugin; // Lease the mouse action to the current action
          graph._pluginExecute(keyComb[i].plugin, methodName, parameters);

          e.preventDefault();
          e.stopPropagation();

          return true;
        }
      } else if (keyComb[i].callback && graph.isActionAllowed(e, keyComb[i])) {

        if (keyComb[i].options) {
          parameters.push(keyComb[i].options);
        }

        e.preventDefault();
        e.stopPropagation();

        keyComb[i].callback.apply(graph, parameters);
        return true;
      }

      if (keyComb[i].removeSelectedShape && graph.isActionAllowed(e, keyComb[i])) {

        e.preventDefault();
        e.stopPropagation();

        graph.selectedShapes.map(function (shape) {

          shape.kill(keyComb[i].keepInDom);
        });
      }

      /* else if ( keyComb[ i ].series ) {
         var series;
        if ( keyComb[ i ].series === 'all' ) {
          series = graph.series;
        }
         if ( !Array.isArray( keyComb[ i ].series ) ) {
          series = [ series ];
        }
         if ( keyComb[ i ].options ) {
          parameters.push( keyComb[ i ].options );
        }
         for ( var j = 0; j < series.length; i++ ) {
          graph._serieExecute( series[ i ], methodName, parameters );
        }
        return true;
      }*/
    }

    return false;
  }

  function doDom() {

    // Create SVG element, set the NS
    this.dom = document.createElementNS(Graph.ns, 'svg');
    this.dom.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:xlink', 'http://www.w3.org/1999/xlink');
    //this.dom.setAttributeNS(this.ns, 'xmlns:xlink', this.nsxml);
    util.setAttributeTo(this.dom, {
      'xmlns': Graph.ns,
      'font-family': this.options.fontFamily,
      'font-size': this.options.fontSize
    });

    try {
      util.setAttributeTo(this.dom, {
        // eslint-disable-next-line no-undef
        'data-jsgraph-version': 'v2.0.100'
      });
    } catch (e) {
      // ignore
    }

    this.defs = document.createElementNS(Graph.ns, 'defs');
    this.dom.appendChild(this.defs);

    this.groupEvent = document.createElementNS(Graph.ns, 'g');

    this.rectEvent = document.createElementNS(Graph.ns, 'rect');
    util.setAttributeTo(this.rectEvent, {
      'pointer-events': 'fill',
      'fill': 'transparent'
    });
    this.groupEvent.appendChild(this.rectEvent);

    this.dom.appendChild(this.groupEvent);

    // Handling graph title
    this.domTitle = document.createElementNS(Graph.ns, 'text');
    this.setTitle(this.options.title);
    util.setAttributeTo(this.domTitle, {
      'text-anchor': 'middle',
      'y': 20
    });
    this.groupEvent.appendChild(this.domTitle);
    //

    this.graphingZone = document.createElementNS(Graph.ns, 'g');
    this.updateGraphingZone();

    this.groupEvent.appendChild(this.graphingZone);

    /*  this.shapeZoneRect = document.createElementNS(this.ns, 'rect');
    //this.shapeZoneRect.setAttribute('pointer-events', 'fill');
    this.shapeZoneRect.setAttribute('fill', 'transparent');
    this.shapeZone.appendChild(this.shapeZoneRect);
    */
    this.axisGroup = document.createElementNS(Graph.ns, 'g');
    this.graphingZone.appendChild(this.axisGroup);

    this.groupGrids = document.createElementNS(Graph.ns, 'g');

    // With the z stacking, this should probably be removed
    //this.groupGrids.setAttribute( 'clip-path', 'url(#_clipplot' + this._creation + ')' );

    this.groupPrimaryGrids = document.createElementNS(Graph.ns, 'g');
    this.groupSecondaryGrids = document.createElementNS(Graph.ns, 'g');

    this.axisGroup.appendChild(this.groupGrids);

    this.groupGrids.appendChild(this.groupSecondaryGrids);
    this.groupGrids.appendChild(this.groupPrimaryGrids);

    this.plotGroup = document.createElementNS(Graph.ns, 'g');
    this.graphingZone.appendChild(this.plotGroup);

    // 5 September 2014. I encountered a case here shapeZone must be above plotGroup
    /*this.shapeZone = document.createElementNS( this.ns, 'g' );
    this.graphingZone.appendChild( this.shapeZone );
    */

    this.layers = [];

    this._makeClosingLines();

    this.clip = document.createElementNS(Graph.ns, 'clipPath');
    this.clip.setAttribute('id', '_clipplot' + this._creation);
    this.defs.appendChild(this.clip);

    this.clipRect = document.createElementNS(Graph.ns, 'rect');
    this.clip.appendChild(this.clipRect);
    this.clip.setAttribute('clipPathUnits', 'userSpaceOnUse');

    this.markerArrow = document.createElementNS(this.ns, 'marker');
    this.markerArrow.setAttribute('viewBox', '0 0 10 10');
    this.markerArrow.setAttribute('id', 'arrow' + this._creation);
    this.markerArrow.setAttribute('refX', '6');
    this.markerArrow.setAttribute('refY', '5');
    this.markerArrow.setAttribute('markerUnits', 'strokeWidth');
    this.markerArrow.setAttribute('markerWidth', '8');
    this.markerArrow.setAttribute('markerHeight', '6');
    this.markerArrow.setAttribute('orient', 'auto');
    //this.markerArrow.setAttribute('fill', 'context-stroke');
    //this.markerArrow.setAttribute('stroke', 'context-stroke');

    var pathArrow = document.createElementNS(Graph.ns, 'path');
    pathArrow.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
    //pathArrow.setAttribute( 'fill', 'context-stroke' );
    this.markerArrow.appendChild(pathArrow);

    this.defs.appendChild(this.markerArrow);

    // Horionzal split marker for axis
    this.markerHorizontalSplit = document.createElementNS(Graph.ns, 'marker');
    this.markerHorizontalSplit.setAttribute('viewBox', '0 0 6 8');
    this.markerHorizontalSplit.setAttribute('id', 'horionzalsplit_' + this.getId());
    this.markerHorizontalSplit.setAttribute('refX', '3');
    this.markerHorizontalSplit.setAttribute('refY', '4');
    this.markerHorizontalSplit.setAttribute('markerUnits', 'strokeWidth');
    this.markerHorizontalSplit.setAttribute('markerWidth', '6');
    this.markerHorizontalSplit.setAttribute('markerHeight', '8');

    var path = document.createElementNS(Graph.ns, 'line');
    path.setAttribute('x1', '0');
    path.setAttribute('y1', '8');

    path.setAttribute('x2', '6');
    path.setAttribute('y2', '0');

    path.setAttribute('stroke', 'black');
    this.markerHorizontalSplit.appendChild(path);

    this.defs.appendChild(this.markerHorizontalSplit);

    // Vertical split marker for axis
    this.markerVerticalSplit = document.createElementNS(Graph.ns, 'marker');
    this.markerVerticalSplit.setAttribute('viewBox', '0 0 8 6');
    this.markerVerticalSplit.setAttribute('id', 'verticalsplit_' + this.getId());
    this.markerVerticalSplit.setAttribute('refX', '4');
    this.markerVerticalSplit.setAttribute('refY', '3');
    this.markerVerticalSplit.setAttribute('markerUnits', 'strokeWidth');
    this.markerVerticalSplit.setAttribute('markerWidth', '8');
    this.markerVerticalSplit.setAttribute('markerHeight', '6');

    var path = document.createElementNS(Graph.ns, 'line');

    path.setAttribute('x1', '0');
    path.setAttribute('y1', '0');

    path.setAttribute('x2', '8');
    path.setAttribute('y2', '6');

    path.setAttribute('stroke', 'black');
    this.markerVerticalSplit.appendChild(path);
    this.defs.appendChild(this.markerVerticalSplit);

    this.vertLineArrow = document.createElementNS(Graph.ns, 'marker');
    this.vertLineArrow.setAttribute('viewBox', '0 0 10 10');
    this.vertLineArrow.setAttribute('id', 'verticalline' + this._creation);
    this.vertLineArrow.setAttribute('refX', '0');
    this.vertLineArrow.setAttribute('refY', '5');
    this.vertLineArrow.setAttribute('markerUnits', 'strokeWidth');
    this.vertLineArrow.setAttribute('markerWidth', '20');
    this.vertLineArrow.setAttribute('markerHeight', '10');
    this.vertLineArrow.setAttribute('orient', 'auto');
    //this.vertLineArrow.setAttribute('fill', 'context-stroke');
    //this.vertLineArrow.setAttribute('stroke', 'context-stroke');
    this.vertLineArrow.setAttribute('stroke-width', '1px');

    var pathVertLine = document.createElementNS(Graph.ns, 'path');
    pathVertLine.setAttribute('d', 'M 0 -10 L 0 10');
    pathVertLine.setAttribute('stroke', 'black');

    this.vertLineArrow.appendChild(pathVertLine);

    this.defs.appendChild(this.vertLineArrow);

    // Removed with z stacking ?
    //    this.plotGroup.setAttribute( 'clip-path', 'url(#_clipplot' + this._creation + ')' );

    this.bypassHandleMouse = false;
  }

  function _registerEvents(graph) {
    var self = graph;

    if (!graph.wrapper) {
      throw 'No wrapper exists. Cannot register the events.';
    }

    graph.dom.setAttribute('tabindex', 0);

    graph.dom.addEventListener('keydown', function (e) {
      _handleKey(graph, e, 'keydown');
    });

    graph.dom.addEventListener('keypress', function (e) {
      _handleKey(graph, e, 'keypress');
    });

    graph.dom.addEventListener('keyup', function (e) {
      _handleKey(graph, e, 'keyup');
    });
    // Not sure this has to be prevented

    // August 17th, 2017: I extended the graph.groupEvent to the more general graph.dom to make the zoom plugin more
    // intuitive. Let us see if it breaks another example...
    graph.dom.addEventListener('mousemove', function (e) {
      //e.preventDefault();
      var coords = graph._getXY(e);
      _handleMouseMove(graph, coords.x, coords.y, e);
    });

    graph.dom.addEventListener('mouseleave', function (e) {

      _handleMouseLeave(graph);
    });

    graph.groupEvent.addEventListener('mousedown', function (e) {

      graph.focus();

      //   e.preventDefault();
      if (e.which == 3 || e.ctrlKey) {
        return;
      }

      var coords = graph._getXY(e);
      _handleMouseDown(graph, coords.x, coords.y, e);
    });

    graph.dom.addEventListener('mouseup', function (e) {

      graph.emit('mouseUp', e);
      var coords = graph._getXY(e);

      _handleMouseUp(graph, coords.x, coords.y, e);
    });

    graph.wrapper.addEventListener('mouseup', function (e) {
      e.stopPropagation();
    });

    graph.dom.addEventListener('dblclick', function (e) {

      graph.emit('dblClick', e);
      var coords = graph._getXY(e);

      _handleDblClick(graph, coords.x, coords.y, e);
    });

    graph.groupEvent.addEventListener('click', function (e) {

      // Cancel right click or Command+Click
      if (e.which == 3 || e.ctrlKey) {
        return;
      }

      //   e.preventDefault();
      var coords = graph._getXY(e);

      if (!graph.prevent(false)) {
        _handleClick(graph, coords.x, coords.y, e);
      }

      //}, 200 );
    });

    graph.groupEvent.addEventListener('mousewheel', function (e) {

      var deltaY = e.wheelDeltaY || e.wheelDelta || -e.deltaY;
      var coords = graph._getXY(e);
      _handleMouseWheel(graph, deltaY, coords.x, coords.y, e);

      return false;
    });

    graph.groupEvent.addEventListener('wheel', function (e) {

      var coords = graph._getXY(e);
      var deltaY = e.wheelDeltaY || e.wheelDelta || -e.deltaY;
      _handleMouseWheel(graph, deltaY, coords.x, coords.y, e);

      return false;
    });
  }

  function _handleMouseDown(graph, x, y, e) {

    var self = graph;

    if (graph.forcedPlugin) {

      graph.activePlugin = graph.forcedPlugin;
      graph._pluginExecute(graph.activePlugin, 'onMouseDown', [graph, x, y, e]);
      return;
    }

    if (graph.activePlugin) {
      graph.activePlugin = false;
    }

    checkMouseActions(graph, e, [graph, x, y, e], 'onMouseDown');
  }

  function _handleMouseMove(graph, x, y, e) {

    if (graph.bypassHandleMouse) {
      graph.bypassHandleMouse.handleMouseMove(e);
      return;
    }

    if (graph.activePlugin && graph._pluginExecute(graph.activePlugin, 'onMouseMove', [graph, x, y, e])) {
      return;
    }

    //			return;

    graph._applyToAxes('handleMouseMove', [x - graph.options.paddingLeft, e], true, false);
    graph._applyToAxes('handleMouseMove', [y - graph.options.paddingTop, e], false, true);

    if (!graph.activePlugin) {
      var index;

      // Takes care of the tracking line
      if (graph.options.trackingLine && graph.options.trackingLine.enable && graph.options.trackingLine.snapToSerie) {

        if (graph.options.trackingLine.mode == 'common') {

          var snapToSerie = graph.options.trackingLine.snapToSerie;
          index = snapToSerie.handleMouseMove(false, true);

          if (this.trackingObject) {

            if (!index) {

              graph.trackingObject.hide();
            } else {

              graph.trackingObject.show();

              graph.trackingObject.getPosition(0).x = index.xClosest;
              graph.trackingObject.getPosition(1).x = index.xClosest;
              graph.trackingObject.redraw();

              var x = snapToSerie.getXAxis().getPx(index.xClosest) + graph.options.paddingLeft;
            }
          }

          var series = graph.options.trackingLine.series;

          // Gets a default value
          if (!series) {

            series = graph.getSeries().map(function (serie) {
              return {
                serie: serie,
                withinPx: 20,
                withinVal: -1
              };
            });
          }

          graph._trackingLegend = _trackingLegendSerie(graph, series, x, y, graph._trackingLegend, graph.options.trackingLine.textMethod, index.xClosest);
        }
      }
    }
    // End takes care of the tracking line

    if (graph.options.onMouseMoveData) {
      var results = {};

      for (var i = 0; i < graph.series.length; i++) {

        results[graph.series[i].getName()] = graph.series[i].handleMouseMove(false, true);
      }

      graph.options.onMouseMoveData.call(graph, e, results);
    }

    checkMouseActions(graph, e, [graph, x, y, e], 'onMouseMove');
  }

  function checkMouseActions(graph, e, parameters, methodName) {

    var keyComb = graph.options.mouseActions,
        i,
        l,
        executed = false;

    for (i = 0, l = keyComb.length; i < l; i++) {

      if (keyComb[i].plugin) {
        // Is it a plugin ?

        if (graph.forcedPlugin == keyComb[i].plugin || graph.isActionAllowed(e, keyComb[i])) {

          if (keyComb[i].options) {
            parameters.push(keyComb[i].options);
          }

          // Lease the mouse action to the current action
          // 25.10.2017: Except for mousewheel. See #111
          if (e.type !== 'wheel' && e.type !== 'mousewheel') {
            graph.activePlugin = keyComb[i].plugin;
          }

          graph._pluginExecute(keyComb[i].plugin, methodName, parameters);
          executed = true;
          continue;
        }
      } else if (keyComb[i].callback && graph.isActionAllowed(e, keyComb[i])) {

        if (keyComb[i].options) {
          parameters.push(keyComb[i].options);
        }

        keyComb[i].callback.apply(graph, parameters);
        executed = true;
        continue;
      } else if (keyComb[i].series) {

        var series;
        if (keyComb[i].series === 'all') {
          series = graph.series;
        }

        if (!Array.isArray(keyComb[i].series)) {
          series = [series];
        }

        if (keyComb[i].options) {
          parameters.push(keyComb[i].options);
        }

        for (var j = 0; j < series.length; i++) {
          graph._serieExecute(series[i], methodName, parameters);
        }
        executed = true;
        continue;
      }
    }

    return executed;
  }

  var _trackingLegendSerie = function _trackingLegendSerie(graph, serie, x, y, legend, textMethod, xValue) {

    var justCreated = false;

    if (!Array.isArray(serie)) {
      serie = [serie];
    }

    var output = [];

    if (!legend && graph.options.trackingLine.legend) {
      justCreated = true;
      legend = _makeTrackingLegend(graph);
    }

    serie.map(function (serie) {

      var index = serie.serie.handleMouseMove(xValue, false);

      if (!index || !textMethod) {

        if (serie.serie.trackingShape) {
          serie.serie.trackingShape.hide();
        }

        return legend;
      }

      // Should we display the dot ?
      if (serie.withinPx > 0 && Math.abs(x - graph.options.paddingLeft - serie.serie.getXAxis().getPx(index.xClosest)) - serie.withinPx > 1e-14 || serie.withinVal > 0 && Math.abs(serie.serie.getXAxis().getVal(x - graph.options.paddingLeft) - index.xClosest) - serie.withinVal > serie.serie.getXAxis().getVal(x - graph.options.paddingLeft) / 100000) {

        if (serie.serie.trackingShape) {
          serie.serie.trackingShape.hide();
        }
      } else {

        output[serie.serie.getName()] = {

          yValue: index.xClosest,
          xValue: index.yClosest,
          serie: serie,
          index: index

        };

        var serieShape = void 0;
        if (graph.options.trackingLine && graph.options.trackingLine.serieShape) {
          serieShape = graph.options.trackingLine.serieShape;
        } else {
          serieShape = {
            shape: 'ellipse',
            properties: {
              rx: [serie.serie.getLineWidth() * 3 + 'px'],
              ry: [serie.serie.getLineWidth() * 3 + 'px']
            }
          };
        }

        if (!serie.serie.trackingShape) {

          serie.serie.trackingShape = graph.newShape(serieShape.shape, {
            fillColor: serie.serie.getLineColor(),
            strokeColor: 'White',
            strokeWidth: serie.serie.getLineWidth()
          }, true, serieShape.properties).setSerie(serie.serie).forceParentDom(serie.serie.groupMain).draw();

          serieShape.onCreated && serieShape.onCreated(serie.serie.trackingShape);

          serie.serie.trackingShape.on('changed', function () {

            serieShape.onChanged && serieShape.onChanged(serie.serie.trackingShape);
          });
        }

        serie.serie.trackingShape.show();
        serie.serie.trackingShape.getPosition(0).x = index.xClosest;

        if (serieShape.magnet) {

          var magnetOptions = serieShape.magnet,
              val = magnetOptions.within,
              minmaxpos = void 0;

          if (magnetOptions.withinPx) {
            val = serie.serie.getXAxis().getRelVal(magnetOptions.withinPx);
          }

          if (minmaxpos = serie.serie.findLocalMinMax(index.xClosest, val, magnetOptions.mode)) {

            serie.serie.trackingShape.getPosition(0).x = minmaxpos;
          }
        }

        serie.serie.trackingShape.redraw();
      }
    }); // End map

    if (!graph.options.trackingLine.legend) {
      return;
    }

    if (Object.keys(output).length == 0 || !textMethod) {
      legend.style.display = 'none';
    } else {

      if (legend.style.display == 'none' || justCreated) {

        forceTrackingLegendMode(graph, legend, x, y, true);
      } else {
        _trackingLegendMove(graph, legend, x, y);
      }

      legend.style.display = 'block';
      var txt = textMethod(output, xValue, x, y);

      legend.innerHTML = txt;

      //legend.innerHTML = textMethod( output, xValue, x, y );
    }

    return legend;
  };

  var forceTrackingLegendMode = function forceTrackingLegendMode(graph, legend, toX, toY, skip) {

    var ratio = 0,
        start = Date.now(),
        h = legend.offsetHeight,
        startX = parseInt(legend.style.marginLeft.replace('px', '') || 0),
        startY = parseInt(legend.style.marginTop.replace('px', '') || 0);

    toX = toX > graph.getWidth() / 2 ? toX - toX % 10 - 20 - legend.offsetWidth : toX - toX % 10 + 30;
    toY = toY - toY % 10 + h / 2;

    if (skip) {
      legend.style.marginLeft = toX + 'px';
      legend.style.marginTop = toY + 'px';
      return;
    }

    function next() {

      var progress = (Date.now() - start) / 200;
      if (progress > 1) {
        progress = 1;
      }

      legend.style.marginLeft = (toX - startX) * progress + startX + 'px';
      legend.style.marginTop = (toY - startY) * progress + startY + 'px';

      if (progress < 1) {
        window.requestAnimationFrame(next);
      }
    }

    window.requestAnimationFrame(next);
  };

  var _trackingLegendMove = util.debounce(forceTrackingLegendMode, 50);

  function _makeTrackingLegend(graph) {

    var group = document.createElement('div');
    group.setAttribute('class', 'trackingLegend');
    group.style.position = 'absolute';
    group.style.borderRadius = '4px';
    group.style.boxShadow = '1px 1px 3px 0px rgba(100,100,100,0.6)';
    group.style.border = '2px solid #333333';
    group.style.backgroundColor = 'rgba(255, 255, 255, 0.5 )';
    group.style.pointerEvents = 'none';
    group.style.paddingTop = '5px';
    group.style.paddingBottom = '5px';
    group.style.paddingLeft = '10px';
    group.style.paddingRight = '10px';

    graph.getWrapper().insertBefore(group, graph.getDom());

    return group;
  }

  function _handleDblClick(graph, x, y, e) {
    //	var _x = x - graph.options.paddingLeft;
    //	var _y = y - graph.options.paddingTop;
    var pref = graph.options.dblclick;
    checkMouseActions(graph, e, [x, y, e], 'onDblClick');
    /*
        if ( !pref || !pref.type ) {
          return;
        }
         switch ( pref.type ) {
           case 'plugin':
             var plugin;
             if ( ( plugin = graph.plugins[ pref.plugin ] ) ) {
               plugin.onDblClick( graph, x, y, pref.options, e );
            }
             break;
        }*/
  }

  function _handleMouseUp(graph, x, y, e) {

    if (graph.bypassHandleMouse) {
      graph.bypassHandleMouse.handleMouseUp(e);
      graph.activePlugin = false;
      return;
    }

    graph._pluginExecute(graph.activePlugin, 'onMouseUp', [graph, x, y, e]);
    graph.activePlugin = false;
  }

  function _handleClick(graph, x, y, e) {

    graph.emit('click', [graph, x, y, e]);
    // Not on a shape
    checkMouseActions(graph, e, [x, y, e], 'onClick');

    if (!e.target.jsGraphIsShape && !graph.prevent(false) && graph.options.shapesUnselectOnClick) {

      graph.unselectShapes();
    }
  }

  function _getAxis(graph, num, options, pos) {

    var options = options || {};
    var inst;

    var _availableAxes = {

      def: {
        x: graph.getConstructor('graph.axis.x'),
        y: graph.getConstructor('graph.axis.y')
      },

      time: {
        x: graph.getConstructor('graph.axis.x.time')
      },

      bar: {
        x: graph.getConstructor('graph.axis.x.bar')
      }
    };

    switch (options.type) {

      case 'time':
        var axisInstance = _availableAxes.time;
        break;

      case 'bar':
        var axisInstance = _availableAxes.bar;
        break;

      case 'broken':
        var axisInstance = _availableAxes.broken;
        break;

      default:
        var axisInstance = _availableAxes.def;
        break;
    }

    switch (pos) {

      case 'top':
      case 'bottom':
        inst = axisInstance.x;
        break;

      case 'left':
      case 'right':
        inst = axisInstance.y;
        break;
    }

    num = num || 0;

    if ((typeof num === 'undefined' ? 'undefined' : _typeof(num)) == 'object') {
      options = num;
      num = 0;
    }

    if (!graph.axis[pos][num]) {

      graph.axis[pos][num] = new inst(graph, pos, options);
      graph.axis[pos][num].init(graph, options);
    }

    return graph.axis[pos][num];
  }

  function _closeLine(graph, mode, x1, x2, y1, y2) {

    if (graph.options.close === false) {
      return;
    }

    var l = 0;

    graph.axis[mode].map(function (g) {

      if (g.isDisplayed() && !g.floating) {
        l++;
      }
    });

    if ((graph.options.close === true || graph.options.close[mode]) && l == 0) {

      graph.closingLines[mode].setAttribute('display', 'block');
      graph.closingLines[mode].setAttribute('x1', x1);
      graph.closingLines[mode].setAttribute('x2', x2);
      graph.closingLines[mode].setAttribute('y1', y1);
      graph.closingLines[mode].setAttribute('y2', y2);
    } else {

      graph.closingLines[mode].setAttribute('display', 'none');
    }
  }

  function _handleMouseWheel(graph, delta, coordX, coordY, e) {
    if (checkMouseActions(graph, e, [delta, e, coordX, coordY], 'onMouseWheel')) {
      e.preventDefault();
      e.stopPropagation();
    }
  }

  function _handleMouseLeave(graph) {
    if (graph.options.handleMouseLeave) {
      graph.options.handleMouseLeave.call(graph);
    }
  }

  function haveAxesChanged(graph) {
    var temp = graph._axesHaveChanged;
    graph._axesHaveChanged = false;
    return temp;
  }

  function hasSizeChanged(graph) {
    var temp = graph._sizeChanged;
    graph._sizeChanged = false;
    return temp;
  }

  // Constants
  Graph.SERIE_LINE = Symbol();
  Graph.SERIE_SCATTER = Symbol();
  Graph.SERIE_CONTOUR = Symbol();
  Graph.SERIE_BAR = Symbol();
  Graph.SERIE_BOX = Symbol();
  Graph.SERIE_ZONE = Symbol();
  Graph.SERIE_LINE_COLORED = Symbol();
  Graph.SERIE_ZONE = Symbol();
  Graph.SERIE_DENSITYMAP = Symbol();
  Graph.SERIE_LINE_3D = Symbol();
  Graph.SERIE_ZONE_3D = Symbol();

  Graph.TICKS_OUTSIDE = Symbol();
  Graph.TICKS_INSIDE = Symbol();
  Graph.TICKS_CENTERED = Symbol();

  Graph.ns = 'http://www.w3.org/2000/svg';
  Graph.nsxlink = 'http://www.w3.org/1999/xlink';

  exports.default = Graph;
  module.exports = exports['default'];
});

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(5), __webpack_require__(138)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('../graph.util.js'), require('./fit_lm.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphUtil, global.fit_lm);
    global.waveform = mod.exports;
  }
})(this, function (module, exports, _graphUtil, _fit_lm) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var util = _interopRequireWildcard(_graphUtil);

  var _fit_lm2 = _interopRequireDefault(_fit_lm);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var Waveform = function () {
    function Waveform() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var xOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var xScale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

      _classCallCheck(this, Waveform);

      this.xOffset = xOffset;
      this.xScale = xScale;

      // Error bar handling
      this.errors = {

        nb: 0,

        bars: {
          above: null,
          below: null
        },

        boxes: {
          above: null,
          below: null
        }
      };

      this.BELOW = Waveform.BELOW;
      this.ABOVE = Waveform.ABOVE;
      this.BOX = Waveform.BOX;
      this.BAR = Waveform.BAR;

      this.setData(data);
    }

    /** [ [ x1, y1 ], [ x2, y2 ] ] */

    /*
    setDataXY( data ) {
       let newData = [ this._makeArray( data.length ), this._makeArray( data.length ) ],
        warnNaN = false;
      const nanable = this.isNaNAllowed();
       data.map( ( el, index ) => {
         if ( !nanable && ( el[ 0 ] !== el[ 0 ] || el[ 1 ] !== el[ 1 ] ) ) {
          warnNaN = true;
        }
         newData[ 0 ][ index ] = el[ 0 ];
        newData[ 1 ][ index ] = el[ 1 ];
      } );
       if ( warnNaN ) {
        this.warn( "Trying to assign NaN values to a typed array that does not support NaNs. 0's will be used instead" );
      }
       this._setData( ...newData );
      return this;
    }
    */


    _createClass(Waveform, [{
      key: 'setData',
      value: function setData(data) {
        var dataX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;


        /* First, we must treat the case of the array of array for backward compatibility */
        if (Array.isArray(data[0])) {
          var x = [];
          var y = [];
          data.forEach(function (el) {
            x.push(el[0]);
            y.push(el[1]);
          });

          this.setXWaveform(x);
          data = y;
        }

        var newData = this._makeArray(data.length),
            warnNaN = false;

        var nanable = this.isNaNAllowed();

        data.map(function (el, index) {

          if (!nanable && (el[0] !== el[0] || el[1] !== el[1])) {
            warnNaN = true;
          }

          newData[index] = el;
        });

        if (warnNaN) {
          this.warn("Trying to assign NaN values to a typed array that does not support NaNs. 0's will be used instead");
        }

        this._setData(newData);

        if (dataX) {
          this.setXWaveform(dataX);
        }
        return this;
      }
    }, {
      key: 'getY',
      value: function getY(index, optimized) {

        if (optimized && this.dataInUse) {
          return this.dataInUse.y[index] * this.getScale() + this.getShift();
        }

        return this.data[index] * this.getScale() + this.getShift();
      }
    }, {
      key: 'setXWaveform',
      value: function setXWaveform(waveform) {

        if (!(waveform instanceof Waveform)) {

          if (Array.isArray(waveform)) {
            waveform = new Waveform(waveform);
          } else {
            throw 'Cannot set X waveform. Data is not a valid array.';
          }
        }

        this.xdata = waveform;
        this.computeXMinMax();
        return this;
      }
    }, {
      key: 'hasXWaveform',
      value: function hasXWaveform() {
        return !!this.xdata;
      }
    }, {
      key: 'getXWaveform',
      value: function getXWaveform() {
        if (this.xdata) {
          return this.xdata;
        }

        var wave = new Waveform();
        for (var i = 0; i < this.getLength(); i += 1) {
          wave.append(this.getX(i));
        }
        return wave;
      }
    }, {
      key: 'rescaleX',
      value: function rescaleX(offset, scale) {
        this.xScale = scale;
        this.xOffset = offset;
        this.computeXMinMax();
        return this;
      }
    }, {
      key: 'getTypedArrayClass',
      value: function getTypedArrayClass() {
        return this._typedArrayClass || false;
      }
    }, {
      key: 'setTypedArrayClass',
      value: function setTypedArrayClass(constructor) {

        if (this.getTypedArrayClass() && this.isNaNAllowed() && !this.isNaNAllowed(constructor)) {
          this.warn('NaN values are not allowed by the new constructor (' + constructor.name + ') while it was allowed by the previous one (' + this._typedArrayClass.name + ')');
        }

        if (this.getTypedArrayClass() && this.isUnsigned() && !this.isUnsigned(constructor)) {
          this.warn('You are switching from signed values to unsigned values. You may experience data corruption if there were some negative values.');
        }

        this._typedArrayClass = constructor;

        if (this.data) {
          this._setData(constructor.from(this.data));
        }

        if (this.hasXWaveform()) {
          this.getXWaveform().setTypedArrayClass(constructor);
        }
      }
    }, {
      key: 'isNaNAllowed',
      value: function isNaNAllowed() {
        var constructor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._typedArrayClass;


        // The following types accept NaNs
        return constructor == Array || constructor == Float32Array || constructor == Float64Array;
      }
    }, {
      key: 'isUnsigned',
      value: function isUnsigned() {
        var constructor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._typedArrayClass;


        // The following types accept NaNs
        return constructor == Uint8Array || constructor == Uint8ClampedArray || constructor == Uint16Array || constructor == Uint32Array;
      }
    }, {
      key: 'recalculateMinMaxNewPoint',
      value: function recalculateMinMaxNewPoint(x, y) {
        if (x < this.minX || this.minX === undefined) {
          this.minX = x;
        }

        if (x > this.maxX || this.maxX === undefined) {
          this.maxX = x;
        }

        if (y < this.minY || this.minY === undefined) {
          this.minY = y;
        }

        if (y > this.maxY || this.maxY === undefined) {
          this.maxY = y;
        }
      }
    }, {
      key: 'prepend',
      value: function prepend(x, y) {

        if (typeof x == 'function') {
          x = x(this);
        }

        if (typeof y == 'function') {
          y = y(this);
        }

        if (this.xdata) {
          this.xdata.prepend(null, x);
        } else if (x !== null) {
          this.xdata = this.getXWaveform();
          this.xdata.prepend(null, x);
        } else {
          this.xOffset -= this.xScale;
        }

        this.data.unshift(y);
        this.recalculateMinMaxNewPoint(x, y);
        return this;
      }
    }, {
      key: 'append',
      value: function append(x, y) {

        if (typeof x == 'function') {
          x = x(this);
        }

        if (typeof y == 'function') {
          y = y(this);
        }

        if (this.xdata) {
          this.xdata.append(null, x);
        } else if (x !== null) {
          this.xdata = this.getXWaveform();
          this.xdata.append(null, x);
        }

        if (this.monotoneous) {
          if (y > this.data[this.data.y] && this.getMonotoneousAscending() === false) {
            this.monotoneous = false;
          } else if (y < this.data[this.data.y] && this.getMonotoneousAscending() === true) {
            this.monotoneous = false;
          }
        }

        if (this.data.length == 1 || this._monotoneousAscending === undefined) {

          this.monotoneous = true;

          if (y == this.data[0]) {
            this._monotoneousAscending = undefined;
          } else {
            this._monotoneousAscending = y > this.data[0];
          }
        }

        this.data.push(y);
        this.recalculateMinMaxNewPoint(x, y);

        return this;
      }
    }, {
      key: '_makeArray',
      value: function _makeArray(length) {

        var constructor = this.getTypedArrayClass();
        if (constructor) {
          return new constructor(length);
        }
        return new Array(length);
      }
    }, {
      key: '_setData',
      value: function _setData(dataY) {
        var l = dataY.length;
        var i = 1,
            monoDir = dataY[1] > dataY[0],
            minY = dataY[0],
            maxY = dataY[0];

        if (isNaN(minY)) {
          minY = Number.MAX_VALUE;
        }

        if (isNaN(maxY)) {
          maxY = -Number.MAX_VALUE;
        }

        this._monotoneous = true;

        for (; i < l; i++) {
          if (dataY[i] !== dataY[i - 1] && monoDir !== dataY[i] > dataY[i - 1]) {
            this._monotoneous = false;
          }

          if (dataY[i] === dataY[i]) {
            // NaN support
            minY = Math.min(dataY[i], minY);
            maxY = Math.max(dataY[i], maxY);
          }
        }

        if (this._monotoneous) {
          this._monotoneousAscending = dataY[1] > dataY[0];
        }

        if (this.hasErrorBars()) {
          // If prefer to loop again here

          for (i = 0; i < l; i++) {

            if (dataY[i] === dataY[i]) {
              // NaN support

              minY = Math.min(minY, dataY[i] - this.getMaxError(i, 'below'));
              maxY = Math.max(maxY, dataY[i] + this.getMaxError(i, 'above'));
            }
          }

          this.minY = minY;
          this.maxY = maxY;
        } else {
          this.minY = minY;
          this.maxY = maxY;
        }

        this.data = dataY;

        this.computeXMinMax();
      }
    }, {
      key: 'computeXMinMax',
      value: function computeXMinMax() {

        if (!this.data) {

          return;
        }

        if (this.xdata) {

          this.minX = this.xdata.getMin();
          this.maxX = this.xdata.getMax();
        } else {

          var b1 = this.xOffset + this.xScale * this.getLength(),
              b2 = this.xOffset;

          this.minX = Math.min(b1, b2);
          this.maxX = Math.max(b1, b2);
        }
      }
    }, {
      key: 'getDataInUse',
      value: function getDataInUse() {
        return this.dataInUse || this.data;
      }
    }, {
      key: 'getIndexFromVal',
      value: function getIndexFromVal(val) {
        var useDataToUse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var roundingMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Math.round;


        var data = void 0;

        if (useDataToUse && this.dataInUse) {
          data = this.dataInUse.y;
        } else {
          data = this.data;
        }

        var position = void 0;

        position = this.getIndexFromData(val, data, this.data.getMonotoneousAscending(), roundingMethod);

        if (useDataToUse && this.dataInUse && this.dataInUseType == 'aggregateY') {
          // In case of aggregation, round to the closest element of 4.
          return position - position % 4;
        }

        return position;
      }
    }, {
      key: 'getIndexFromX',
      value: function getIndexFromX(xval) {
        var useDataToUse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var roundingMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Math.round;


        var xdata = void 0;

        if (useDataToUse && this.dataInUse) {
          xdata = this.dataInUse.x;
        } else if (this.xdata) {
          xdata = this.xdata.getData();
        }

        var position = void 0;

        if (this.hasXWaveform()) {
          position = this.xdata.getIndexFromData(xval, xdata, this.xdata.getMonotoneousAscending(), roundingMethod);
        } else {
          position = Math.max(0, Math.min(this.getLength() - 1, roundingMethod((xval - this.xOffset) / this.xScale)));
        }

        if (useDataToUse && this.dataInUse && this.dataInUseType == 'aggregateX') {
          // In case of aggregation, round to the closest element of 4.
          return position - position % 4;
        }

        return position;
      }
    }, {
      key: 'getIndexFromXY',
      value: function getIndexFromXY(xval, yval) {
        var useDataToUse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var roundingMethod = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Math.round;
        var scaleX = arguments[4];
        var scaleY = arguments[5];


        var xdata = void 0,
            ydata = void 0;

        if (useDataToUse && this.dataInUse) {

          xdata = this.dataInUse.x;
          ydata = this.dataInUse.y;
        } else if (this.xdata) {

          xdata = this.xdata.data;
          ydata = this.data;
        }

        var position = void 0;

        if (this.isXMonotoneous()) {
          // X lookup only

          if (this.getXMin() > xval || this.getXMax() < xval) {
            return false;
          }

          if (this.hasXWaveform()) {
            // The x value HAS to be rescaled
            position = this.xdata.getIndexFromData(xval, xdata, this.xdata.getMonotoneousAscending(), roundingMethod);
          } else {
            position = Math.max(0, Math.min(this.getLength() - 1, roundingMethod((xval - this.xOffset) / this.xScale)));
          }
        } else if (!isNaN(yval)) {

          position = this.getIndexFromDataXY(xval, xdata, yval, ydata, scaleX, scaleY);
        } else {
          return;
        }

        if (useDataToUse && this.dataInUse && this.dataInUseType == 'aggregateX') {
          // In case of aggregation, round to the closest element of 4.
          return position - position % 4;
        }

        return position;
      }
    }, {
      key: 'getIndexFromDataXY',
      value: function getIndexFromDataXY(valX, dataX, valY, dataY) {
        var scaleX = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
        var scaleY = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;


        var data = void 0,
            position = void 0;

        valX -= this.getXShift();
        valX /= this.getXScale();

        valY -= this.getShift();
        valY /= this.getScale();

        return euclidianSearch(valX, valY, dataX, dataY, scaleX, scaleY);
      }
    }, {
      key: 'getIndexFromData',
      value: function getIndexFromData(val, valCollection, isAscending, roundingMethod) {

        if (!this.isMonotoneous()) {
          console.trace();
          throw 'Impossible to get the index from a non-monotoneous wave !';
        }

        var data = void 0,
            position = void 0;

        val -= this.getShift();
        val /= this.getScale();

        return binarySearch(val, valCollection, !isAscending);
      }
    }, {
      key: 'getReductionType',
      value: function getReductionType() {
        return this.dataInUseType;
      }
    }, {
      key: 'getXMin',
      value: function getXMin() {
        return this.minX * this.getXScale() + this.getXShift();
      }
    }, {
      key: 'getXMax',
      value: function getXMax() {
        return this.maxX * this.getXScale() + this.getXShift();
      }
    }, {
      key: 'getYMin',
      value: function getYMin() {
        return this.minY * this.getScale() + this.getShift();
      }
    }, {
      key: 'getYMax',
      value: function getYMax() {
        return this.maxY * this.getScale() + this.getShift();
      }
    }, {
      key: 'getMin',
      value: function getMin() {
        return this.minY * this.getScale() + this.getShift();
      }
    }, {
      key: 'getMax',
      value: function getMax() {
        return this.maxY * this.getScale() + this.getShift();
      }
    }, {
      key: 'getMinX',
      value: function getMinX() {

        return this.minX * this.getXScale() + this.getXShift();
      }
    }, {
      key: 'getMaxX',
      value: function getMaxX() {
        return this.maxX * this.getXScale() + this.getXShift();
      }
    }, {
      key: 'getMinY',
      value: function getMinY() {
        return this.minY * this.getScale() + this.getShift();
      }
    }, {
      key: 'getMaxY',
      value: function getMaxY() {
        return this.maxY * this.getScale() + this.getShift();
      }
    }, {
      key: 'getDataMaxX',
      value: function getDataMaxX() {
        return this.maxX;
      }
    }, {
      key: 'getDataMinX',
      value: function getDataMinX() {
        return this.minX;
      }
    }, {
      key: 'getDataMaxY',
      value: function getDataMaxY() {
        return this.maxY;
      }
    }, {
      key: 'getDataMaxY',
      value: function getDataMaxY() {
        return this.minY;
      }
    }, {
      key: 'getDataY',
      value: function getDataY() {
        return this.data;
      }
    }, {
      key: 'getData',
      value: function getData(optimized) {
        if (!optimized || !this.dataInUse) {
          return this.data;
        }
        return this.dataInUse.y;
      }
    }, {
      key: 'setShift',
      value: function setShift() {
        var shift = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;


        // We must update the min and the max of the y data
        //this.minY += ( shift - this.getShift() );
        //this.maxY += ( shift - this.getShift() );
        this.shift = shift;
        return this;
      }
    }, {
      key: 'getShift',
      value: function getShift() {
        return this.shift || 0;
      }
    }, {
      key: 'getScale',
      value: function getScale() {
        return this.scale || 1;
      }
    }, {
      key: 'setScale',
      value: function setScale() {
        var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;


        // this.minY = ( this.minY - this.getShift() ) * scale;
        // this.maxY = ( this.maxY - this.getShift() ) * scale;
        this.scale = scale;
        return this;
      }
    }, {
      key: 'setXShift',
      value: function setXShift() {
        var shift = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;


        if (!this.hasXWaveform) {
          return this;
        }

        // We must update the min and the max of the x data
        // That's important for when the data has already been set
        //  this.minX += ( shift - this.getXShift() );
        //    this.maxX += ( shift - this.getXShift() );
        this.getXWaveform().setShift(shift);
        return this;
      }
    }, {
      key: 'getXShift',
      value: function getXShift() {
        var shift = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;


        if (!this.hasXWaveform) {
          return 0;
        }

        return this.getXWaveform().getShift();
      }
    }, {
      key: 'setXScale',
      value: function setXScale() {
        var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;


        if (!this.hasXWaveform) {
          return this;
        }

        this.getXWaveform().setScale(scale);
        return this;
      }
    }, {
      key: 'getXScale',
      value: function getXScale() {

        if (!this.hasXWaveform) {
          return 1;
        }

        return this.getXWaveform().getScale();
      }
    }, {
      key: 'getLength',
      value: function getLength() {
        return this.data.length;
      }
    }, {
      key: 'getDataToUseFlat',
      value: function getDataToUseFlat() {

        var l = void 0;
        var j = 0;
        var arr = void 0;

        if (this.dataInUse) {

          l = this.dataInUse.x.length;
          arr = new Array(l * 2).fill(0);

          for (var i = 0; i < l; i += 1) {
            arr[j] = this.dataInUse.x[i];
            arr[j + 1] = this.dataInUse.y[i];
            j += 2;
          }
        } else {

          l = this.getLength();
          arr = new Array(l * 2).fill(0);
          for (var i = 0; i < l; i += 1) {
            arr[j + 1] = this.data[i];
            arr[j] = this.getX(i);
            j += 2;
          }
        }

        return arr;
      }
    }, {
      key: 'fit',
      value: function fit(options) {

        var self = this;

        return new Promise(function (resolver, rejector) {

          var fit = new _fit_lm2.default(util.extend({}, {

            dataY: self,
            dataX: self.getXWaveform(),
            done: function done(results) {
              resolver(results);
            },
            waveform: new Waveform()

          }, options));

          fit.init();
          fit.fit();
        });
      }
    }, {
      key: 'getX',
      value: function getX(index, optimized) {

        if (optimized && this.dataInUse) {
          return this.dataInUse.x[index] * this.getXScale() + this.getXShift();
        }

        if (this.xdata) {
          return this.xdata.data[index] * this.getXScale() + this.getXShift();
        } else {
          return this.xOffset + index * this.xScale;
        }
      }
    }, {
      key: 'getXRaw',
      value: function getXRaw(index, optimized) {

        if (optimized && this.dataInUse) {
          return this.dataInUse.x[index];
        }

        if (this.xdata) {
          return this.xdata.data[index];
        } else {
          return index;
        }
      }
    }, {
      key: '_integrateP',
      value: function _integrateP() {
        var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - 1;


        from = Math.round(from);
        to = Math.round(to);

        if (from > to) {
          var temp = from;
          from = to;
          to = temp;
        }

        var l = to - from + 1;
        var sum = 0,
            delta;

        var deltaTot = 0;
        var diff = void 0;
        var arrY = this.getData();

        for (; from <= to; from++) {

          if (arrY.length - 1 > from) {
            diff = this.getX(from + 1) - this.getX(from);
            deltaTot += diff;
            sum += arrY[from] * diff;
          }
        }

        return [sum, l, deltaTot];
      }
    }, {
      key: 'integrateP',
      value: function integrateP(from, to) {
        var val = this._integrateP(from, to);
        return val[0];
      }
    }, {
      key: 'integrate',
      value: function integrate(fromX, toX) {
        return this.integrateP(this.getIndexFromX(fromX), this.getIndexFromX(toX));
      }
    }, {
      key: 'average',
      value: function average() {
        var p0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var p1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - 1;

        return this.getAverageP(p0, p1);
      }
    }, {
      key: 'mean',
      value: function mean() {
        return this.average();
      }
    }, {
      key: 'getAverageP',
      value: function getAverageP(from, to) {
        var sum = this._integrateP(from, to);
        return sum[0] / sum[2];
      }
    }, {
      key: 'getAverageX',
      value: function getAverageX(from, to) {
        var sum = this._integrateX(from, to);
        return sum[0] / sum[2];
      }
    }, {
      key: 'checkMonotonicity',
      value: function checkMonotonicity() {

        var i = 1,
            data = this.getData();
        var l = this.data.length;
        var dir = data[1] > data[0];

        for (; i < l; i++) {
          if (data[i] !== data[i - 1] && dir !== data[i] > data[i - 1]) {
            return this._monotoneous = false;
          }
        }

        this._monotoneousAscending = data[1] > data[0];
        return this._monotoneous = true;
      }
    }, {
      key: 'requireXMonotonicity',
      value: function requireXMonotonicity() {
        if (this.xdata) {
          this.xdata.requireMonotonicity();
        }
      }
    }, {
      key: 'requireMonotonicity',
      value: function requireMonotonicity() {
        if (!this.isMonotoneous()) {
          throw 'The wave must be monotonic';
        }
      }
    }, {
      key: 'isMonotoneous',
      value: function isMonotoneous() {
        return !!this._monotoneous;
      }
    }, {
      key: 'isXMonotoneous',
      value: function isXMonotoneous() {
        if (this.xdata) {
          return this.xdata.isMonotoneous();
        }
        // Offset and scale is always monotoneous
        return true;
      }
    }, {
      key: 'invert',
      value: function invert(data) {

        var d = dataY || this.data;
        d.reverse();

        if (this.isMonotoneous()) {
          this._monotoneousAscending = !this._monotoneousAscending;
        }

        return d;
      }
    }, {
      key: 'resampleForDisplay',
      value: function resampleForDisplay(options) {
        // Serie redrawing

        var i = 0;

        this.requireXMonotonicity();

        var inverting = false,
            dataY = this.getDataY(),
            data = {
          x: [],
          y: []
        },
            dataMinMax = [],
            resampleSum = void 0,
            resampleMin = void 0,
            resampleMax = void 0,
            resampleNum = void 0,
            resample_x_start = void 0,
            resample_x_px_start = void 0,
            x_px = void 0,
            doing_mean = false,
            firstPointIndex = 0,
            xval = void 0;

        var l = this.getLength();

        if (!options.xPosition) {
          throw 'No position calculation method provided';
        }

        if (!options.resampleToPx) {
          throw 'No "resampleToPx" method was provided. Unit: px per point';
        }

        if (options.minX > options.maxX) {
          var temp = options.minX;
          options.minX = options.maxX;
          options.maxX = temp;
        }

        if (this.xdata && !this.xdata.getMonotoneousAscending() || !this.xdata && this.xScale < -0) {
          inverting = true;
          i = l;
        }

        for (; inverting ? i > 0 : i < l; inverting ? i-- : i++) {

          xval = this.getX(i);

          if (options.minX > xval) {

            firstPointIndex = i;
            continue;
          }

          x_px = options.xPosition(xval);

          if (!doing_mean) {

            if (!firstPointIndex) {

              firstPointIndex = i;
            } else {

              data.x.push(xval);
              data.y.push(dataY[firstPointIndex]);
            }

            while (isNaN(dataY[i])) {

              if (inverting) {
                i--;
              } else {
                i++;
              }
            }

            resampleSum = resampleMin = resampleMax = dataY[firstPointIndex];
            resampleNum = 1;
            resample_x_px_start = x_px;
            resample_x_start = xval;
            firstPointIndex = 0;

            doing_mean = true;

            continue;
          }

          if (Math.abs(x_px - resample_x_px_start) > options.resampleToPx || i == l || i == 0 || isNaN(dataY[i])) {

            var xpos = (resample_x_start + xval) / 2;

            data.x.push(xpos);
            data.y.push(resampleSum / resampleNum);

            dataMinMax.push(xpos, resampleMin, resampleMax);

            if (options.maxX !== undefined && xval > options.maxX) {

              break;
            }

            doing_mean = false;

            continue;
          }

          resampleSum += dataY[i];
          resampleNum++;

          resampleMin = Math.min(resampleMin, dataY[i]);
          resampleMax = Math.max(resampleMax, dataY[i]);
        }

        this.dataInUseType = 'resampled';
        this.dataInUse = data;
        return dataMinMax;
      }
    }, {
      key: 'interpolate',
      value: function interpolate(x) {

        var yData = this.getDataY();
        var xIndex = void 0;

        if (this.xdata) {

          var xData = this.xdata.getData();

          try {
            xIndex = binarySearch(x, xData, !this.xdata.getMonotoneousAscending());
          } catch (e) {
            return NaN;
          }

          if (xData[xIndex] == x) {
            return yData[xIndex];
          }
          return (x - xData[xIndex]) / (xData[xIndex + 1] - xData[xIndex]) * (yData[xIndex + 1] - yData[xIndex]) + yData[xIndex];
        } else {
          xIndex = (x - this.xOffset) / this.xScale;
          var xIndexF = Math.floor(xIndex);
          return (xIndex - xIndexF) * (yData[xIndexF + 1] - yData[xIndexF]) + yData[xIndexF];
        }
      }
    }, {
      key: 'interpolateIndex_X',
      value: function interpolateIndex_X(index) {

        var yData = this.getDataY();
        if (this.xdata) {
          var xData = this.xdata.getData();
          var indexStart = Math.floor(index);

          return (index - indexStart) * (xData[indexStart + 1] - xData[indexStart]) + xData[indexStart];
        }
      }
    }, {
      key: 'getMonotoneousAscending',
      value: function getMonotoneousAscending() {

        if (!this.isMonotoneous()) {
          return 'The waveform is not monotoneous';
        }

        return this._monotoneousAscending;
      }
    }, {
      key: 'getXMonotoneousAscending',
      value: function getXMonotoneousAscending() {
        if (this.xdata) {
          return this.xdata.getMonotoneousAscending();
        }

        return this.xScale > 0;
      }
    }, {
      key: 'isXMonotoneousAscending',
      value: function isXMonotoneousAscending() {
        return this.getXMonotoneousAscending.apply(this, arguments);
      }
    }, {
      key: 'divide',
      value: function divide(numberOrWave) {
        return this._arithmetic(numberOrWave, DIVIDE);
      }
    }, {
      key: 'divideBy',
      value: function divideBy() {
        return this.divide.apply(this, arguments);
      }
    }, {
      key: 'multiply',
      value: function multiply(numberOrWave) {
        return this._arithmetic(numberOrWave, MULTIPLY);
      }
    }, {
      key: 'multiplyBy',
      value: function multiplyBy() {
        return this.multiply.apply(this, arguments);
      }
    }, {
      key: 'log',
      value: function log() {
        return this.logBase(10);
      }
    }, {
      key: 'ln',
      value: function ln() {
        return this.logBase(Math.E);
      }
    }, {
      key: 'logBase',
      value: function logBase(base) {

        var logBase = Math.log(base);
        this.data.map(function (valY) {

          return Math.log(valY) / logBase;
        });
      }
    }, {
      key: 'add',
      value: function add(numberOrWave) {
        return this._arithmetic(numberOrWave, ADD);
      }
    }, {
      key: 'addBy',
      value: function addBy() {
        return this.add.apply(this, arguments);
      }
    }, {
      key: 'subtract',
      value: function subtract(numberOrWave) {
        return this._arithmetic(numberOrWave, SUBTRACT);
      }
    }, {
      key: 'subtractBy',
      value: function subtractBy() {
        return this.subtract.apply(this, arguments);
      }
    }, {
      key: 'math',
      value: function math(method) {

        for (var i = 0; i < this.getLength(); i++) {
          this.data[i] = method(this.getY(i), this.getX(i));
        }

        this._setData(this.data);
        return this;
      }
    }, {
      key: '_arithmetic',
      value: function _arithmetic(numberOrWave, operator) {

        if (numberOrWave instanceof Waveform) {
          return this._waveArithmetic(numberOrWave, operator);
        } else if (typeof numberOrWave == 'number') {

          return this._numberArithmetic(numberOrWave, operator);
        }
      }
    }, {
      key: '_numberArithmetic',
      value: function _numberArithmetic(num, operation) {

        var i = 0,
            l = this.getLength();

        if (operation == MULTIPLY) {

          for (; i < l; i++) {
            this.data[i] *= num;
          }

          this.minY *= num;
          this.maxY *= num;
        } else if (operation == DIVIDE) {

          for (; i < l; i++) {
            this.data[i] /= num;
          }

          this.minY /= num;
          this.maxY /= num;
        } else if (operation == ADD) {

          for (; i < l; i++) {
            this.data[i] += num;
          }

          this.minY += num;
          this.maxY += num;
        } else if (operation == SUBTRACT) {

          for (; i < l; i++) {
            this.data[i] -= num;
          }

          this.minY -= num;
          this.maxY -= num;
        }

        return this;
      }
    }, {
      key: '_waveArithmetic',
      value: function _waveArithmetic(wave, operation) {

        var yDataThis = this.getDataY(),
            i = 0;
        var l = this.getLength();
        this.requireXMonotonicity();
        wave.requireXMonotonicity();

        if (operation == MULTIPLY) {

          for (; i < l; i++) {
            yDataThis[i] *= wave.interpolate(this.getX(i));
          }
        } else if (operation == DIVIDE) {

          for (; i < l; i++) {
            yDataThis[i] /= wave.interpolate(this.getX(i));
          }
        } else if (operation == ADD) {

          for (; i < l; i++) {
            yDataThis[i] += wave.interpolate(this.getX(i));
          }
        } else if (operation == SUBTRACT) {

          for (; i < l; i++) {
            yDataThis[i] -= wave.interpolate(this.getX(i));
          }
        }

        this._setData(yDataThis);
        return this;
      }
    }, {
      key: 'aggregate',
      value: function aggregate() {
        var _this = this;

        var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'x';


        this._dataAggregating = {};
        this._dataAggregated = {};
        this._dataAggregationDirection = direction.toUpperCase();

        var pow2 = pow2floor(this.getLength());

        this._dataAggregating = aggregator({

          minX: this.minX,
          maxX: this.maxX,
          minY: this.minY,
          maxY: this.maxY,
          data: this.data,
          xdata: this.xdata ? this.xdata.getData() : undefined,
          xScale: this.xScale,
          xOffset: this.xOffset,
          numPoints: pow2,
          direction: direction

        }).then(function (event) {

          _this._dataAggregated = event.aggregates;
          _this._dataAggregating = false;
        });
      }
    }, {
      key: 'hasAggregation',
      value: function hasAggregation() {
        return !!this._dataAggregated;
      }
    }, {
      key: 'selectAggregatedData',
      value: function selectAggregatedData(pxWidth) {

        if (pxWidth < 2) {
          return false;
        }
        /*
        console.log( direction, this._dataAggregationDirection );
             if( direction !== this._dataAggregationDirection ) {
              throw "The data is not aggregated in that direction";
            }
        */

        var level = pow2ceil(pxWidth);

        if (this._dataAggregated[level]) {

          this.dataInUseType = 'aggregate' + this._dataAggregationDirection;
          this.dataInUse = this._dataAggregated[level];
          return;
        } else if (this._dataAggregating) {

          return this._dataAggregating;
        }

        this.dataInUseType = 'none';
        this.dataInUse = {
          y: this.data,
          x: this.getXWaveform().data
        };
      }
    }, {
      key: 'duplicate',
      value: function duplicate(alsoDuplicateXWave) {
        var newWaveform = new Waveform();
        newWaveform._setData(this.getDataY().slice());
        newWaveform.rescaleX(this.xOffset, this.xShift);
        newWaveform.setShift(this.getShift());
        newWaveform.setScale(this.getScale());

        if (this.xdata) {
          if (alsoDuplicateXWave) {
            newWaveform.setXWaveform(this.xdata.duplicate());
          } else {
            newWaveform.setXWaveform(this.xdata);
          }

          newWaveform.setXShift(this.getXShift());
          newWaveform.setXScale(this.getXScale());
        } else {
          newWaveform.xOffset = this.xOffset;
          newWaveform.xScale = this.xScale;
        }

        return newWaveform;
      }
    }, {
      key: 'subrangeX',
      value: function subrangeX(fromX, toX) {

        if (!this.xdata) {
          // We can select the new range from there

          var fromP = this.getIndexFromX(fromX),
              toP = this.getIndexFromX(toP);

          return new Waveform().setData(this.data.slice(fromP, toP)).rescaleX(this.xOffset, this.xScale);
        } else {

          var waveform = new Waveform();

          for (var i = 0, l = this.data.length; i < l; i++) {

            if (this.data[i] >= fromX && this.data[i] < toX) {

              waveform.append(this.dataX[i], this.data[i]);
            }
          }

          return waveform;
        }
      }
    }, {
      key: 'findLocalMinMax',
      value: function findLocalMinMax(xRef, xWithin, type) {

        var index = this.getIndexFromX(xRef),
            indexPlus = this.getIndexFromX(xRef + xWithin),
            indexMinus = this.getIndexFromX(xRef - xWithin);

        return this.findLocalMinMaxIndex(indexMinus, indexPlus, type);
      }
    }, {
      key: 'findLocalMinMaxIndex',
      value: function findLocalMinMaxIndex(indexMinus, indexPlus, type) {

        var tmp = void 0;

        if (indexPlus < indexMinus) {
          tmp = indexPlus;
          indexPlus = indexMinus;
          indexMinus = tmp;
        }

        var curr = void 0,
            currI = void 0;

        if (type == 'max') {

          curr = Number.NEGATIVE_INFINITY;

          for (var i = indexMinus; i <= indexPlus; i++) {

            if (this.getY(i) > curr) {
              curr = this.getY(i);
              currI = i;
            }
          }
        } else {

          curr = Number.POSITIVE_INFINITY;

          for (var i = indexMinus; i <= indexPlus; i++) {

            if (this.getY(i) < curr) {
              curr = this.getY(i);
              currI = i;
            }
          }
        }

        if (currI == indexMinus || currI == indexPlus) {
          return false;
        }

        return this.getX(currI);
      }
    }, {
      key: 'warn',
      value: function warn(text) {
        if (console) {
          console.warn(text);
        }
      }
    }, {
      key: 'setUnit',
      value: function setUnit(unit) {
        this.unit = unit;
        return this;
      }
    }, {
      key: 'setXUnit',
      value: function setXUnit(unit) {
        if (this.hasXWaveform()) {
          this.xdata.setUnit(unit);
        }

        this.xunit = unit;
        return this;
      }
    }, {
      key: 'getUnit',
      value: function getUnit() {
        return this.unit || '';
      }
    }, {
      key: 'getXUnit',
      value: function getXUnit() {
        if (this.hasXWaveform()) {
          return this.xdata.getUnit();
        }

        return this.xunit | '';
      }
    }, {
      key: 'hasXUnit',
      value: function hasXUnit() {
        return this.getXUnit().length > 0;
      }
    }, {
      key: 'hasUnit',
      value: function hasUnit() {
        return this.getUnit().length > 0;
      }
    }, {
      key: 'findLevels',
      value: function findLevels(level, options) {

        options = util.extend({

          box: 1,
          edge: 'both',
          rounding: 'before',
          rangeP: [0, this.getLength()]

        }, options);

        var lastLvlIndex = options.rangeP[0];
        var lvlIndex;
        var indices = [];
        var i = 0;

        while (lvlIndex = this.findLevel(level, util.extend(true, {}, options, {
          rangeP: [lastLvlIndex, options.rangeP[1]]
        }))) {
          indices.push(lvlIndex);
          lastLvlIndex = Math.ceil(lvlIndex);

          i++;
          if (i > 1000) {
            return;
          }
        }

        return indices;
      }
    }, {
      key: 'findLevel',
      value: function findLevel(level, options) {

        options = util.extend({

          box: 1,
          edge: 'both',
          direction: 'ascending',
          rounding: 'before',
          rangeP: [0, this.getLength()]

        }, options);

        if (options.rangeX) {
          options.rangeP = options.rangeX.map(this.getIndexFromX);
        }

        var value, below, i, j, l, increment;

        var box = options.box;

        if (box % 2 == 0) {
          box++;
        }

        if (options.direction == 'descending') {
          i = options.rangeP[1], l = options.rangeP[0], increment = -1;
        } else {
          i = options.rangeP[0], l = options.rangeP[1], increment = +1;
        }

        for (;; i += increment) {

          if (options.direction == 'descending') {
            if (i < l) {
              break;
            }
          } else {
            if (i > l) {
              break;
            }
          }

          if (i < options.rangeP[0] + (box - 1) / 2) {
            continue;
          }

          if (i > options.rangeP[1] - (box - 1) / 2) {
            break;
          }

          value = this.getAverageP(i - (box - 1) / 2, i + (box - 1) / 2);

          if (below === undefined) {
            below = value < level;
            continue;
          }
          // Crossing up
          if (value >= level && below) {

            below = false;

            if (options.edge == 'ascending' || options.edge == 'both') {
              // Found something

              for (j = i + (box - 1) / 2; j >= i - (box - 1) / 2; j--) {

                if (this.data[j] >= level && this.data[j - 1] <= level) {
                  // Find a crossing

                  switch (options.rounding) {
                    case 'before':
                      return j - 1;
                      break;

                    case 'after':
                      return j;
                      break;

                    case 'interpolate':
                      return getIndexInterpolate(level, this.data[j], this.data[j - 1], j, j - 1);
                      break;
                  }
                }
              }
            }
          } else if (value <= level && !below) {

            below = true;

            if (options.edge == 'descending' || options.edge == 'both') {

              for (j = i + (box - 1) / 2; j >= i - (box - 1) / 2; j--) {

                if (this.data[j] <= level && this.data[j - 1] >= level) {
                  // Find a crossing

                  switch (options.rounding) {
                    case 'before':
                      return j - 1;
                      break;

                    case 'after':
                      return j;
                      break;

                    case 'interpolate':
                      return getIndexInterpolate(level, this.data[j], this.data[j - 1], j, j - 1);
                      break;
                  }
                }
              }
            }
          }
        }
      }
    }, {
      key: 'normalize',
      value: function normalize(mode) {

        var factor = void 0,
            total = void 0,
            minValue = void 0,
            maxValue = void 0,
            ratio = void 0,
            i = void 0;

        if (mode == 'max1' || mode == 'max100') {

          factor = 1;

          if (mode == 'max100') {
            factor = 100;
          }

          maxValue = this.data[0];

          for (i = 1; i < this.getLength(); i++) {

            if (this.data[i] > maxValue) {

              maxValue = this.data[i];
            }
          }

          for (i = 0; i < this.getLength(); i++) {

            this.data[i] /= maxValue / factor;
          }
        } else if (mode == 'sum1') {

          total = 0;

          for (i = 0; i < this.getLength(); i++) {
            total += this.data[i];
          }

          for (i = 0; i < this.getLength(); i++) {

            this.data[i] /= total;
          }
        } else if (mode == 'max1min0') {

          maxValue = this.data[0], minValue = this.data[0];

          for (i = 1; i < this.getLength(); i++) {
            if (this.data[i] > maxValue) {

              maxValue = this.data[i];
            } else if (this.data[i] < minValue) {

              minValue = this.data[i];
            }
          }

          ratio = 1 / (maxValue - minValue);

          for (i = 0; i < this.getLength(); i++) {

            this.data[i] = (this.data[i] - minValue) * ratio;
          }
        }

        this.setData(this.data);
      }
    }, {
      key: 'setErrorBarX',
      value: function setErrorBarX(waveform) {

        if (Array.isArray(waveform)) {
          waveform = new Waveform(waveform);
        }

        var xWave = this.getXWaveform();
        xWave.setErrorBar(waveform);
        return this;
      }
    }, {
      key: 'setErrorBarXBelow',
      value: function setErrorBarXBelow(waveform) {

        if (Array.isArray(waveform)) {
          waveform = new Waveform(waveform);
        }

        var xWave = this.getXWaveform();
        xWave.setErrorBarBelow(waveform);
        return this;
      }
    }, {
      key: 'setErrorBarXAbove',
      value: function setErrorBarXAbove(waveform) {

        if (Array.isArray(waveform)) {
          waveform = new Waveform(waveform);
        }

        var xWave = this.getXWaveform();
        xWave.setErrorBarAbove(waveform);
        return this;
      }
    }, {
      key: 'setErrorBoxX',
      value: function setErrorBoxX(waveform) {

        if (Array.isArray(waveform)) {
          waveform = new Waveform(waveform);
        }

        var xWave = this.getXWaveform();
        xWave.setErrorBoxAbove(waveform);
        xWave.setErrorBoxBelow(waveform);
        return this;
      }
    }, {
      key: 'setErrorBoxXBelow',
      value: function setErrorBoxXBelow(waveform) {

        if (Array.isArray(waveform)) {
          waveform = new Waveform(waveform);
        }

        var xWave = this.getXWaveform();

        xWave.setErrorBoxBelow(waveform);
        return this;
      }
    }, {
      key: 'setErrorBoxXAbove',
      value: function setErrorBoxXAbove(waveform) {

        if (Array.isArray(waveform)) {
          waveform = new Waveform(waveform);
        }

        var xWave = this.getXWaveform();
        xWave.setErrorBoxAbove(waveform);
        return this;
      }
    }, {
      key: 'setErrorBar',
      value: function setErrorBar(waveform) {
        var checkMinMax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;


        if (Array.isArray(waveform)) {
          waveform = new Waveform(waveform);
        }
        this.errors.nb++;
        this.errors.nb++;
        this.errors.bars.bottom = waveform;
        this.errors.bars.top = waveform;

        if (checkMinMax) {
          this._setData();
        }
      }
    }, {
      key: 'setErrorBarBelow',
      value: function setErrorBarBelow(waveform) {
        var checkMinMax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;


        if (Array.isArray(waveform)) {
          waveform = new Waveform(waveform);
        }
        this.errors.nb++;
        this.errors.bars.below = waveform;

        if (checkMinMax) {
          this._setData();
        }
      }
    }, {
      key: 'setErrorBarAbove',
      value: function setErrorBarAbove(waveform) {
        var checkMinMax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;


        if (Array.isArray(waveform)) {
          waveform = new Waveform(waveform);
        }

        this.errors.nb++;
        this.errors.bars.above = waveform;

        if (checkMinMax) {
          this._setData();
        }
      }
    }, {
      key: 'setErrorBox',
      value: function setErrorBox(waveform) {
        var checkMinMax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;


        if (Array.isArray(waveform)) {
          waveform = new Waveform(waveform);
        }
        this.errors.nb++;
        this.errors.nb++;
        this.errors.boxes.above = waveform;
        this.errors.boxes.below = waveform;

        if (checkMinMax) {
          this._setData();
        }
      }
    }, {
      key: 'setErrorBoxBelow',
      value: function setErrorBoxBelow(waveform) {
        var checkMinMax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;


        if (Array.isArray(waveform)) {
          waveform = new Waveform(waveform);
        }
        this.errors.nb++;
        this.errors.boxes.below = waveform;

        if (checkMinMax) {
          this._setData();
        }
      }
    }, {
      key: 'setErrorBoxAbove',
      value: function setErrorBoxAbove(waveform) {
        var checkMinMax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;


        if (Array.isArray(waveform)) {
          waveform = new Waveform(waveform);
        }

        this.errors.boxes.above = waveform;
        if (checkMinMax) {
          this._setData();
        }
      }
    }, {
      key: 'getMaxError',
      value: function getMaxError(i) {
        var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Waveform.ABOVE;


        return Math.max(this.getMaxErrorType(i, side, Waveform.BOX), this.getMaxErrorType(i, side, Waveform.BAR));
      }
    }, {
      key: 'getMaxErrorType',
      value: function getMaxErrorType(i) {
        var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Waveform.ABOVE;
        var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Waveform.BOX;


        var stack = void 0;
        if (type == Waveform.BOX) {
          stack = this.errors.boxes;
        } else if (type == Waveform.BAR) {
          stack = this.errors.bars;
        } else {
          throw 'Unknown type of error';
        }

        var waveform = void 0;
        if (!(waveform = stack[side])) {
          if (side == Waveform.ABOVE) {
            if (stack[side] == Waveform.BELOW) {
              waveform = stack.below;
            }
          } else {
            if (stack[side] == Waveform.ABOVE) {
              waveform = stack.above;
            }
          }
        }

        if (!waveform) {
          return 0;
        }

        return waveform.getY(i);
      }
    }, {
      key: 'getErrorBarXBelow',
      value: function getErrorBarXBelow(index) {
        return this.getErrorX(index, Waveform.BELOW, Waveform.BAR);
      }
    }, {
      key: 'getErrorBarXAbove',
      value: function getErrorBarXAbove(index) {
        return this.getErrorX(index, Waveform.ABOVE, Waveform.BAR);
      }
    }, {
      key: 'getErrorBoxXBelow',
      value: function getErrorBoxXBelow(index) {
        return this.getErrorX(index, Waveform.BELOW, Waveform.BOX);
      }
    }, {
      key: 'getErrorBoxXAbove',
      value: function getErrorBoxXAbove(index) {
        return this.getErrorX(index, Waveform.ABOVE, Waveform.BOX);
      }
    }, {
      key: 'getErrorBarYBelow',
      value: function getErrorBarYBelow(index) {
        return this.getError(index, Waveform.BELOW, Waveform.BAR);
      }
    }, {
      key: 'getErrorBarYAbove',
      value: function getErrorBarYAbove(index) {
        return this.getError(index, Waveform.ABOVE, Waveform.BAR);
      }
    }, {
      key: 'getErrorBoxYBelow',
      value: function getErrorBoxYBelow(index) {
        return this.getError(index, Waveform.BELOW, Waveform.BOX);
      }
    }, {
      key: 'getErrorBoxYAbove',
      value: function getErrorBoxYAbove(index) {
        return this.getError(index, Waveform.ABOVE, Waveform.BOX);
      }
    }, {
      key: 'getErrorX',
      value: function getErrorX(index) {
        var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Waveform.ABOVE;
        var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Waveform.BAR;


        if (!this.hasXWaveform()) {
          return false;
        }

        return this.xdata.getError(index, side, type);
      }
    }, {
      key: 'getError',
      value: function getError(index) {
        var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Waveform.ABOVE;
        var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Waveform.BAR;


        var errors = type == Waveform.BAR ? this.errors.bars : this.errors.boxes;

        if (!errors) {
          return false;
        }

        var wave = void 0;
        if (wave = side == Waveform.ABOVE ? errors.above : errors.below) {

          if (wave == Waveform.ABOVE && side == Waveform.BELOW) {
            wave = errors.above;
          } else if (wave == Waveform.BELOW && side == Waveform.ABOVE) {
            wave = errors.below;
          }

          if (!wave) {
            return false;
          }

          return wave.getY(index);
        }
      }
    }, {
      key: 'hasErrorBars',
      value: function hasErrorBars() {

        return this.errors.nb > 0 || this.hasXWaveform() && this.xdata.errors.nb > 0;
      }
    }]);

    return Waveform;
  }();

  Waveform.BELOW = Symbol();
  Waveform.ABOVE = Symbol();

  Waveform.BOX = Symbol();
  Waveform.BAR = Symbol();

  var MULTIPLY = Symbol();
  var ADD = Symbol();
  var SUBTRACT = Symbol();
  var DIVIDE = Symbol();

  // http://stackoverflow.com/questions/26965171/fast-nearest-power-of-2-in-javascript
  function pow2ceil(v) {
    v--;
    var p = 2;
    while (v >>= 1) {
      p <<= 1;
    }
    return p;
  }

  function pow2floor(v) {

    var p = 1;

    while (v >>= 1) {
      p <<= 1;
    }
    return p;
  }

  function getIndexInterpolate(value, valueBefore, valueAfter, indexBefore, indexAfter) {
    return (value - valueBefore) / (valueAfter - valueBefore) * (indexAfter - indexBefore) + indexBefore;
  }

  function euclidianSearch(targetX, targetY, haystackX, haystackY) {
    var scaleX = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
    var scaleY = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;


    var distance = Number.MAX_VALUE,
        distance_i = void 0;

    var index = -1;

    for (var i = 0, l = haystackX.length; i < l; i++) {

      distance_i = Math.pow((targetX - haystackX[i]) * scaleX, 2) + Math.pow((targetY - haystackY[i]) * scaleY, 2);

      if (distance_i < distance) {

        index = i;
        distance = distance_i;
      }
    }

    return index;
  }

  function binarySearch(target, haystack) {
    var reverse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : haystack[haystack.length - 1] < haystack[0];


    var seedA = 0,
        length = haystack.length,
        seedB = length - 1,
        seedInt = void 0,
        i = 0,
        nanDirection = 1;

    if (!reverse && (haystack[0] > target || haystack[seedB] < target) || reverse && (haystack[0] < target || haystack[seedB] > target)) {
      throw new Error('Target ' + target + ' is not in the stack');
    }

    if (haystack[seedA] == target) {
      return seedA;
    }

    if (haystack[seedB] == target) {
      return seedB;
    }

    while (true) {
      i++;
      if (i > 100) {
        throw new Error('Error loop');
      }

      seedInt = Math.floor((seedA + seedB) / 2);

      //  seedInt -= seedInt % 2; // Always looks for an x.

      while (isNaN(haystack[seedInt])) {

        if (seedInt >= haystack.length - 1) {

          return haystack.length - 1;
        } else if (seedInt <= 0) {

          return 0;
        }

        seedInt += nanDirection;
      }

      if (seedInt == seedA || haystack[seedInt] == target || seedInt == seedB) {
        return seedInt;
      }

      //    console.log(seedA, seedB, seedInt, haystack[seedInt]);
      if (haystack[seedInt] < target) {
        if (reverse) {
          seedB = seedInt;
        } else {
          seedA = seedInt;
        }
      } else if (haystack[seedInt] > target) {
        if (reverse) {
          seedA = seedInt;
        } else {
          seedB = seedInt;
        }
      } else {
        return false;
      }

      nanDirection *= -1;
    }
  }

  exports.default = Waveform;
  module.exports = exports['default'];
});

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(8).f;
var has = __webpack_require__(15);
var TAG = __webpack_require__(6)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var defined = __webpack_require__(24);
var fails = __webpack_require__(3);
var spaces = __webpack_require__(81);
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;


/***/ }),
/* 49 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4);
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(45), __webpack_require__(5), __webpack_require__(74), __webpack_require__(46), __webpack_require__(57)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('../graph.core.js'), require('../graph.util.js'), require('../mixins/graph.mixin.errorbars.js'), require('../util/waveform.js'), require('./graph.serie.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphCore, global.graphUtil, global.graphMixinErrorbars, global.waveform, global.graphSerie);
    global.graphSerieLine = mod.exports;
  }
})(this, function (module, exports, _graphCore, _graphUtil, _graphMixinErrorbars, _waveform, _graphSerie) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _graphCore2 = _interopRequireDefault(_graphCore);

  var util = _interopRequireWildcard(_graphUtil);

  var _graphMixinErrorbars2 = _interopRequireDefault(_graphMixinErrorbars);

  var _waveform2 = _interopRequireDefault(_waveform);

  var _graphSerie2 = _interopRequireDefault(_graphSerie);

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var SerieLine = function (_Serie) {
    _inherits(SerieLine, _Serie);

    _createClass(SerieLine, null, [{
      key: 'default',
      value: function _default() {
        /**
         * @name SerieLineDefaultOptions
         * @object
         * @static
         * @memberof SerieLine
         */
        return {

          lineColor: 'black',
          lineStyle: 1,
          flip: false,
          label: '',
          lineWidth: 1,
          markers: false,
          trackMouse: false,
          trackMouseLabel: false,
          trackMouseLabelRouding: 1,
          lineToZero: false,
          selectableOnClick: false,
          markersIndependant: false,
          overflowX: false,
          overflowY: false
        };
      }
    }]);

    function SerieLine(graph, name, options) {
      _classCallCheck(this, SerieLine);

      var _this = _possibleConstructorReturn(this, (SerieLine.__proto__ || Object.getPrototypeOf(SerieLine)).apply(this, arguments));

      _this.selectionType = 'unselected';
      _this.markerFamilies = {};

      util.mapEventEmission(_this.options, _this); // Register events

      // Creates an empty style variable
      _this.styles = {};

      // Unselected style
      _this.styles.unselected = {
        lineColor: _this.options.lineColor,
        lineStyle: _this.options.lineStyle,
        lineWidth: _this.options.lineWidth,
        markers: _this.options.markers
      };

      _this.styles.selected = {
        lineWidth: 3
      };

      _this.markersDom = new Map();

      _this.shown = true;

      _this.data = [];
      _this._isMinOrMax = {
        x: {
          min: false,
          max: false
        },
        y: {
          min: false,
          max: false
        }
      };

      // Optimize is no markerPoints => save loops
      //      this.markerPoints = {};

      _this.groupLines = document.createElementNS(_this.graph.ns, 'g');
      _this.domMarker = document.createElementNS(_this.graph.ns, 'path');

      if (!_this.domMarker.style) {
        _this.domMarker.style = {
          cursor: 'pointer'
        };
      } else {
        _this.domMarker.style.cursor = 'pointer';
      }

      _this.groupMain = document.createElementNS(_this.graph.ns, 'g');
      _this.additionalData = {};

      _this.marker = document.createElementNS(_this.graph.ns, 'circle');
      _this.marker.setAttribute('fill', 'black');
      _this.marker.setAttribute('r', 3);
      _this.marker.setAttribute('display', 'none');

      _this.markerLabel = document.createElementNS(_this.graph.ns, 'text');
      _this.markerLabelSquare = document.createElementNS(_this.graph.ns, 'rect');
      _this.markerLabelSquare.setAttribute('fill', 'white');
      _this.domMarkerHover = {};
      _this.domMarkerSelect = {};
      _this.markerHovered = 0;
      _this.groupMarkerSelected = document.createElementNS(_this.graph.ns, 'g');

      _this.markerPoints = {};

      //this.scale = 1;
      //this.shift = 0;
      _this.lines = [];

      _this.groupMain.appendChild(_this.groupLines);

      _this.groupMain.appendChild(_this.marker);

      _this.groupMain.appendChild(_this.groupMarkerSelected);
      _this.groupMain.appendChild(_this.markerLabelSquare);
      _this.groupMain.appendChild(_this.markerLabel);

      _this.groupMarkers = document.createElementNS(_this.graph.ns, 'g');
      _this.groupMain.appendChild(_this.groupMarkers);

      _this.independantMarkers = [];

      if (_this.initExtended1) {
        _this.initExtended1();
      }

      _this.groupLines.addEventListener('click', function (e) {

        if (_this.options.selectableOnClick) {

          if (_this.isSelected()) {

            _this.graph.unselectSerie(_this);
          } else {
            _this.graph.selectSerie(_this);
          }
        }
      });

      if (_this.options.markers) {
        _this.setMarkers(_this.options.markers, 'unselected');
      }

      return _this;
    }

    _createClass(SerieLine, [{
      key: 'postInit',
      value: function postInit() {
        this.extendStyles();
      }
    }, {
      key: 'setOptions',
      value: function setOptions(options) {
        this.options = util.extend(true, {}, SerieLine.prototype.defaults, options || {});
        // Unselected style
        this.styles.unselected = {
          lineColor: this.options.lineColor,
          lineStyle: this.options.lineStyle,
          markers: this.options.markers
        };

        this.applyLineStyles();
        return this;
      }
    }, {
      key: 'onMouseOverMarker',
      value: function onMouseOverMarker(e, index) {

        var toggledOn = this.toggleMarker(index, true, true);

        if (this.options.onMouseOverMarker) {

          this.options.onMouseOverMarker(index, this.infos ? this.infos[index] || false : false, [this.waveform.getX(index), this.waveform.getY(index)]);
        }
      }
    }, {
      key: 'onMouseOutMarker',
      value: function onMouseOutMarker(e, index) {
        this.markersOffHover();

        if (this.options.onMouseOutMarker) {
          this.options.onMouseOutMarker(index, this.infos ? this.infos[index] || false : false, [this.waveform.getX(index), this.waveform.getY(index)]);
        }
      }
    }, {
      key: 'toggleMarker',
      value: function toggleMarker(index, force, hover) {

        var i = index;

        var _on;
        if (typeof force === 'undefined') {
          _on = !hover ? !this.domMarkerSelect[index] : !this.domMarkerHover[index];
        }
        var el = this['domMarker' + (hover ? 'Hover' : 'Select')];

        if (_on || force === true) {

          if (!el[index]) {

            var dom = document.createElementNS(this.graph.ns, 'path');

            this.setMarkerStyleTo(dom, this.markerFamilies[this.selectionType][this.getMarkerCurrentFamily(i)]);
            this['domMarker' + (hover ? 'Hover' : 'Select')][index] = dom;
            this.groupMarkerSelected.appendChild(dom);
          } else {
            dom = el[index];
          }

          var x = this.getX(this.waveform.getX(i)),
              y = this.getY(this.waveform.getY(i));

          dom.setAttribute('d', 'M ' + x + ' ' + y + ' ' + this.getMarkerPath(this.markerFamilies[this.selectionType][this.getMarkerCurrentFamily(i)], 1));

          if (hover) {
            this.markerHovered++;
          }
        } else if (!_on || force === false) {

          if (hover && this.domMarkerHover[index] && !this.domMarkerSelect[index] || this.domMarkerSelect[index]) {

            if (!el[index]) {
              return;
            }

            this.groupMarkerSelected.removeChild(el[index]);

            delete el[index];

            if (hover) this.markerHovered--;
          }
        }

        return _on;
      }
    }, {
      key: 'markersOffHover',
      value: function markersOffHover() {

        for (var i in this.domMarkerHover) {
          this.toggleMarker(i.split(','), false, true);
        }
        return this;
      }
    }, {
      key: 'markersOffSelect',
      value: function markersOffSelect() {

        for (var i in this.domMarkerSelect) {
          this.toggleMarker(i.split(','), false, false);
        }
        return this;
      }
    }, {
      key: 'onClickOnMarker',
      value: function onClickOnMarker(e, index) {

        var toggledOn = this.toggleMarker(index);

        if (toggledOn && this.options.onSelectMarker) {
          this.options.onSelectMarker(index, this.infos ? this.infos[index[0]] || false : false);
        }

        if (!toggledOn && this.options.onUnselectMarker) {
          this.options.onUnselectMarker(index, this.infos ? this.infos[index[0]] || false : false);
        }

        if (this.options.onToggleMarker) {
          this.options.onToggleMarker(index, this.infos ? this.infos[index[0]] || false : false, toggledOn);
        }
      }
    }, {
      key: '_getMarkerIndexFromEvent',
      value: function _getMarkerIndexFromEvent(e) {
        var px = this.graph._getXY(e);

        //  return this.searchIndexByPxXY( ( px.x ), ( px.y ) );
        return this.searchIndexByPxXY(px.x - this.graph.getPaddingLeft(), px.y - this.graph.getPaddingTop());
      }
    }, {
      key: 'onMouseWheel',
      value: function onMouseWheel() {}
    }, {
      key: 'empty',
      value: function empty() {

        for (var i = 0, l = this.lines.length; i < l; i++) {
          this.groupLines.removeChild(this.lines[i]);
        }
        this.lines = [];

        return this;
      }
    }, {
      key: 'select',
      value: function select(selectionType) {

        selectionType = selectionType || 'selected';

        this.selected = selectionType !== 'unselected';

        if (this.areMarkersShown() || this.areMarkersShown(selectionType)) {
          this.selectionType = selectionType;

          this.draw(true); // Drawing is absolutely required here
          this.applyLineStyles();
        } else {
          this.selectionType = selectionType;
          this.applyLineStyles();
        }

        this.applyLineStyle(this.getSymbolForLegend());
        return this;
      }
    }, {
      key: 'unselect',
      value: function unselect() {

        this.selected = false;

        return this.select('unselected');
      }
    }, {
      key: 'degrade',
      value: function degrade(pxPerP) {

        this.degradationPx = pxPerP;
        return this;
      }
    }, {
      key: 'drawInit',
      value: function drawInit(force) {
        var _this2 = this;

        var data, xData;

        try {
          this.axisCheck();
        } catch (e) {
          console.warn(e);
          return false;
        }

        this.currentLineId = 0;
        this.counter = 0;
        this._drawn = true;
        this.currentLine = '';

        // Degradation

        if (this.waveform) {

          if (this.degradationPx) {

            this.waveform.resampleForDisplay({

              resampleToPx: this.degradationPx,
              xPosition: this.getXAxis().getPx.bind(this.getXAxis()),
              minX: this.getXAxis().getCurrentMin(),
              maxX: this.getXAxis().getCurrentMax()

            });

            this._dataToUse = [this.waveform.getDataToUseFlat()];
          } else if (this.waveform.hasAggregation()) {

            var xaxis = this.getXAxis(),
                numberOfPointsInTotal = this.graph.getDrawingWidth() * (xaxis.getDataMax() - xaxis.getDataMin()) / (xaxis.getCurrentMax() - xaxis.getCurrentMin()),
                promise = this.waveform.selectAggregatedData(numberOfPointsInTotal);

            if (promise instanceof Promise) {

              promise.then(function () {

                _this2.draw(force);
              });

              return false;
            } else if (promise === false) {

              return false;
            } else {

              this._dataToUse = this.waveform.getDataToUseFlat();
            }
          }

          //    this._dataToUse = this.waveform.getDataToUseFlat();
        } else {

          this._dataToUse = this.data;
          this._xDataToUse = this.xData;
        }

        return true;
      }
    }, {
      key: 'removeLinesGroup',
      value: function removeLinesGroup() {
        this._afterLinesGroup = this.groupLines.nextSibling;
        this.groupMain.removeChild(this.groupLines);
      }
    }, {
      key: 'insertLinesGroup',
      value: function insertLinesGroup() {

        if (!this._afterLinesGroup) {
          throw 'Could not find group after lines to insertion.';
        }

        this.groupMain.insertBefore(this.groupLines, this._afterLinesGroup);
        this._afterLinesGroup = false;
      }
    }, {
      key: 'removeExtraLines',
      value: function removeExtraLines() {

        var i = this.currentLineId,
            l = this.lines.length;

        for (; i < l; i++) {
          this.groupLines.removeChild(this.lines[i]);
        }

        this.lines.splice(this.currentLineId, l - this.currentLineId);
        this.currentLineId = 0;
      }
    }, {
      key: 'draw',
      value: function draw(force) {
        // Serie redrawing

        _get(SerieLine.prototype.__proto__ || Object.getPrototypeOf(SerieLine.prototype), 'draw', this).apply(this, arguments);

        if (!this.getXAxis() || !this.getYAxis()) {
          throw 'No axes were defined for this serie';
        }

        if (force || this.hasDataChanged()) {
          if (!this.drawInit(force)) {
            return;
          }

          var data = this._dataToUse,
              xData = this._xDataToUse,
              slotToUse = this._slotToUse;

          this.removeLinesGroup();
          this.eraseMarkers();

          this.lookForMaxima = true;
          this.lookForMinima = false;

          this.markerFamily = this.markerFamilies[this.selectionType || 'unselected'];

          this.pos0 = this.getYAxis().getPos(0);

          if (this.hasErrors()) {
            this.errorDrawInit();
          }

          this._draw();

          if (this.hasErrors()) {
            this.errorDraw();
          }

          this.removeExtraLines();
          this.insertMarkers();
          this.insertLinesGroup();
        }

        // Unhovers everything
        for (var i in this.domMarkerHover) {
          this.toggleMarker(i.split(','), false, true);
        }

        // Deselects everything
        for (var i in this.domMarkerSelect) {
          this.toggleMarker(i.split(','), false, false);
        }

        this.applyLineStyle(this.getSymbolForLegend());

        if (this.hasStyleChanged(this.selectionType)) {
          this.updateStyle();
        }

        this.dataHasChanged(false);
        _get(SerieLine.prototype.__proto__ || Object.getPrototypeOf(SerieLine.prototype), 'afterDraw', this).call(this);
      }
    }, {
      key: '_draw',
      value: function _draw() {
        var _this3 = this;

        var self = this,
            waveform = this.waveform,
            data = void 0,
            x = void 0,
            y = void 0,
            lastX = false,
            lastY = false,
            xpx = void 0,
            ypx = void 0,
            xpx2 = void 0,
            ypx2 = void 0,
            xAxis = this.getXAxis(),
            yAxis = this.getYAxis(),
            xMin = xAxis.getCurrentMin(),
            yMin = yAxis.getCurrentMin(),
            xMax = xAxis.getCurrentMax(),
            yMax = yAxis.getCurrentMax();

        if (!waveform) {
          return;
        }

        data = waveform.getData(true);

        // Y crossing
        var yLeftCrossingRatio = void 0,
            yLeftCrossing = void 0,
            yRightCrossingRatio = void 0,
            yRightCrossing = void 0,
            xTopCrossingRatio = void 0,
            xTopCrossing = void 0,
            xBottomCrossingRatio = void 0,
            xBottomCrossing = void 0,


        /*xshift = waveform.getXShift(),
        xscale = wave.getXScale(),*/
        yshift = waveform.getShift(),
            yscale = waveform.getScale();

        var pointOutside = false;
        var lastPointOutside = false;
        var pointOnAxis = void 0;

        var _monotoneous = this.isMonotoneous(),
            _markersShown = this.markersShown();

        var i = 0,
            l = waveform.getLength();

        this.currentLine = '';

        if (waveform.isXMonotoneous()) {

          if (waveform.isXMonotoneousAscending()) {

            try {
              i = waveform.getIndexFromX(xMin, true) || 0;
              l = waveform.getIndexFromX(xMax, true);
            } catch (e) {

              l = waveform.getLength();
            }
          } else {

            try {
              i = waveform.getIndexFromX(xMax, true) || 0;
              l = waveform.getIndexFromX(xMin, true);
            } catch (e) {

              l = waveform.getLength();
            }
          }

          l += 2;
          if (l > data.length) {
            l = data.length;
          }
        }

        for (; i < l; i += 1) {

          x = waveform.getX(i, true);
          y = data[i] * yscale + yshift;

          if (x != x || y != y) {
            // NaN checks
            this._createLine();
            continue;
          }

          if (!this.options.overflowX && x < xMin && lastX < xMin || !this.options.overflowX && x > xMax && lastX > xMax || (!this.options.overflowY && y < yMin && lastY < yMin || !this.options.overflowY && y > yMax && lastY > yMax) && !this.options.lineToZero) {
            lastX = x;
            lastY = y;
            lastPointOutside = true;
            continue;
          }

          this.counter2 = i;

          if (_markersShown) {
            this.getMarkerCurrentFamily(this.counter2);
          }

          xpx2 = this.getX(x);
          ypx2 = this.getY(y);
          //xpx2 = 0;
          //ypx2 = 0;

          if (xpx2 == xpx && ypx2 == ypx) {
            continue;
          }

          if (xpx2 != xpx2 || ypx2 != ypx2) {
            // NaN checks
            if (this.counter > 0) {

              this._createLine();
            }
            continue;
          }

          if (!_monotoneous) {

            pointOutside = !this.options.overflowX && (x < xMin || x > xMax) || !this.options.overflowY && (y < yMin || y > yMax);
          } else {
            pointOutside = !this.options.overflowY && (y < yMin || y > yMax);
          }

          if (this.options.lineToZero) {
            pointOutside = x < xMin || x > xMax;

            if (pointOutside) {
              continue;
            }
          } else {

            if (pointOutside || lastPointOutside) {

              if ((lastX === false || lastY === false) && !lastPointOutside) {

                xpx = xpx2;
                ypx = ypx2;
                lastX = x;
                lastY = y;
              } else {

                pointOnAxis = [];
                // Y crossing
                yLeftCrossingRatio = (x - xMin) / (x - lastX);
                yLeftCrossing = y - yLeftCrossingRatio * (y - lastY);
                yRightCrossingRatio = (x - xMax) / (x - lastX);
                yRightCrossing = y - yRightCrossingRatio * (y - lastY);

                // X crossing
                xTopCrossingRatio = (y - yMin) / (y - lastY);
                xTopCrossing = x - xTopCrossingRatio * (x - lastX);
                xBottomCrossingRatio = (y - yMax) / (y - lastY);
                xBottomCrossing = x - xBottomCrossingRatio * (x - lastX);

                if (yLeftCrossingRatio < 1 && yLeftCrossingRatio > 0 && yLeftCrossing !== false && yLeftCrossing < yMax && yLeftCrossing > yMin) {
                  pointOnAxis.push([xMin, yLeftCrossing]);
                }

                if (yRightCrossingRatio < 1 && yRightCrossingRatio > 0 && yRightCrossing !== false && yRightCrossing < yMax && yRightCrossing > yMin) {
                  pointOnAxis.push([xMax, yRightCrossing]);
                }

                if (xTopCrossingRatio < 1 && xTopCrossingRatio > 0 && xTopCrossing !== false && xTopCrossing < xMax && xTopCrossing > xMin) {
                  pointOnAxis.push([xTopCrossing, yMin]);
                }

                if (xBottomCrossingRatio < 1 && xBottomCrossingRatio > 0 && xBottomCrossing !== false && xBottomCrossing < xMax && xBottomCrossing > xMin) {
                  pointOnAxis.push([xBottomCrossing, yMax]);
                }

                if (pointOnAxis.length > 0) {

                  if (!pointOutside) {
                    // We were outside and now go inside

                    if (pointOnAxis.length > 1) {
                      console.error('Programmation error. Please e-mail me.');
                      console.log(pointOnAxis, xBottomCrossing, xTopCrossing, yRightCrossing, yLeftCrossing, y, yMin, yMax, lastY);
                    }

                    this._createLine();
                    this._addPoint(this.getX(pointOnAxis[0][0]), this.getY(pointOnAxis[0][1]), pointOnAxis[0][0], pointOnAxis[0][1], false, false, false);
                    this._addPoint(xpx2, ypx2, lastX, lastY, false, false, true);
                  } else if (!lastPointOutside) {
                    // We were inside and now go outside

                    if (pointOnAxis.length > 1) {
                      console.error('Programmation error. Please e-mail me.');
                      console.log(pointOnAxis, xBottomCrossing, xTopCrossing, yRightCrossing, yLeftCrossing, y, yMin, yMax, lastY);
                    }

                    this._addPoint(this.getX(pointOnAxis[0][0]), this.getY(pointOnAxis[0][1]), pointOnAxis[0][0], pointOnAxis[0][1], false, false, false);
                  } else {

                    // No crossing: do nothing
                    if (pointOnAxis.length == 2) {
                      this._createLine();

                      this._addPoint(this.getX(pointOnAxis[0][0]), this.getY(pointOnAxis[0][1]), pointOnAxis[0][0], pointOnAxis[0][1], false, false, false);
                      this._addPoint(this.getX(pointOnAxis[1][0]), this.getY(pointOnAxis[1][1]), pointOnAxis[0][0], pointOnAxis[0][1], false, false, false);
                    }
                  }
                } else if (!pointOutside) {

                  this._addPoint(xpx2, ypx2, lastX, lastY, i, false, false);
                } // else {
                // Norman:
                // This else case is not the sign of a bug. If yLeftCrossing == 0 or 1 for instance, pointOutside or lastPointOutside will be true
                // However, there's no need to draw anything because the point is on the axis and will already be covered.
                // 28 Aug 2015

                /*
                  if ( lastPointOutside !== pointOutside ) {
                    console.error( "Programmation error. A crossing should have been found" );
                    console.log( yLeftCrossing, yLeftCrossingRatio, yMax, yMin );
                    console.log( yRightCrossing, yRightCrossingRatio, yMax, yMin );
                    console.log( xTopCrossing, xTopCrossingRatio, xMax, xMin );
                    console.log( xBottomCrossing, xBottomCrossingRatio, xMax, xMin );
                    console.log( pointOutside, lastPointOutside )
                   }
                  */
                // }
              }

              xpx = xpx2;
              ypx = ypx2;
              lastX = x;
              lastY = y;

              lastPointOutside = pointOutside;

              continue;
            }
          }

          this._addPoint(xpx2, ypx2, x, y, i, false, true);

          //this.detectPeaks( x, y );

          xpx = xpx2;
          ypx = ypx2;

          lastX = x;
          lastY = y;
        }

        this._createLine();

        if (this._tracker) {

          if (this._trackerDom) {
            this._trackerDom.remove();
          }

          var cloned = this.groupLines.cloneNode(true);
          this.groupMain.appendChild(cloned);

          for (i = 0, l = cloned.children.length; i < l; i++) {

            cloned.children[i].setAttribute('stroke', 'transparent');
            cloned.children[i].setAttribute('stroke-width', '25px');
            cloned.children[i].setAttribute('pointer-events', 'stroke');
          }

          this._trackerDom = cloned;

          this.groupMain.addEventListener('mousemove', function (e) {
            var coords = _this3.graph._getXY(e),
                ret = _this3.handleMouseMove(false, false);

            _this3._trackingCallback(_this3, ret, coords.x, coords.y);
          });

          this.groupMain.addEventListener('mouseleave', function (e) {
            _this3._trackingOutCallback(_this3);
          });
        }

        return this;
      }
    }, {
      key: 'kill',
      value: function kill() {
        _get(SerieLine.prototype.__proto__ || Object.getPrototypeOf(SerieLine.prototype), 'kill', this).call(this);
      }
    }, {
      key: 'getMarkerCurrentFamily',
      value: function getMarkerCurrentFamily(k) {

        if (!this.markerPoints || !this.markerPoints[this.selectionType]) {
          return;
        }

        var family;

        for (var z = 0; z < this.markerPoints[this.selectionType].length; z++) {
          if (this.markerPoints[this.selectionType][z][0] <= k) {
            // This one is a possibility !
            if (this.markerPoints[this.selectionType][z][1] >= k) {
              // Verify that it's in the boundary
              this.markerCurrentFamily = this.markerPoints[this.selectionType][z][2];
              family = this.markerFamilies[this.selectionType][this.markerCurrentFamily];
            }
          } else {
            break;
          }
        }

        if (!family) {
          return false;
        }
        this.getMarkerDom(family);
        return this.markerCurrentFamily;
      }
    }, {
      key: 'setMarkerStyleTo',
      value: function setMarkerStyleTo(dom, family) {

        if (!dom || !family) {
          console.trace();
          throw 'Cannot set marker style. DOM does not exist.';
        }

        dom.setAttribute('fill', family.fillColor || 'transparent');
        dom.setAttribute('stroke', family.strokeColor || this.getLineColor());
        dom.setAttribute('stroke-width', family.strokeWidth || 1);
      }
    }, {
      key: 'hideTrackingMarker',
      value: function hideTrackingMarker() {
        this.marker.setAttribute('display', 'none');
        this.markerLabel.setAttribute('display', 'none');
        this.markerLabelSquare.setAttribute('display', 'none');
      }
    }, {
      key: '_addPoint',
      value: function _addPoint(xpx, ypx, x, y, j, move, allowMarker) {

        /*if( ! this.currentLineId ) {
            throw "No current line"
          }* @memberof SerieLine
        */

        if (xpx !== xpx || ypx !== ypx) {
          return;
        }

        if (this.counter == 0) {
          this.currentLine = 'M ';
        } else {

          if (this.options.lineToZero || move) {
            this.currentLine += 'M ';
          } else {
            this.currentLine += 'L ';
          }
        }

        this.currentLine += xpx;
        this.currentLine += ' ';
        this.currentLine += ypx;
        this.currentLine += ' ';

        if (this.options.lineToZero && this.pos0 !== undefined) {

          this.currentLine += 'L ';
          this.currentLine += xpx;
          this.currentLine += ' ';
          this.currentLine += this.pos0;
          this.currentLine += ' ';
        }

        if (this.hasErrors()) {
          this.errorAddPoint(j, x, y, xpx, ypx);
        }

        if (!this.markerPoints) {
          this.counter++;

          return;
        }

        if (this.markersShown() && allowMarker !== false && this.markerFamily) {
          drawMarkerXY(this, this.markerFamily[this.markerCurrentFamily], xpx, ypx, this.markersDom.get(this.markerFamily[this.markerCurrentFamily]));
        }

        this.counter++;
      }
    }, {
      key: '_createLine',
      value: function _createLine() {

        var i = this.currentLineId++,
            line;

        // Creates a line if needed
        if (this.lines[i]) {
          line = this.lines[i];
        } else {

          line = document.createElementNS(this.graph.ns, 'path');
          this.applyLineStyle(line);
          this.groupLines.appendChild(line);
          this.lines[i] = line;
        }

        if (this.counter == 0) {
          line.setAttribute('d', '');
        } else {
          line.setAttribute('d', this.currentLine);
        }

        this.currentLine = 'M ';
        this.counter = 0;

        return line;
      }
    }, {
      key: 'applyLineStyles',
      value: function applyLineStyles() {

        for (var i = 0; i < this.lines.length; i++) {
          this.applyLineStyle(this.lines[i]);
        }
      }
    }, {
      key: 'applyLineStyle',
      value: function applyLineStyle(line) {

        line.setAttribute('stroke', this.getLineColor());
        line.setAttribute('stroke-width', this.getLineWidth());
        if (this.getLineDashArray()) {
          line.setAttribute('stroke-dasharray', this.getLineDashArray());
        } else {
          line.removeAttribute('stroke-dasharray');
        }
        line.setAttribute('fill', 'none');
        //	line.setAttribute('shape-rendering', 'optimizeSpeed');
      }
    }, {
      key: 'updateStyle',
      value: function updateStyle() {
        this.applyLineStyles();
        this.setLegendSymbolStyle();

        this.styleHasChanged(false);
      }
    }, {
      key: 'getMarkerPath',
      value: function getMarkerPath(family, add) {

        var z = family.zoom || 1,
            add = add || 0,
            el = [];

        switch (family.type) {

          case 2:
            el = ['m', -2, -2, 'l', 4, 4, 'm', -4, 0, 'l', 4, -4];
            break;

          case 3:
            el = ['m', -2, 0, 'l', 4, 0, 'm', -2, -2, 'l', 0, 4];
            break;

          case 4:
            el = ['m', -1, -1, 'l', 2, 0, 'l', -1, 2, 'z'];
            break;

          default:
          case 1:
            el = ['m', -2, -2, 'l', 4, 0, 'l', 0, 4, 'l', -4, 0, 'z'];
            break;

        }

        if ((z == 1 || !z) && !add) {
          return el.join(' ');
        }

        var num = 'number';

        if (!el) {
          return;
        }

        for (var i = 0, l = el.length; i < l; i++) {

          if (_typeof(el[i]) == num) {

            el[i] *= z + add;
          }
        }

        return el.join(' ');
      }
    }, {
      key: 'getMarkerDom',
      value: function getMarkerDom(family) {

        var self = this;

        if (!this.markersDom.has(family)) {

          var dom = document.createElementNS(this.graph.ns, 'path');
          this.setMarkerStyleTo(dom, family);
          this.markersDom.set(family, {
            dom: dom,
            path: ''
          });

          dom.addEventListener('mouseover', function (e) {
            var closest = self._getMarkerIndexFromEvent(e);
            self.onMouseOverMarker(e, closest);
          });

          dom.addEventListener('mouseout', function (e) {
            var closest = self._getMarkerIndexFromEvent(e);
            self.onMouseOutMarker(e, closest);
          });

          dom.addEventListener('click', function (e) {
            var closest = self._getMarkerIndexFromEvent(e);
            self.onClickOnMarker(e, closest);
          });
        }

        return family.dom;
      }
    }, {
      key: 'getMarkerDomIndependent',
      value: function getMarkerDomIndependent(index, family) {
        var _this4 = this;

        if (!this.independantMarkers[index]) {

          var dom = document.createElementNS(this.graph.ns, 'path');
          this.setMarkerStyleTo(dom, family);

          dom.addEventListener('mouseover', function (e) {

            _this4.onMouseOverMarker(e, index);
          });

          dom.addEventListener('mouseout', function (e) {

            _this4.onMouseOutMarker(e, index);
          });

          dom.addEventListener('click', function (e) {

            _this4.onClickOnMarker(e, index);
          });

          this.independantMarkers[index] = dom;
        }

        this.groupMarkers.appendChild(this.independantMarkers[index]);

        return this.independantMarkers[index];
      }
    }, {
      key: 'searchIndexByPxXY',
      value: function searchIndexByPxXY(x, y) {

        var oldDist = false,
            xyindex = false,
            dist;

        var xData = this._xDataToUse,
            p_x,
            p_y;

        for (var k = 0, m = this.waveform.getLength(); k < m; k += 1) {

          p_x = this.waveform.getX(k);
          p_y = this.waveform.getY(k);

          dist = Math.pow(this.getX(p_x) - x, 2) + Math.pow(this.getY(p_y) - y, 2);
          //console.log(x, y, dist, this.data[i][k], this.data[i][k + 1]);

          if (!oldDist || dist < oldDist) {
            oldDist = dist;
            xyindex = k;
          }
        }

        return xyindex;
      }
    }, {
      key: 'searchClosestValue',
      value: function searchClosestValue(valX, valY) {

        if (this.waveform) {

          var indexX = void 0;
          try {

            indexX = this.waveform.getIndexFromXY(valX, valY, undefined, undefined, this.getXAxis().getRelPx(1), this.getYAxis().getRelPx(1));
          } catch (e) {
            console.log(e);
            throw new Error('Error while finding the closest index');
            return {};
          }

          if (isNaN(indexX)) {
            return false;
          }

          var returnObj = {};

          var direction = void 0;
          // Changed on 8 March. Before is was 0 and +1, why ? In case of decreasing data ? Not sure
          if (valX > this.waveform.getX(indexX)) {
            direction = -1;
          } else {
            direction = 0;
          }

          Object.assign(returnObj, {
            indexMin: indexX + direction,
            indexMax: indexX + direction + 1,
            indexClosest: indexX,
            xMin: this.waveform.getX(indexX + direction),
            xMax: this.waveform.getX(indexX + direction + 1),
            yMin: this.waveform.getY(indexX + direction),
            yMax: this.waveform.getY(indexX + direction + 1),
            xClosest: this.waveform.getX(indexX),
            yClosest: this.waveform.getY(indexX),
            xExact: valX
          });
          return returnObj;
        }
      }
    }, {
      key: 'handleMouseMove',
      value: function handleMouseMove(xValue, doMarker, yValue) {

        var valX = xValue || this.getXAxis().getMouseVal(),
            valY = yValue || this.getYAxis().getMouseVal(),
            xMinIndex,
            xMin,
            yMin,
            xMax,
            yMax;

        var value = this.searchClosestValue(valX, valY);

        if (!value) {
          return;
        }

        var ratio, intY;

        if (value.xMax == value.xMin) {
          intY = value.yMin;
        } else {

          //ratio = ( valX - value.xMin ) / ( value.xMax - value.xMin );
          //intY = ( ( 1 - ratio ) * value.yMin + ratio * value.yMax );
        }

        if (doMarker && this.options.trackMouse) {

          if (value.xMin == undefined) {

            return false;
          } else {

            if (!this.marker) {
              return;
            }

            var x = this.getX(this.getFlip() ? value.yClosest : value.xClosest);
            var y = this.getY(this.getFlip() ? value.xClosest : value.yClosest);

            if (isNaN(x) || isNaN(y)) {
              return;
            }

            this.marker.setAttribute('display', 'block');
            this.marker.setAttribute('cx', x);
            this.marker.setAttribute('cy', y);

            this.markerLabel.setAttribute('display', 'block');
            this.markerLabelSquare.setAttribute('display', 'block');

            switch (this.options.trackMouseLabel) {

              case false:

                break;

              default:
                this.markerLabel.textContent = this.options.trackMouseLabel.replace('<x>', valX.toFixed(this.options.trackMouseLabelRouding)).replace('<y>', intY.toFixed(this.options.trackMouseLabelRouding));
                break;
            }

            this.markerLabel.setAttribute('x', x + 5);
            this.markerLabel.setAttribute('y', y - 5);

            this.markerLabelSquare.setAttribute('x', x + 5);
            this.markerLabelSquare.setAttribute('y', y - 5 - this.graph.options.fontSize);
            this.markerLabelSquare.setAttribute('width', this.markerLabel.getComputedTextLength() + 2);
            this.markerLabelSquare.setAttribute('height', this.graph.options.fontSize + 2);
          }
        }

        return {
          xBefore: value.xMin,
          xAfter: value.xMax,
          yBefore: value.yMin,
          yAfter: value.yMax,
          trueX: value.xExact,
          indexClosest: value.indexClosest,
          interpolatedY: intY,

          xClosest: value.xClosest,
          yClosest: value.yClosest
        };
      }
    }, {
      key: 'getMax',
      value: function getMax(start, end) {

        var start2 = Math.min(start, end),
            end2 = Math.max(start, end),
            v1 = this.searchClosestValue(start2),
            v2 = this.searchClosestValue(end2),
            i,
            j,
            max = -Infinity,
            initJ,
            maxJ;

        //      console.log( start2, end2, v1, v2 );

        if (!v1) {
          start2 = this.minX;
          v1 = this.searchClosestValue(start2);
        }

        if (!v2) {
          end2 = this.maxX;
          v2 = this.searchClosestValue(end2);
        }

        if (!v1 || !v2) {
          return -Infinity;
        }

        for (i = v1.dataIndex; i <= v2.dataIndex; i++) {
          initJ = i == v1.dataIndex ? v1.xBeforeIndexArr : 0;
          maxJ = i == v2.dataIndex ? v2.xBeforeIndexArr : this.data[i].length;

          for (j = initJ; j <= maxJ; j += 2) {
            max = Math.max(max, this.data[i][j + 1]);
          }
        }

        return max;
      }
    }, {
      key: 'getMin',
      value: function getMin(start, end) {

        var start2 = Math.min(start, end),
            end2 = Math.max(start, end),
            v1 = this.searchClosestValue(start2),
            v2 = this.searchClosestValue(end2),
            i,
            j,
            min = Infinity,
            initJ,
            maxJ;

        if (!v1) {
          start2 = this.minX;
          v1 = this.searchClosestValue(start2);
        }

        if (!v2) {
          end2 = this.maxX;
          v2 = this.searchClosestValue(end2);
        }

        if (!v1 || !v2) {
          return Infinity;
        }

        for (i = v1.dataIndex; i <= v2.dataIndex; i++) {
          initJ = i == v1.dataIndex ? v1.xBeforeIndexArr : 0;
          maxJ = i == v2.dataIndex ? v2.xBeforeIndexArr : this.data[i].length;

          for (j = initJ; j <= maxJ; j += 2) {
            min = Math.min(min, this.data[i][j + 1]);
          }
        }

        return min;
      }
    }, {
      key: 'setStyle',
      value: function setStyle(style) {
        var selectionType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'unselected';


        this.styles[selectionType] = style;
        this.styleHasChanged(selectionType);
      }
    }, {
      key: 'setLineStyle',
      value: function setLineStyle(number) {
        var selectionType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'unselected';
        var applyToSelected = arguments[2];


        this.styles[selectionType] = this.styles[selectionType] || {};
        this.styles[selectionType].lineStyle = number;

        if (applyToSelected) {
          this.setLineStyle(number, 'selected');
        }

        this.styleHasChanged(selectionType);

        return this;
      }
    }, {
      key: 'getLineStyle',
      value: function getLineStyle(selectionType) {
        return this.getStyle(selectionType).lineStyle;
      }
    }, {
      key: 'getLineDashArray',
      value: function getLineDashArray() {
        var selectionType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.selectionType || 'unselected';


        switch (this.getStyle(selectionType).lineStyle) {

          case 2:
            return '1, 1';
            break;
          case 3:
            return '2, 2';
            break;
          case 4:
            return '3, 3';
            break;
          case 5:
            return '4, 4';
            break;
          case 6:
            return '5, 5';
            break;

          case 7:
            return '5 2';
            break;
          case 8:
            return '2 5';
            break;

          case 9:
            return '4 2 4 4';
            break;
          case 10:
            return '1,3,1';
            break;
          case 11:
            return '9 2';
            break;
          case 12:
            return '2 9';
            break;

          case 1:
          case false:
            return false;
            break;

          default:
            return this.styles[selectionType].lineStyle;
            break;
        }

        this.styleHasChanged(selectionType);
      }
    }, {
      key: 'getStyle',
      value: function getStyle() {
        var selectionType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.selectionType || 'unselected';

        return this.styles[selectionType];
      }
    }, {
      key: 'extendStyles',
      value: function extendStyles() {
        for (var i in this.styles) {

          var s = this.styles[i];
          if (s) {
            this.styles[i] = util.extend(true, {}, this.styles.unselected, s);
          }
        }
      }
    }, {
      key: 'extendStyle',
      value: function extendStyle(styleTarget, styleOrigin) {
        var s = this.styles[styleTarget];

        this.styles[styleTarget] = util.extend(true, {}, this.styles[styleOrigin || 'unselected'], s || {});

        this.styles[styleTarget].markers.map(function (marker) {
          if (marker.dom) {
            marker.dom = '';
          }
        });

        this._recalculateMarkerPoints(styleTarget, this.styles[styleTarget].markers);
        this.styleHasChanged(styleTarget);
      }
    }, {
      key: 'setLineWidth',
      value: function setLineWidth(width, selectionType, applyToSelected) {

        selectionType = selectionType || 'unselected';
        this.styles[selectionType] = this.styles[selectionType] || {};
        this.styles[selectionType].lineWidth = width;

        if (applyToSelected) {
          this.setLineWidth(width, 'selected');
        }

        this.styleHasChanged(selectionType);

        return this;
      }
    }, {
      key: 'getLineWidth',
      value: function getLineWidth(selectionType) {

        return this.getStyle(selectionType).lineWidth || 1;
      }
    }, {
      key: 'setLineColor',
      value: function setLineColor(color, selectionType, applyToSelected) {

        selectionType = selectionType || 'unselected';
        this.styles[selectionType] = this.styles[selectionType] || {};
        this.styles[selectionType].lineColor = color;

        if (applyToSelected) {
          this.setLineColor(color, 'selected');
        }

        this.styleHasChanged(selectionType);

        return this;
      }
    }, {
      key: 'getLineColor',
      value: function getLineColor(selectionType) {

        return this.getStyle(selectionType).lineColor || 'black';
      }
    }, {
      key: 'showMarkers',
      value: function showMarkers(selectionType, redraw) {
        selectionType = selectionType || 'unselected';
        this.styles[selectionType] = this.styles[selectionType] || {};
        this.styles[selectionType].showMarkers = true;

        if (redraw && this._drawn) {
          this.draw(true);
        } else {
          this.styleHasChanged(selectionType);
        }

        return this;
      }
    }, {
      key: 'hideMarkers',
      value: function hideMarkers(selectionType, redraw) {

        selectionType = selectionType || 'unselected';
        this.styles[selectionType].showMarkers = false;

        if (redraw && this._drawn) {
          this.draw(true);
        } else {
          this.styleHasChanged(selectionType);
        }
        return this;
      }
    }, {
      key: 'markersShown',
      value: function markersShown(selectionType) {
        return this.getStyle(selectionType).showMarkers !== false;
      }
    }, {
      key: 'areMarkersShown',
      value: function areMarkersShown() {
        return this.markersShown.apply(this, arguments);
      }
    }, {
      key: 'isMarkersShown',
      value: function isMarkersShown() {
        return this.markersShown.apply(this, arguments);
      }
    }, {
      key: 'setMarkers',
      value: function setMarkers(families, selectionType, applyToSelected) {
        // Family has to be an object
        // Family looks like
        /*
        {
        	type: 1,
        	zoom: 1,
        	strokeWidth: 1,
        	strokeColor: '',
        	fillColor: '',
              points: []
        }
        * @memberof SerieLine
        */

        this.styles[selectionType || 'unselected'] = this.styles[selectionType || 'unselected'] || {};

        this.showMarkers(selectionType, false);

        if (!Array.isArray(families) && (typeof families === 'undefined' ? 'undefined' : _typeof(families)) == 'object') {
          families = [families];
        } else if (!families) {

          families = [{
            type: 1,
            zoom: 1,
            points: 'all'
          }];
        }

        this.styles[selectionType || 'unselected'].markers = families;

        if (applyToSelected) {
          this.styles.selected.markers = util.extend(true, {}, families);
        }

        this._recalculateMarkerPoints(selectionType, families);
        this.styleHasChanged(selectionType);
        this.dataHasChanged(true); // Data has not really changed, but marker placing is performed during the draw method
        return this;
      }
    }, {
      key: 'setMarkersPoints',
      value: function setMarkersPoints(points, family, selectionType) {
        this._extendMarkers('points', points, family, selectionType, true);
      }
    }, {
      key: 'setMarkersColor',
      value: function setMarkersColor(color, family, selectionType) {
        this._extendMarkers('color', color, family, selectionType);
      }
    }, {
      key: 'setMarkersType',
      value: function setMarkersType(type, family, selectionType) {
        this._extendMarkers('type', type, family, selectionType);
      }
    }, {
      key: 'setMarkersZoom',
      value: function setMarkersZoom(zoom, family, selectionType) {
        this._extendMarkers('zoom', zoom, family, selectionType);
      }
    }, {
      key: 'setMarkersStrokeColor',
      value: function setMarkersStrokeColor(strokeColor, family, selectionType) {
        this._extendMarkers('strokeColor', strokeColor, family, selectionType);
      }
    }, {
      key: 'setMarkersStrokeWidth',
      value: function setMarkersStrokeWidth(strokeWidth, family, selectionType) {
        this._extendMarkers('strokeWidth', strokeWidth, family, selectionType);
      }
    }, {
      key: 'setMarkersFillColor',
      value: function setMarkersFillColor(fillColor, family, selectionType) {
        this._extendMarkers('fillColor', fillColor, family, selectionType);
      }
    }, {
      key: '_extendMarkers',
      value: function _extendMarkers(type, value, family, selectionType, recalculatePoints) {

        family = family || 0;
        selectionType = selectionType || 'unselected';

        if (!this.styles[selectionType] || !this.styles[selectionType].markers) {
          return;
        }

        this.styles[selectionType].markers[family][type] = value;

        if (recalculatePoints) {
          this._recalculateMarkerPoints(selectionType, this.styles[selectionType].markers);
        }

        if (!this.markersDom[this.styles[selectionType].markers[family]]) {
          // DOM doesn't exist yet.
          return;
        }

        this.setMarkerStyleTo(this.markersDom[this.styles[selectionType].markers[family]].dom, this.styles[selectionType].markers[family]);
      }
    }, {
      key: '_recalculateMarkerPoints',
      value: function _recalculateMarkerPoints(selectionType, families) {

        var markerPoints = [];
        // Overwriting any other undefined families
        markerPoints.push([0, Infinity, null]);

        for (var i = 0, k = families.length; i < k; i++) {

          families[i].markerPath = this.getMarkerPath(families[i]);

          if (!families[i].points) {
            families[i].points = 'all';
          }

          if (!Array.isArray(families[i].points)) {
            families[i].points = [families[i].points];
          }

          for (var j = 0, l = families[i].points.length; j < l; j++) {

            if (families[i].points[j] == 'all') {

              markerPoints.push([0, Infinity, i]);
            } else if (!Array.isArray(families[i].points[j])) {

              markerPoints.push([families[i].points[j], families[i].points[j], i]);
              //markerPoints.push( [ family[ i ].points[ j ] + 1, null ] );
            } else {

              markerPoints.push([families[i].points[j][0], families[i].points[j][1], i]);
            }
          }
        }

        this.markerFamilies[selectionType || 'unselected'] = families;

        // Let's sort if by the first index.
        markerPoints.sort(function (a, b) {
          return a[0] - b[0] || (a[2] == null ? -1 : 1);
        });

        this.markerPoints[selectionType || 'unselected'] = markerPoints;
      }
    }, {
      key: 'insertMarkers',
      value: function insertMarkers(selectionType) {

        if (!this.markerFamilies || !this.markerFamilies[selectionType || this.selectionType] || this.options.markersIndependant) {
          return;
        }

        for (var i = 0, l = this.markerFamilies[selectionType || this.selectionType].length; i < l; i++) {

          if (!this.markersDom.has(this.markerFamilies[selectionType || this.selectionType][i])) {
            continue;
          }

          var dom = this.markersDom.get(this.markerFamilies[selectionType || this.selectionType][i]);

          dom.dom.setAttribute('d', dom.path);

          this.groupMarkers.appendChild(dom.dom);
          this.currentMarkersSelectionType = this.selectionType;
        }
      }
    }, {
      key: 'getMarkerForLegend',
      value: function getMarkerForLegend() {

        if (!this.markerPoints || !this.markerPoints[this.selectionType]) {
          return;
        }

        if (!this.markerForLegend) {

          var marker = document.createElementNS(this.graph.ns, 'path');
          this.setMarkerStyleTo(marker, this.markerFamilies[this.selectionType][0]);

          marker.setAttribute('d', 'M 14 0 ' + this.getMarkerPath(this.markerFamilies[this.selectionType][0]));

          this.markerForLegend = marker;
        }

        return this.markerForLegend;
      }
    }, {
      key: 'eraseMarkers',
      value: function eraseMarkers() {

        var self = this;

        if (this.options.markersIndependant) {

          for (var i in this.independantMarkers) {
            self.groupMarkers.removeChild(this.independantMarkers[i]);
          }

          this.independantMarkers = {};
        } else if (this.currentMarkersSelectionType) {

          this.markersDom.forEach(function (el) {

            if (!el.dom) {
              return;
            }

            if (el.dom.parentNode !== self.groupMarkers) {
              return;
            }

            self.groupMarkers.removeChild(el.dom);
            el.path = '';
          });

          this.currentMarkersSelectionType = false;
        }
      }
    }, {
      key: 'isMonotoneous',
      value: function isMonotoneous() {
        if (this.waveform) {
          return this.waveform.isMonotoneous();
        }

        return !!this.xmonotoneous;
      }
    }, {
      key: 'findLocalMinMax',
      value: function findLocalMinMax(xRef, xWithin, type) {

        if (!this.waveform) {
          return false;
        }

        return this.waveform.findLocalMinMax(xRef, xWithin, type);
      }
    }]);

    return SerieLine;
  }(_graphSerie2.default);

  function drawMarkerXY(graph, family, x, y, markerDom) {

    if (!family) {
      return;
    }

    if (graph.options.markersIndependant) {
      var dom = graph.getMarkerDomIndependent(graph.counter2, family);
      var p = 'M ' + x + ' ' + y + ' ';
      p += family.markerPath + ' ';

      dom.setAttribute('d', p);
    }

    markerDom.path = markerDom.path || '';
    markerDom.path += 'M ' + x + ' ' + y + ' ';
    markerDom.path += family.markerPath + ' ';
  }

  util.mix(SerieLine, _graphMixinErrorbars2.default);

  exports.default = SerieLine;
  module.exports = exports['default'];
});

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(21);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 53 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(21);
var TAG = __webpack_require__(6)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports);
    global.graphPosition = mod.exports;
  }
})(this, function (module, exports) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _parsePx(px) {
    if (px && px.indexOf && px.indexOf('px') > -1) {
      return parseInt(px.replace('px', ''));
    }
    return false;
  }

  function isNumeric(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  }

  /**
   * Utility class to compute positioning
   * @class
   */

  var Position = function () {
    function Position(x, y, dx, dy) {
      _classCallCheck(this, Position);

      if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) == 'object') {
        this.x = x.x;
        this.y = x.y;
        this.dx = x.dx;
        this.dy = x.dy;
      } else {
        this.x = x;
        this.y = y;
        this.dx = dx;
        this.dy = dy;
      }
    }

    _createClass(Position, [{
      key: 'duplicate',
      value: function duplicate() {
        return new Position(this.x, this.y, this.dx, this.dy);
      }
    }, {
      key: 'compute',
      value: function compute(graph, xAxis, yAxis, serie) {

        if (!graph || !xAxis || !yAxis || !graph.hasXAxis || !graph.hasYAxis) {
          graph.throw();
        }

        if (!graph.hasXAxis(xAxis)) {
          throw 'Graph does not contain the x axis that was used as a parameter';
        }

        if (!graph.hasYAxis(yAxis)) {
          throw 'Graph does not contain the x axis that was used as a parameter';
        }

        return this._compute(graph, xAxis, yAxis, serie);
      }
    }, {
      key: '_compute',
      value: function _compute(graph, xAxis, yAxis, serie) {

        var relativeTo = this._relativeTo;
        if (relativeTo) {
          var relativeToComputed = relativeTo._compute(graph, xAxis, yAxis, serie);
        }

        var parsed,
            pos = {
          x: false,
          y: false
        };

        if (!xAxis) {
          xAxis = graph.getXAxis();
        }

        if (!yAxis) {
          yAxis = graph.getYAxis();
        }

        for (var i in pos) {

          var axis = i == 'x' ? xAxis : yAxis;
          var val = this[i];
          var dval = this['d' + i];

          if (val === undefined && (dval !== undefined && relativeTo === undefined || relativeTo === undefined)) {

            if (i == 'x') {

              if (dval === undefined) {
                continue;
              }

              pos[i] = relativeTo ? relativeTo[i] : 0;
            } else if (this.x !== undefined && serie) {

              if (_parsePx(this.x) !== false) {
                console.warn('You have defined x in px and not y. Makes no sense. Returning 0 for y');
                pos[i] = 0;
              } else {

                try {

                  var closest = serie.searchClosestValue(this.x);

                  if (!closest) {
                    throw new Error('Could not find y position for x = ' + this.x + ' on serie "' + serie.getName() + '". Returning 0 for y.');
                  }

                  pos[i] = serie.getY(closest.yClosest);
                } catch (error) {
                  console.error(error);
                  pos[i] = 0;
                }
              }
            }
          } else if (val !== undefined) {

            pos[i] = this.getPx(val, axis);
          }

          if (dval !== undefined) {

            var def = val !== undefined || relativeToComputed == undefined || relativeToComputed[i] == undefined ? pos[i] : relativeToComputed[i];

            if (i == 'y' && relativeToComputed && relativeToComputed.x !== undefined && relativeToComputed.y == undefined) {

              if (!serie) {
                throw new Error('Error. No serie exists. Cannot find y value');
                return;
              }

              var closest = serie.searchClosestValue(relativeTo.x);
              if (closest) {
                def = serie.getY(closest.yMin);
              }

              //console.log( relativeTo.x, closest, serie.getY( closest.yMin ), def );
            }

            if (!def) {
              def = 0;
            }

            if ((parsed = _parsePx(dval)) !== false) {
              // dx in px => val + 10px

              pos[i] = def + parsed; // return integer (will be interpreted as px)
            } else if ((parsed = this._parsePercent(dval)) !== false) {

              pos[i] = def + this._getPositionPx(parsed, true, axis, graph); // returns xx%
            } else if (axis) {

              pos[i] = def + axis.getRelPx(dval); // px + unittopx
            }
          }
        }

        return pos;
      }
    }, {
      key: '_getPositionPx',
      value: function _getPositionPx(value, x, axis, graph) {

        var parsed;

        if ((parsed = _parsePx(value)) !== false) {
          return parsed; // return integer (will be interpreted as px)
        }

        if ((parsed = this._parsePercent(value)) !== false) {
          return parsed / 100 * (x ? graph.getDrawingWidth() : graph.getDrawingHeight());
        } else if (axis) {
          return axis.getPos(value);
        }
      }
    }, {
      key: '_parsePercent',
      value: function _parsePercent(percent) {
        if (percent && percent.indexOf && percent.indexOf('%') > -1) {
          return percent;
        }
        return false;
      }
    }, {
      key: 'getDeltaPx',
      value: function getDeltaPx(value, axis) {
        var v;
        if ((v = _parsePx(value)) !== false) {
          return v + 'px';
        } else {

          return axis.getRelPx(value) + 'px';
        }
      }
    }, {
      key: 'deltaPosition',
      value: function deltaPosition(mode, delta, axis) {

        mode = mode == 'y' ? 'y' : 'x';
        var ref = this[mode],
            refd = this['d' + mode],
            refPx,
            deltaPx;

        if (ref !== undefined) {
          if ((refPx = _parsePx(ref)) !== false) {

            if ((deltaPx = _parsePx(delta)) !== false) {
              this[mode] = refPx + deltaPx + 'px';
            } else {
              this[mode] = refPx + axis.getRelPx(delta) + 'px';
            }
          } else {

            ref = this.getValPosition(ref, axis);

            if ((deltaPx = _parsePx(delta)) !== false) {
              this[mode] = ref + axis.getRelVal(deltaPx);
            } else {
              this[mode] = ref + delta;
            }
          }
        } else if (refd !== undefined) {

          if (mode == 'y' && ref === undefined && !this._relativeTo) {
            // This means that the shape is placed by the x value. Therefore, the dy is only a stand-off.
            // Therefore, we do nothing
            return;
          }

          if ((refPx = _parsePx(refd)) !== false) {

            if ((deltaPx = _parsePx(delta)) !== false) {
              this['d' + mode] = refPx + deltaPx + 'px';
            } else {
              this['d' + mode] = refPx + axis.getRelPx(delta) + 'px';
            }
          } else {

            refd = this.getValPosition(refd, axis);

            if ((deltaPx = _parsePx(delta)) !== false) {
              this['d' + mode] = refd + axis.getRelVal(deltaPx);
            } else {
              this['d' + mode] = refd + delta;
            }
          }
        }
      }
    }, {
      key: 'getValPosition',
      value: function getValPosition(rel, axis) {

        if (rel == 'max') {
          return axis.getMaxValue();
        }

        if (rel == 'min') {
          return axis.getMinValue();
        }

        return rel;
      }
    }, {
      key: 'getPx',
      value: function getPx(value, axis, rel) {

        var parsed;

        if (typeof value == 'function') {

          return value(axis, rel);
        } else if ((parsed = _parsePx(value)) !== false) {

          return parsed; // return integer (will be interpreted as px)
        } else if ((parsed = this._parsePercent(value)) !== false) {

          return parsed; // returns xx%
        } else if (axis) {

          if (value == 'min') {

            return axis.getMinPx();
          } else if (value == 'max') {

            return axis.getMaxPx();
          } else if (rel) {

            return axis.getRelPx(value);
          } else if (isNumeric(value)) {

            return axis.getPos(value);
          }
        }
      }
    }, {
      key: 'getPxRel',
      value: function getPxRel(value, axis) {
        return this.getPx(value, axis, true);
      }
    }, {
      key: 'relativeTo',
      value: function relativeTo(pos) {
        this._relativeTo = Position.check(pos);
        return this;
      }
    }], [{
      key: 'check',
      value: function check(pos, callback) {
        if (pos instanceof Position) {
          return pos;
        }

        var posObject = new Position(pos);

        if (pos && pos.relativeTo) {
          var position = callback(pos.relativeTo);
          if (position) {
            posObject.relativeTo(position);
          }
        }

        return posObject;
      }
    }]);

    return Position;
  }();

  exports.default = Position;
  module.exports = exports['default'];
});

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports);
    global.EventEmitter = mod.exports;
  }
})(this, function (module, exports) {
  /*!
   * EventEmitter v4.2.9 - git.io/ee
   * Oliver Caldwell
   * MIT license
   * @preserve
   */

  'use strict';

  /**
   * Class for managing events.
   * Can be extended to provide event functionality in other classes.
   *
   * @class EventEmitter Manages event registering and emitting.
   */

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  function EventEmitter() {}

  // Shortcuts to improve speed and size
  var proto = EventEmitter.prototype;

  /**
   * Finds the index of the listener for the event in its storage array.
   *
   * @param {Function[]} listeners Array of listeners to search through.
   * @param {Function} listener Method to look for.
   * @return {Number} Index of the specified listener, -1 if not found
   * @api private
   */
  function indexOfListener(listeners, listener) {
    var i = listeners.length;
    while (i--) {
      if (listeners[i].listener === listener) {
        return i;
      }
    }

    return -1;
  }

  /**
   * Alias a method while keeping the context correct, to allow for overwriting of target method.
   *
   * @param {String} name The name of the target method.
   * @return {Function} The aliased method
   * @api private
   */
  function alias(name) {
    return function aliasClosure() {
      return this[name].apply(this, arguments);
    };
  }

  /**
   * Returns the listener array for the specified event.
   * Will initialise the event object and listener arrays if required.
   * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
   * Each property in the object response is an array of listener functions.
   *
   * @param {String|RegExp} evt Name of the event to return the listeners from.
   * @return {Function[]|Object} All listener functions for the event.
   */
  proto.getListeners = function getListeners(evt) {
    var events = this._getEvents();
    var response;
    var key;

    // Return a concatenated array of all matching events if
    // the selector is a regular expression.
    if (evt instanceof RegExp) {
      response = {};
      for (key in events) {
        if (events.hasOwnProperty(key) && evt.test(key)) {
          response[key] = events[key];
        }
      }
    } else {
      response = events[evt] || (events[evt] = []);
    }

    return response;
  };

  /**
   * Takes a list of listener objects and flattens it into a list of listener functions.
   *
   * @param {Object[]} listeners Raw listener objects.
   * @return {Function[]} Just the listener functions.
   */
  proto.flattenListeners = function flattenListeners(listeners) {
    var flatListeners = [];
    var i;

    for (i = 0; i < listeners.length; i += 1) {
      flatListeners.push(listeners[i].listener);
    }

    return flatListeners;
  };

  /**
   * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
   *
   * @param {String|RegExp} evt Name of the event to return the listeners from.
   * @return {Object} All listener functions for an event in an object.
   */
  proto.getListenersAsObject = function getListenersAsObject(evt) {
    var listeners = this.getListeners(evt);
    var response;

    if (listeners instanceof Array) {
      response = {};
      response[evt] = listeners;
    }

    return response || listeners;
  };

  /**
   * Adds a listener function to the specified event.
   * The listener will not be added if it is a duplicate.
   * If the listener returns true then it will be removed after it is called.
   * If you pass a regular expression as the event name then the listener will be added to all events that match it.
   *
   * @param {String|RegExp} evt Name of the event to attach the listener to.
   * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
   * @return {Object} Current instance of EventEmitter for chaining.
   */
  proto.addListener = function addListener(evt, listener) {
    var listeners = this.getListenersAsObject(evt);
    var listenerIsWrapped = (typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) === 'object';
    var key;

    for (key in listeners) {
      if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
        listeners[key].push(listenerIsWrapped ? listener : {
          listener: listener,
          once: false
        });
      }
    }

    return this;
  };

  /**
   * Alias of addListener
   */
  proto.on = alias('addListener');

  /**
   * Semi-alias of addListener. It will add a listener that will be
   * automatically removed after its first execution.
   *
   * @param {String|RegExp} evt Name of the event to attach the listener to.
   * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
   * @return {Object} Current instance of EventEmitter for chaining.
   */
  proto.addOnceListener = function addOnceListener(evt, listener) {
    return this.addListener(evt, {
      listener: listener,
      once: true
    });
  };

  /**
   * Alias of addOnceListener.
   */
  proto.once = alias('addOnceListener');

  /**
   * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
   * You need to tell it what event names should be matched by a regex.
   *
   * @param {String} evt Name of the event to create.
   * @return {Object} Current instance of EventEmitter for chaining.
   */
  proto.defineEvent = function defineEvent(evt) {
    this.getListeners(evt);
    return this;
  };

  /**
   * Uses defineEvent to define multiple events.
   *
   * @param {String[]} evts An array of event names to define.
   * @return {Object} Current instance of EventEmitter for chaining.
   */
  proto.defineEvents = function defineEvents(evts) {
    for (var i = 0; i < evts.length; i += 1) {
      this.defineEvent(evts[i]);
    }
    return this;
  };

  /**
   * Removes a listener function from the specified event.
   * When passed a regular expression as the event name, it will remove the listener from all events that match it.
   *
   * @param {String|RegExp} evt Name of the event to remove the listener from.
   * @param {Function} listener Method to remove from the event.
   * @return {Object} Current instance of EventEmitter for chaining.
   */
  proto.removeListener = function removeListener(evt, listener) {
    var listeners = this.getListenersAsObject(evt);
    var index;
    var key;

    for (key in listeners) {
      if (listeners.hasOwnProperty(key)) {
        index = indexOfListener(listeners[key], listener);

        if (index !== -1) {
          listeners[key].splice(index, 1);
        }
      }
    }

    return this;
  };

  /**
   * Alias of removeListener
   */
  proto.off = alias('removeListener');

  /**
   * Adds listeners in bulk using the manipulateListeners method.
   * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
   * You can also pass it a regular expression to add the array of listeners to all events that match it.
   * Yeah, this function does quite a bit. That's probably a bad thing.
   *
   * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
   * @param {Function[]} [listeners] An optional array of listener functions to add.
   * @return {Object} Current instance of EventEmitter for chaining.
   */
  proto.addListeners = function addListeners(evt, listeners) {
    // Pass through to manipulateListeners
    return this.manipulateListeners(false, evt, listeners);
  };

  /**
   * Removes listeners in bulk using the manipulateListeners method.
   * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
   * You can also pass it an event name and an array of listeners to be removed.
   * You can also pass it a regular expression to remove the listeners from all events that match it.
   *
   * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
   * @param {Function[]} [listeners] An optional array of listener functions to remove.
   * @return {Object} Current instance of EventEmitter for chaining.
   */
  proto.removeListeners = function removeListeners(evt, listeners) {
    // Pass through to manipulateListeners
    return this.manipulateListeners(true, evt, listeners);
  };

  /**
   * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
   * The first argument will determine if the listeners are removed (true) or added (false).
   * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
   * You can also pass it an event name and an array of listeners to be added/removed.
   * You can also pass it a regular expression to manipulate the listeners of all events that match it.
   *
   * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
   * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
   * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
   * @return {Object} Current instance of EventEmitter for chaining.
   */
  proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
    var i;
    var value;
    var single = remove ? this.removeListener : this.addListener;
    var multiple = remove ? this.removeListeners : this.addListeners;

    // If evt is an object then pass each of its properties to this method
    if ((typeof evt === 'undefined' ? 'undefined' : _typeof(evt)) === 'object' && !(evt instanceof RegExp)) {
      for (i in evt) {
        if (evt.hasOwnProperty(i) && (value = evt[i])) {
          // Pass the single listener straight through to the singular method
          if (typeof value === 'function') {
            single.call(this, i, value);
          } else {
            // Otherwise pass back to the multiple function
            multiple.call(this, i, value);
          }
        }
      }
    } else {
      // So evt must be a string
      // And listeners must be an array of listeners
      // Loop over it and pass each one to the multiple method
      i = listeners.length;
      while (i--) {
        single.call(this, evt, listeners[i]);
      }
    }

    return this;
  };

  /**
   * Removes all listeners from a specified event.
   * If you do not specify an event then all listeners will be removed.
   * That means every event will be emptied.
   * You can also pass a regex to remove all events that match it.
   *
   * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
   * @return {Object} Current instance of EventEmitter for chaining.
   */
  proto.removeEvent = function removeEvent(evt) {
    var type = typeof evt === 'undefined' ? 'undefined' : _typeof(evt);
    var events = this._getEvents();
    var key;

    // Remove different things depending on the state of evt
    if (type === 'string') {
      // Remove all listeners for the specified event
      delete events[evt];
    } else if (evt instanceof RegExp) {
      // Remove all events matching the regex.
      for (key in events) {
        if (events.hasOwnProperty(key) && evt.test(key)) {
          delete events[key];
        }
      }
    } else {
      // Remove all listeners in all events
      delete this._events;
    }

    return this;
  };

  /**
   * Alias of removeEvent.
   *
   * Added to mirror the node API.
   */
  proto.removeAllListeners = alias('removeEvent');

  /**
   * Emits an event of your choice.
   * When emitted, every listener attached to that event will be executed.
   * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
   * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
   * So they will not arrive within the array on the other side, they will be separate.
   * You can also pass a regular expression to emit to all events that match it.
   *
   * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
   * @param {Array} [args] Optional array of arguments to be passed to each listener.
   * @return {Object} Current instance of EventEmitter for chaining.
   */
  proto.emitEvent = function emitEvent(evt, args) {
    var listeners = this.getListenersAsObject(evt);
    var listener;
    var i;
    var key;
    var response;

    for (key in listeners) {
      if (listeners.hasOwnProperty(key)) {
        i = listeners[key].length;

        while (i--) {
          // If the listener returns true then it shall be removed from the event
          // The function is executed either with a basic call or an apply if there is an args array
          listener = listeners[key][i];

          if (listener.once === true) {
            this.removeListener(evt, listener.listener);
          }

          response = listener.listener.apply(this, args || []);

          if (response === this._getOnceReturnValue()) {
            this.removeListener(evt, listener.listener);
          }
        }
      }
    }

    return this;
  };

  /**
   * Alias of emitEvent
   */
  proto.trigger = alias('emitEvent');

  /**
   * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
   * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
   *
   * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
   * @param {...*} Optional additional arguments to be passed to each listener.
   * @return {Object} Current instance of EventEmitter for chaining.
   */
  proto.emit = function emit(evt) {
    var args = Array.prototype.slice.call(arguments, 1);
    return this.emitEvent(evt, args);
  };

  /**
   * Sets the current value to check against when executing listeners. If a
   * listeners return value matches the one set here then it will be removed
   * after execution. This value defaults to true.
   *
   * @param {*} value The new value to check for when executing listeners.
   * @return {Object} Current instance of EventEmitter for chaining.
   */
  proto.setOnceReturnValue = function setOnceReturnValue(value) {
    this._onceReturnValue = value;
    return this;
  };

  /**
   * Fetches the current value to check against when executing listeners. If
   * the listeners return value matches this one then it should be removed
   * automatically. It will return true by default.
   *
   * @return {*|Boolean} The current value to check for or the default, true.
   * @api private
   */
  proto._getOnceReturnValue = function _getOnceReturnValue() {
    if (this.hasOwnProperty('_onceReturnValue')) {
      return this._onceReturnValue;
    } else {
      return true;
    }
  };

  /**
   * Fetches the events object and creates one if required.
   *
   * @return {Object} The events storage object.
   * @api private
   */
  proto._getEvents = function _getEvents() {
    return this._events || (this._events = {});
  };

  exports.default = EventEmitter;
  module.exports = exports['default'];
});

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(56), __webpack_require__(5), __webpack_require__(46)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('../dependencies/eventEmitter/EventEmitter.js'), require('../graph.util.js'), require('../util/waveform.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.EventEmitter, global.graphUtil, global.waveform);
    global.graphSerie = mod.exports;
  }
})(this, function (module, exports, _EventEmitter2, _graphUtil, _waveform) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _EventEmitter3 = _interopRequireDefault(_EventEmitter2);

  var util = _interopRequireWildcard(_graphUtil);

  var _waveform2 = _interopRequireDefault(_waveform);

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var Serie = function (_EventEmitter) {
    _inherits(Serie, _EventEmitter);

    _createClass(Serie, null, [{
      key: 'default',
      value: function _default() {

        return {
          redrawShapesAfterDraw: false
        };
      }
    }]);

    function Serie(graph, name, options) {
      _classCallCheck(this, Serie);

      var _this = _possibleConstructorReturn(this, (Serie.__proto__ || Object.getPrototypeOf(Serie)).apply(this, arguments));

      _this.graph = graph;
      _this.name = name;
      _this.options = Object.assign({}, Serie.default(), _this.constructor.default(), options);

      //if( new.target.default ) {
      //console.log( new.target.default() );
      //}

      return _this;
    }

    _createClass(Serie, [{
      key: 'postInit',
      value: function postInit() {}
    }, {
      key: 'draw',
      value: function draw() {}
    }, {
      key: 'beforeDraw',
      value: function beforeDraw() {}
    }, {
      key: 'afterDraw',
      value: function afterDraw() {

        if (this.options.redrawShapesAfterDraw) {
          this.graph.getShapesOfSerie(this).forEach(function (shape) {
            shape.redraw();
          });
        }

        this.emit('draw');
      }
    }, {
      key: 'setData',
      value: function setData(data, oneDimensional, type) {

        if (data instanceof _waveform2.default) {
          return this.setWaveform(data);
        }

        throw 'Setting data other than waveforms in not supported by default. You must implemented this method in the inherited class.';
      }
    }, {
      key: '_addData',
      value: function _addData(type, howmany) {
        return [];
      }
    }, {
      key: 'clearData',
      value: function clearData() {
        this.setData(new _waveform2.default());
        return this;
      }
    }, {
      key: 'getData',
      value: function getData() {
        return this.data;
      }
    }, {
      key: 'setOptions',
      value: function setOptions(options) {
        this.options = options || {};
      }
    }, {
      key: 'setOption',
      value: function setOption(name, value) {
        this.options[name] = value;
      }
    }, {
      key: 'kill',
      value: function kill(noLegendUpdate) {

        this.graph.removeSerieFromDom(this);
        this.graph._removeSerie(this);

        if (this.graph.legend && !noLegendUpdate) {

          this.graph.legend.update();
        }

        this.graph = undefined;
        return this;
      }
    }, {
      key: 'hide',
      value: function hide(hideShapes) {
        var mute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;


        this.hidden = true;
        this.groupMain.setAttribute('display', 'none');

        this.getSymbolForLegend().setAttribute('opacity', 0.5);
        this.getTextForLegend().setAttribute('opacity', 0.5);

        this.hideImpl();

        if (hideShapes) {
          var shapes = this.graph.getShapesOfSerie(this);
          for (var i = 0, l = shapes.length; i < l; i++) {
            shapes[i].hide();
          }
        }

        if (!mute) {
          this.emit('hide');
        }

        if (this.getXAxis().doesHideWhenNoSeriesShown() || this.getYAxis().doesHideWhenNoSeriesShown()) {
          this.graph.draw(true);
        }

        if (this.graph.hasPlugin('peakPicking') && this.graph.getPlugin('peakPicking').getSerie() == this) {
          this.graph.getPlugin('peakPicking').hidePeakPicking();
        }

        return this;
      }
    }, {
      key: 'show',
      value: function show(showShapes) {
        var mute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;


        this.hidden = false;
        this.groupMain.setAttribute('display', 'block');

        this.getSymbolForLegend().setAttribute('opacity', 1);
        this.getTextForLegend().setAttribute('opacity', 1);

        this.showImpl();

        this.draw(true);

        if (showShapes) {
          var shapes = this.graph.getShapesOfSerie(this);
          for (var i = 0, l = shapes.length; i < l; i++) {
            shapes[i].show();
          }
        }

        if (!mute) {
          this.emit('show');
        }

        if (this.getXAxis().doesHideWhenNoSeriesShown() || this.getYAxis().doesHideWhenNoSeriesShown()) {
          this.graph.draw(true);
        }

        if (this.graph.hasPlugin('peakPicking') && this.graph.getPlugin('peakPicking').getSerie() == this) {
          this.graph.getPlugin('peakPicking').showPeakPicking();
        }

        return this;
      }
    }, {
      key: 'hideImpl',
      value: function hideImpl() {}
    }, {
      key: 'showImpl',
      value: function showImpl() {}
    }, {
      key: 'toggleDisplay',
      value: function toggleDisplay() {

        if (!this.isShown()) {
          this.show();
        } else {
          this.hide();
        }

        return this;
      }
    }, {
      key: 'isShown',
      value: function isShown() {
        return !this.hidden;
      }
    }, {
      key: 'axisCheck',
      value: function axisCheck() {

        if (!this.getXAxis() || !this.getYAxis()) {
          throw 'No axis exist for this serie. Check that they were properly assigned';
        }

        if (isNaN(this.getXAxis().getCurrentMin()) || isNaN(this.getXAxis().getCurrentMax()) || isNaN(this.getYAxis().getCurrentMin()) || isNaN(this.getYAxis().getCurrentMax())) {
          throw 'Axis min and max values are not defined. Try autoscaling';
        }
      }
    }, {
      key: 'getX',
      value: function getX(val) {
        return (val = this.getXAxis().getPx(val)) - val % 0.2;
      }
    }, {
      key: 'getY',
      value: function getY(val) {
        return (val = this.getYAxis().getPx(val)) - val % 0.2;
      }
    }, {
      key: 'isSelected',
      value: function isSelected() {
        return this.selected || this.selectionType !== 'unselected';
      }
    }, {
      key: '_checkX',
      value: function _checkX(val) {
        this.minX = Math.min(this.minX, val);
        this.maxX = Math.max(this.maxX, val);
      }
    }, {
      key: '_checkY',
      value: function _checkY(val) {
        this.minY = Math.min(this.minY, val);
        this.maxY = Math.max(this.maxY, val);
      }
    }, {
      key: 'getName',
      value: function getName() {
        return this.name;
      }
    }, {
      key: 'autoAxis',
      value: function autoAxis() {

        if (this.isFlipped()) {

          this.setXAxis(this.graph.getYAxis());
          this.setYAxis(this.graph.getXAxis());
        } else {

          this.setXAxis(this.graph.getXAxis());
          this.setYAxis(this.graph.getYAxis());
        }

        // After axes have been assigned, the graph axes should update their min/max
        this.graph.updateDataMinMaxAxes();
        return this;
      }
    }, {
      key: 'autoAxes',
      value: function autoAxes() {
        return this.autoAxis.apply(this, arguments);
      }
    }, {
      key: 'setXAxis',
      value: function setXAxis(axis) {

        if (typeof axis == 'number') {
          this.xaxis = this.isFlipped() ? this.graph.getYAxis(axis) : this.graph.getXAxis(axis);
        } else {
          this.xaxis = axis;
        }

        this.graph.updateDataMinMaxAxes();

        return this;
      }
    }, {
      key: 'setYAxis',
      value: function setYAxis(axis) {
        if (typeof axis == 'number') {
          this.xaxis = this.isFlipped() ? this.graph.getXAxis(axis) : this.graph.getYAxis(axis);
        } else {
          this.yaxis = axis;
        }

        this.graph.updateDataMinMaxAxes();

        return this;
      }
    }, {
      key: 'setAxes',
      value: function setAxes() {

        for (var i = 0; i < 2; i++) {

          if (arguments[i]) {
            this[arguments[i].isX() ? 'setXAxis' : 'setYAxis'](arguments[i]);
          }
        }

        this.graph.updateDataMinMaxAxes();

        return this;
      }
    }, {
      key: 'getXAxis',
      value: function getXAxis() {
        return this.xaxis;
      }
    }, {
      key: 'getYAxis',
      value: function getYAxis() {
        return this.yaxis;
      }
    }, {
      key: 'getMinX',
      value: function getMinX() {
        return this.minX;
      }
    }, {
      key: 'getMaxX',
      value: function getMaxX() {
        return this.maxX;
      }
    }, {
      key: 'getMinY',
      value: function getMinY() {
        return this.minY;
      }
    }, {
      key: 'getMaxY',
      value: function getMaxY() {
        return this.maxY;
      }
    }, {
      key: 'getWaveform',
      value: function getWaveform() {
        return this.waveform;
      }
    }, {
      key: 'getWaveforms',
      value: function getWaveforms() {
        return [this.waveform];
      }
    }, {
      key: 'setWaveform',
      value: function setWaveform(waveform) {

        if (!(waveform instanceof _waveform2.default)) {
          console.trace();
          console.error(waveform);
          throw new Error('Cannot assign waveform to serie. Waveform is not of the proper Waveform instance');
        }

        this.waveform = waveform;

        this.minX = this.waveform.getXMin();
        this.maxX = this.waveform.getXMax();
        this.minY = this.waveform.getMin();
        this.maxY = this.waveform.getMax();

        this.graph.updateDataMinMaxAxes();
        this.dataHasChanged();

        return this;
      }
    }, {
      key: 'getSymbolForLegend',
      value: function getSymbolForLegend() {

        if (!this.lineForLegend) {

          var line = document.createElementNS(this.graph.ns, 'line');
          this.applyLineStyle(line);

          line.setAttribute('x1', 5);
          line.setAttribute('x2', 25);
          line.setAttribute('y1', 0);
          line.setAttribute('y2', 0);

          line.setAttribute('cursor', 'pointer');

          this.lineForLegend = line;
        }

        return this.lineForLegend;
      }
    }, {
      key: 'setLegendSymbolStyle',
      value: function setLegendSymbolStyle() {
        this.applyLineStyle(this.getSymbolForLegend());
      }
    }, {
      key: 'updateStyle',
      value: function updateStyle() {
        this.setLegendSymbolStyle();
        this.graph.updateLegend();
      }
    }, {
      key: 'getTextForLegend',
      value: function getTextForLegend() {

        if (!this.textForLegend) {

          var text = document.createElementNS(this.graph.ns, 'text');
          text.setAttribute('cursor', 'pointer');
          text.textContent = this.getLabel();

          this.textForLegend = text;
        }

        return this.textForLegend;
      }
    }, {
      key: 'getIndex',
      value: function getIndex() {
        return this.graph.series.indexOf(this);
      }
    }, {
      key: 'getLabel',
      value: function getLabel() {
        return this.options.label || this.name;
      }
    }, {
      key: 'setLabel',
      value: function setLabel(label) {
        this.options.label = label;

        if (this.textForLegend) {
          this.textForLegend.textContent = label;
        }

        this.graph.requireLegendUpdate();
        return this;
      }
    }, {
      key: 'setFlip',
      value: function setFlip(flipped) {
        this.options.flip = flipped;
        return this;
      }
    }, {
      key: 'getFlip',
      value: function getFlip() {
        return this.options.flip;
      }
    }, {
      key: 'isFlipped',
      value: function isFlipped() {
        return this.options.flip;
      }
    }, {
      key: 'setLayer',
      value: function setLayer(layerIndex) {
        var newLayer = parseInt(layerIndex) || 1;

        if (newLayer !== this.options.layer) {
          this.options.layer = newLayer;
          this.graph.appendSerieToDom(this);
        }

        return this;
      }
    }, {
      key: 'getLayer',
      value: function getLayer() {
        return this.options.layer || 1;
      }
    }, {
      key: 'setStyle',
      value: function setStyle(style) {
        var selectionType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'unselected';

        this.styles[selectionType] = style;
        this.styleHasChanged(selectionType);
      }
    }, {
      key: 'styleHasChanged',
      value: function styleHasChanged() {
        var selectionType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'unselected';

        this._changedStyles = this._changedStyles || {};

        if (selectionType === false) {
          for (var i in this._changedStyles) {
            this._changedStyles[i] = false;
          }
        } else {
          this._changedStyles[selectionType || 'unselected'] = true;
        }

        this.graph.requireLegendUpdate();
        return this;
      }
    }, {
      key: 'hasStyleChanged',
      value: function hasStyleChanged(selectionType) {
        this._changedStyles = this._changedStyles || {};
        return this._changedStyles[selectionType || 'unselected'];
      }
    }, {
      key: 'dataHasChanged',
      value: function dataHasChanged(arg) {
        this._dataHasChanged = arg === undefined || arg;
        return this;
      }
    }, {
      key: 'hasDataChanged',
      value: function hasDataChanged() {
        return this._dataHasChanged;
      }
    }, {
      key: 'setInfo',
      value: function setInfo(prop, value) {
        this.infos = this.infos || {};
        this.infos[prop] = value;
        return this;
      }
    }, {
      key: 'getInfo',
      value: function getInfo(prop, value) {
        return (this.infos || {})[prop];
      }
    }, {
      key: 'setAdditionalData',
      value: function setAdditionalData(data) {
        this.additionalData = data;
        return this;
      }
    }, {
      key: 'getAdditionalData',
      value: function getAdditionalData() {
        return this.additionalData;
      }
    }, {
      key: 'select',
      value: function select() {
        this.selected = true;
        return this;
      }
    }, {
      key: 'unselect',
      value: function unselect() {
        this.selected = false;
        return this;
      }
    }, {
      key: 'enableTracking',
      value: function enableTracking(hoverCallback, outCallback) {
        this._tracker = true;
        this._trackingCallback = hoverCallback;
        this._trackingOutCallback = outCallback;

        return this;
      }
    }, {
      key: 'disableTracking',
      value: function disableTracking() {

        if (this._trackerDom) {
          this._trackerDom.remove();
          this._trackerDom = null;
        }

        this._tracker = false;
        this._trackingCallback = null;
        return this;
      }
    }, {
      key: 'allowTrackingLine',
      value: function allowTrackingLine(options) {

        options = options || {};
        this.graph.addSerieToTrackingLine(this, options);
      }
    }, {
      key: 'getMarkerForLegend',
      value: function getMarkerForLegend() {
        return false;
      }
    }, {
      key: 'getType',
      value: function getType() {
        return this._type;
      }
    }, {
      key: 'setDataIndices',
      value: function setDataIndices(categories, nb) {
        this.categoryIndices = categories;
        this.nbCategories = nb;
      }
    }, {
      key: 'hasErrors',
      value: function hasErrors() {
        if (!this.waveform) {
          return false;
        }

        return this.waveform.hasErrorBars();
      }
    }, {
      key: 'type',
      get: function get() {
        return this._type;
      }
    }, {
      key: 'excludedFromLegend',
      set: function set(bln) {
        this._excludedFromLegend = bln;
      },
      get: function get() {
        return !!this._excludedFromLegend;
      }
    }]);

    return Serie;
  }(_EventEmitter3.default);

  exports.default = Serie;
  module.exports = exports['default'];
});

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(19);
var global = __webpack_require__(2);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(33) ? 'pure' : 'global',
  copyright: ' 2018 Denis Pushkarev (zloirock.ru)'
});


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(16);
var toLength = __webpack_require__(9);
var toAbsoluteIndex = __webpack_require__(38);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 60 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(21);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(4);
var cof = __webpack_require__(21);
var MATCH = __webpack_require__(6)('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(6)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.2.5.3 get RegExp.prototype.flags
var anObject = __webpack_require__(1);
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var hide = __webpack_require__(12);
var redefine = __webpack_require__(13);
var fails = __webpack_require__(3);
var defined = __webpack_require__(24);
var wks = __webpack_require__(6);

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var fns = exec(defined, SYMBOL, ''[KEY]);
  var strfn = fns[0];
  var rxfn = fns[1];
  if (fails(function () {
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  })) {
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(1);
var aFunction = __webpack_require__(11);
var SPECIES = __webpack_require__(6)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(2);
var $export = __webpack_require__(0);
var redefine = __webpack_require__(13);
var redefineAll = __webpack_require__(44);
var meta = __webpack_require__(32);
var forOf = __webpack_require__(43);
var anInstance = __webpack_require__(42);
var isObject = __webpack_require__(4);
var fails = __webpack_require__(3);
var $iterDetect = __webpack_require__(63);
var setToStringTag = __webpack_require__(47);
var inheritIfRequired = __webpack_require__(82);

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var hide = __webpack_require__(12);
var uid = __webpack_require__(36);
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Forced replacement prototype accessors methods
module.exports = __webpack_require__(33) || !__webpack_require__(3)(function () {
  var K = Math.random();
  // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call
  __defineSetter__.call(null, K, function () { /* empty */ });
  delete __webpack_require__(2)[K];
});


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(0);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(0);
var aFunction = __webpack_require__(11);
var ctx = __webpack_require__(20);
var forOf = __webpack_require__(43);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(45), __webpack_require__(56), __webpack_require__(5)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('./graph.core.js'), require('./dependencies/eventEmitter/EventEmitter.js'), require('./graph.util.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphCore, global.EventEmitter, global.graphUtil);
    global.graphAxis = mod.exports;
  }
})(this, function (module, exports, _graphCore, _EventEmitter2, _graphUtil) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _graphCore2 = _interopRequireDefault(_graphCore);

  var _EventEmitter3 = _interopRequireDefault(_EventEmitter2);

  var util = _interopRequireWildcard(_graphUtil);

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  /**
   * Default graph parameters
   * @name AxisOptionsDefault
   * @object
   * @static
   * @memberof Axis
   * @prop {Boolean} display - Whether to display or not the axis
   * @prop {Boolean} flipped - Flips the axis (maximum and minimum will be inverted)
   * @prop {Numner} axisDataSpacing.min - The spacing of the at the bottom of the axis. The value is multiplied by the (max - min) values given by the series (0.1 means 10% of the serie width / height).
   * @prop {Number} axisDataSpacing.max - The spacing of the at the top of the axis. The value is multiplied by the (max - min) values given by the series (0.1 means 10% of the serie width / height).
   * @prop {String} unitModification - Used to change the units of the axis in a defined way. Currently, "time" and "time:min.sec" are supported. They will display the value in days, hours, minutes and seconds and the data should be expressed in seconds.
   * @prop {Boolean} primaryGrid - Whether or not to display the primary grid (on the main ticks)
   * @prop {Boolean} secondaryGrid - Whether or not to display the secondary grid (on the secondary ticks)
   * @prop {Number} tickPosition - Sets the position of the ticks with regards to the axis ( 1 = inside, 2 = centered, 3 = outside ).
   * @prop {Number} nbTicksPrimary - The number of primary ticks to use (approximately)
   * @prop {Number} nbTicksSecondary - The number of secondary ticks to use (approximately)
   * @prop {Number} ticklabelratio - Scaling factor on the labels under each primary ticks
   * @prop {Number} exponentialFactor - Scales the labels under each primary ticks by 10^(exponentialFactor)
   * @prop {Number} exponentialLabelFactor - Scales the axis label by 10^(exponentialFactor)
   * @prop {Boolean} logScale - Display the axis in log scale (base 10)
   * @prop {(Number|Boolean)} forcedMin - Use a number to force the minimum value of the axis (becomes independant of its series)
   * @prop {(Number|Boolean)} forcedMax - Use a number to force the maximum value of the axis (becomes independant of its series)
   */
  var defaults = {
    lineAt: false,
    display: true,
    flipped: false,
    axisDataSpacing: {
      min: 0.1,
      max: 0.1
    },
    unitModification: false,
    primaryGrid: true,
    secondaryGrid: true,

    primaryGridColor: '#f0f0f0',
    secondaryGridColor: '#f0f0f0',

    primaryGridWidth: 1,
    secondaryGridWidth: 1,

    hideWhenNoSeriesShown: false,
    shiftToZero: false,
    tickPosition: 1,
    nbTicksPrimary: 3,
    nbTicksSecondary: 10,
    ticklabelratio: 1,
    exponentialFactor: 0,
    exponentialLabelFactor: 0,
    logScale: false,
    forcedMin: false,
    forcedMax: false,

    span: [0, 1],
    marginMin: 0,
    marginMax: 0,

    scientificScale: false,
    scientificScaleExponent: false,
    engineeringScale: false,

    unitInTicks: false,
    unit: false,
    unitWrapperBefore: '',
    unitWrapperAfter: '',

    splitMarks: false,

    tickLabelOffset: 0,

    useKatexForLabel: false,

    highestMax: false,
    lowestMin: false
  };

  /**
   * Axis constructor. Usually not instanced directly, but for custom made axes, that's possible
   * @class Axis
   * @static
   * @augments EventEmitter
   * @example function myAxis() {};
   * myAxis.prototype = new Graph.getConstructor("axis");
   * graph.setBottomAxis( new myAxis( { } ) );
   */

  var Axis = function (_EventEmitter) {
    _inherits(Axis, _EventEmitter);

    function Axis() {
      _classCallCheck(this, Axis);

      return _possibleConstructorReturn(this, (Axis.__proto__ || Object.getPrototypeOf(Axis)).call(this));
    }

    _createClass(Axis, [{
      key: 'init',
      value: function init(graph, options, overwriteoptions) {
        var _this2 = this;

        this.unitModificationTimeTicks = [[1, [1, 2, 5, 10, 20, 30]], [60, [1, 2, 5, 10, 20, 30]], [3600, [1, 2, 6, 12]], [3600 * 24, [1, 2, 3, 4, 5, 10, 20, 40]]];

        this.graph = graph;
        this.options = util.extend(true, {}, defaults, overwriteoptions, options);

        this.group = document.createElementNS(this.graph.ns, 'g');
        this.hasChanged = true;

        this.rectEvent = document.createElementNS(this.graph.ns, 'rect');
        this.rectEvent.setAttribute('pointer-events', 'fill');
        this.rectEvent.setAttribute('fill', 'transparent');
        this.group.appendChild(this.rectEvent);

        this.graph.axisGroup.appendChild(this.group); // Adds to the main axiszone

        // Lines at a certain value
        this._lines = [];

        this.line = document.createElementNS(this.graph.ns, 'line');
        this.line.setAttribute('stroke', 'black');
        this.line.setAttribute('shape-rendering', 'crispEdges');
        this.line.setAttribute('stroke-linecap', 'square');
        this.groupTicks = document.createElementNS(this.graph.ns, 'g');
        this.groupTickLabels = document.createElementNS(this.graph.ns, 'g');

        this.group.appendChild(this.groupTicks);
        this.group.appendChild(this.groupTickLabels);
        this.group.appendChild(this.line);

        this.label = document.createElementNS(this.graph.ns, 'text');

        this.labelTspan = document.createElementNS(this.graph.ns, 'tspan'); // Contains the main label
        this.preunit = ''; //document.createElementNS( this.graph.ns, 'tspan' ); // Contains the scaling unit
        this.unitTspan = document.createElementNS(this.graph.ns, 'tspan'); // Contains the unit
        this.expTspan = document.createElementNS(this.graph.ns, 'tspan'); // Contains the exponent (x10)
        this.expTspanExp = document.createElementNS(this.graph.ns, 'tspan'); // Contains the exponent value

        this.label.appendChild(this.labelTspan);
        //this.label.appendChild( this.preunitTspan );
        this.label.appendChild(this.unitTspan);
        this.label.appendChild(this.expTspan);
        this.label.appendChild(this.expTspanExp);

        this.expTspan.setAttribute('dx', 6);
        this.expTspanExp.setAttribute('dy', -5);
        this.expTspanExp.setAttribute('font-size', '0.8em');

        this.label.setAttribute('text-anchor', 'middle');

        this.setTickPosition(this.options.tickPosition);

        this.gridLinePath = {
          primary: '',
          secondary: ''
        };

        this.gridPrimary = document.createElementNS(this.graph.ns, 'path');
        this.gridSecondary = document.createElementNS(this.graph.ns, 'path');

        this.graph.groupPrimaryGrids.appendChild(this.gridPrimary);
        this.graph.groupSecondaryGrids.appendChild(this.gridSecondary);

        this.setGridLinesStyle();

        this.group.appendChild(this.label);

        this.groupSeries = document.createElementNS(this.graph.ns, 'g');
        this.group.appendChild(this.groupSeries);

        this.widthHeightTick = 0;

        this.ticks = {};
        this.ticksLabels = [];
        this.tickScaling = {
          1: 3,
          2: 2,
          3: 1,
          4: 0.5
        };

        this.currentTick = {};
        this.lastCurrentTick = {};

        this.series = [];
        this.totalDelta = 0;
        this.currentAction = false;

        this.group.addEventListener('mousemove', function (e) {
          e.preventDefault();
          var coords = _this2.graph._getXY(e);
          _this2.handleMouseMoveLocal(coords.x, coords.y, e);

          for (var i = 0, l = _this2.series.length; i < l; i++) {
            _this2.series[i].handleMouseMove(false, true);
          }
        });

        this.labels = [];
        this.group.addEventListener('click', function (e) {
          e.preventDefault();
          var coords = _this2.graph._getXY(e);
          _this2.addLabel(_this2.getVal(coords.x - _this2.graph.getPaddingLeft()));
        });

        //this.clip = document.createElementNS( this.graph.ns, 'clipPath' );
        //this.clip.setAttribute( 'id', '_clip' + this.axisRand );
        //this.graph.defs.appendChild( this.clip );
        /*
            this.clipRect = document.createElementNS( this.graph.ns, 'rect' );
            this.clip.appendChild( this.clipRect );
            this.clip.setAttribute( 'clipPathUnits', 'userSpaceOnUse' );
        */
        this.gridPrimary.setAttribute('clip-path', 'url(#_clipplot' + this.graph._creation + ')');
        this.gridSecondary.setAttribute('clip-path', 'url(#_clipplot' + this.graph._creation + ')');
        this.graph._axisHasChanged(this);
      }
    }, {
      key: 'handleMouseMoveLocal',
      value: function handleMouseMoveLocal() {}
    }, {
      key: 'hide',
      value: function hide() {
        this.options.display = false;
        return this;
      }
    }, {
      key: 'show',
      value: function show() {
        this.options.display = true;
        return this;
      }
    }, {
      key: 'setDisplay',
      value: function setDisplay(bool) {
        this.options.display = !!bool;
        return this;
      }
    }, {
      key: 'isDisplayed',
      value: function isDisplayed() {

        if (!this.options.hideWhenNoSeriesShown) {
          return this.options.display;
        }

        return this.graph.getSeriesFromAxis(this).reduce(function (accumulator, serie) {
          return accumulator || serie.isShown();
        }, false);
      }
    }, {
      key: 'isShown',
      value: function isShown() {

        return this.isDisplayed.apply(this, arguments);
      }
    }, {
      key: 'hideGroup',
      value: function hideGroup() {
        if (this._hidden) {
          return;
        }
        this._hidden = true;
        this.group.setAttribute('display', 'none');
      }
    }, {
      key: 'showGroup',
      value: function showGroup() {
        if (!this._hidden) {
          return;
        }
        this._hidden = false;
        this.group.setAttribute('display', 'initial');
      }
    }, {
      key: 'kill',
      value: function kill(noRedraw, noSerieKill) {
        this.graph.killAxis(this, noRedraw, noSerieKill);
      }
    }, {
      key: 'setLineAt',
      value: function setLineAt(atValues) {
        this.options.lineAt = atValues;
        return this;
      }
    }, {
      key: 'adaptTo',
      value: function adaptTo(axis, thisValue, foreignValue, preference) {

        if (!axis) {
          this.options.adaptTo = false;
          return this;
        }

        this.options.adaptTo = {
          axis: axis,
          thisValue: thisValue,
          foreignValue: foreignValue,
          preference: preference
        };

        this.adapt();

        return this;
      }
    }, {
      key: 'adapt',
      value: function adapt() {

        if (!this.options.adaptTo) {
          return;
        }

        var axis = this.options.adaptTo.axis,
            current = this.options.adaptTo.thisValue,
            foreign = this.options.adaptTo.foreignValue;

        if (axis.currentAxisMin === undefined || axis.currentAxisMax === undefined) {
          axis.setMinMaxToFitSeries();
        }

        if (this.options.forcedMin !== false && this.options.forcedMax == false || this.options.adaptTo.preference !== 'max') {

          if (this.options.forcedMin !== false) {
            this.currentAxisMin = this.options.forcedMin;
          } else {
            this.currentAxisMin = this._zoomed ? this.getCurrentMin() : this.getMinValue() - (current - this.getMinValue()) * (this.options.axisDataSpacing.min * (axis.getCurrentMax() - axis.getCurrentMin()) / (foreign - axis.getCurrentMin()));
          }

          if (this.currentAxisMin == current) {
            this.currentAxisMin -= this.options.axisDataSpacing.min * this.getInterval();
          }

          var use = this.options.forcedMin !== false ? this.options.forcedMin : this.currentAxisMin;
          this.currentAxisMax = (current - use) * (axis.getCurrentMax() - axis.getCurrentMin()) / (foreign - axis.getCurrentMin()) + use;
        } else {

          if (this.options.forcedMax !== false) {
            this.currentAxisMax = this.options.forcedMax;
          } else {
            this.currentAxisMax = this._zoomed ? this.getCurrentMax() : this.getMaxValue() + (this.getMaxValue() - current) * (this.options.axisDataSpacing.max * (axis.getCurrentMax() - axis.getCurrentMin()) / (axis.getCurrentMax() - foreign));
          }

          if (this.currentAxisMax == current) {
            this.currentAxisMax += this.options.axisDataSpacing.max * this.getInterval();
          }

          var use = this.options.forcedMax !== false ? this.options.forcedMax : this.currentAxisMax;

          this.currentAxisMin = (current - use) * (axis.getCurrentMin() - axis.getCurrentMax()) / (foreign - axis.getCurrentMax()) + use;
        }

        this.graph._axisHasChanged(this);
      }
    }, {
      key: 'setFloating',
      value: function setFloating(axis, value) {

        this.floating = true;
        this.floatingAxis = axis;
        this.floatingValue = value;

        return this;
      }
    }, {
      key: 'getFloatingAxis',
      value: function getFloatingAxis() {
        return this.floatingAxis;
      }
    }, {
      key: 'getFloatingValue',
      value: function getFloatingValue() {
        return this.floatingValue;
      }
    }, {
      key: 'setAxisDataSpacing',
      value: function setAxisDataSpacing(val1, val2) {
        this.options.axisDataSpacing.min = val1;
        this.options.axisDataSpacing.max = val2 || val1;
        return this;
      }
    }, {
      key: 'dataSpacing',
      value: function dataSpacing() {
        return this.setAxisDataSpacing.apply(this, arguments);
      }
    }, {
      key: 'setAxisDataSpacingMin',
      value: function setAxisDataSpacingMin(val) {
        this.options.axisDataSpacing.min = val;
      }
    }, {
      key: 'setAxisDataSpacingMax',
      value: function setAxisDataSpacingMax(val) {
        this.options.axisDataSpacing.max = val;
      }
    }, {
      key: 'setMinPx',
      value: function setMinPx(px) {

        this.minPx = px;
        this.setMinMaxFlipped();
      }
    }, {
      key: 'setMaxPx',
      value: function setMaxPx(px) {

        this.maxPx = px;
        this.setMinMaxFlipped();
      }
    }, {
      key: 'getMinPx',
      value: function getMinPx() {
        return this.minPxFlipped;
      }
    }, {
      key: 'getMaxPx',
      value: function getMaxPx() {
        return this.maxPxFlipped;
      }
    }, {
      key: 'getMathMaxPx',
      value: function getMathMaxPx() {
        return this.maxPx;
      }
    }, {
      key: 'getMathMinPx',
      value: function getMathMinPx() {
        return this.minPx;
      }
    }, {
      key: 'getMinValue',
      value: function getMinValue() {
        return this.options.forcedMin !== false ? this.options.forcedMin : this.options.lowestMin !== false ? Math.max(this.options.lowestMin, this.dataMin) : this.dataMin;
      }
    }, {
      key: 'getMaxValue',
      value: function getMaxValue() {
        return this.options.forcedMax !== false ? this.options.forcedMax : this.options.highestMax !== false ? Math.min(this.options.highestMax, this.dataMax) : this.dataMax;
      }
    }, {
      key: 'setMinValueData',
      value: function setMinValueData(min) {
        this.dataMin = min;

        // 25.10.2017. This is to help in the case there's no autoscaling
        if (isNaN(this.getCurrentMin())) {
          //this.setCurrentMin( this.getMinValue() );
          //this.cache();

        }
      }
    }, {
      key: 'setMaxValueData',
      value: function setMaxValueData(max) {
        this.dataMax = max;

        // 25.10.2017. This is to help in the case there's no autoscaling
        // 02.02.2018. Don't agree with this. Next time, put a link to show the use of this piece of code
        if (isNaN(this.getCurrentMax())) {
          //     this.setCurrentMax( this.getMaxValue() );
          //this.cache();

        }
      }
    }, {
      key: 'getDataMax',
      value: function getDataMax() {
        return this.dataMax;
      }
    }, {
      key: 'getDataMin',
      value: function getDataMin() {
        return this.dataMin;
      }
    }, {
      key: 'setLowestMin',
      value: function setLowestMin(lowestMin) {
        this.options.lowestMin = lowestMin;
        this.graph._axisHasChanged(this);
      }
    }, {
      key: 'forceMin',
      value: function forceMin(min) {
        var noRescale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        this.options.forcedMin = min;
        this.setCurrentMin(noRescale ? this.getCurrentMin() : undefined);
        this.graph._axisHasChanged(this);
        return this;
      }
    }, {
      key: 'setHighestMax',
      value: function setHighestMax(highestMax) {
        this.options.highestMax = highestMax;
        this.graph._axisHasChanged(this);
      }
    }, {
      key: 'forceMax',
      value: function forceMax(max) {
        var noRescale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        this.options.forcedMax = max;
        this.setCurrentMax(noRescale ? this.getCurrentMax() : undefined);
        this.graph._axisHasChanged(this);
        return this;
      }
    }, {
      key: 'getForcedMin',
      value: function getForcedMin() {
        return this.options.forcedMin;
      }
    }, {
      key: 'getForcedMax',
      value: function getForcedMax() {
        return this.options.forcedMax;
      }
    }, {
      key: 'forceToAxis',
      value: function forceToAxis(axis) {
        if (axis.getMaxValue && axis.getMinValue) {
          this.options.forcedMin = axis.getMinValue();
          this.options.forcedMax = axis.getMaxValue();
        }

        return this;
      }
    }, {
      key: 'getNbTicksPrimary',
      value: function getNbTicksPrimary() {
        return this.options.nbTicksPrimary;
      }
    }, {
      key: 'setNbTicksPrimary',
      value: function setNbTicksPrimary(nb) {
        this.options.nbTicksPrimary = nb;
      }
    }, {
      key: 'getNbTicksSecondary',
      value: function getNbTicksSecondary() {
        return this.options.nbTicksSecondary;
      }
    }, {
      key: 'setNbTicksSecondary',
      value: function setNbTicksSecondary(nb) {
        this.options.nbTicksSecondary = nb;
        return this;
      }
    }, {
      key: 'handleMouseMove',
      value: function handleMouseMove(px) {
        this.mouseVal = this.getVal(px);
      }
    }, {
      key: 'handleMouseWheel',
      value: function handleMouseWheel(delta, e, baseline) {

        delta = Math.min(0.2, Math.max(-0.2, delta));

        if (baseline == 'min') {
          baseline = this.getMinValue();
        } else if (baseline == 'max') {
          baseline = this.getMaxValue();
        } else if (!baseline) {
          baseline = 0;
        }

        this._doZoomVal((this.getCurrentMax() - baseline) * (1 + delta) + baseline, (this.getCurrentMin() - baseline) * (1 + delta) + baseline);

        this.graph.draw();
        //	this.graph.drawSeries(true);
      }
    }, {
      key: 'zoom',
      value: function zoom(val1, val2, forceLock) {

        if (!forceLock && this.zoomLock) {
          return;
        }

        return this._doZoomVal(val1, val2, true);
      }
    }, {
      key: '_doZoomVal',
      value: function _doZoomVal(val1, val2, mute) {

        return this._doZoom(this.getPx(val1), this.getPx(val2), val1, val2, mute);
      }
    }, {
      key: '_doZoom',
      value: function _doZoom(px1, px2, val1, val2, mute) {

        //if(this.options.display || 1 == 1) {
        var val1 = val1 !== undefined ? val1 : this.getVal(px1);
        var val2 = val2 !== undefined ? val2 : this.getVal(px2);

        this.setCurrentMin(Math.min(val1, val2));
        this.setCurrentMax(Math.max(val1, val2));

        this.cacheCurrentMin();
        this.cacheCurrentMax();
        this.cacheInterval();

        this._zoomed = true;

        this.adapt();

        this._hasChanged = true;

        // New method
        if (!mute) {
          this.emit('zoom', [this.currentAxisMin, this.currentAxisMax, this]);
        }

        return this;
      }
    }, {
      key: 'getSerieShift',
      value: function getSerieShift() {
        return this._serieShift;
      }
    }, {
      key: 'getSerieScale',
      value: function getSerieScale() {
        return this._serieScale;
      }
    }, {
      key: 'getMouseVal',
      value: function getMouseVal() {
        return this.mouseVal;
      }
    }, {
      key: 'getUnitPerTick',
      value: function getUnitPerTick(px, nbTick, valrange) {

        var pxPerTick = px / nbTicks; // 1000 / 100 = 10 px per tick
        if (!nbTick) {
          nbTick = px / 10;
        } else {
          nbTick = Math.min(nbTick, px / 10);
        }

        // So now the question is, how many units per ticks ?
        // Say, we have 0.0004 unit per tick
        var unitPerTick = valrange / nbTick;

        switch (this.options.unitModification) {

          case 'time':
          case 'time:min.sec':
            {

              //const max = this.getModifiedValue( this.getMaxValue() );/*,
              /*units = [
                [ 60, 'min' ],
                [ 3600, 'h' ],
                [ 3600 * 24, 'd' ]
              ];*/

              var i = void 0,
                  l = void 0,
                  k = void 0,
                  m = void 0;
              var breaked = false;
              for (i = 0, l = this.unitModificationTimeTicks.length; i < l; i++) {
                for (k = 0, m = this.unitModificationTimeTicks[i][1].length; k < m; k++) {
                  if (unitPerTick < this.unitModificationTimeTicks[i][0] * this.unitModificationTimeTicks[i][1][k]) {
                    breaked = true;
                    break;
                  }
                }
                if (breaked) {
                  break;
                }
              }

              //i and k contain the good variable;
              if (i !== this.unitModificationTimeTicks.length) {
                unitPerTickCorrect = this.unitModificationTimeTicks[i][0] * this.unitModificationTimeTicks[i][1][k];
              } else {
                unitPerTickCorrect = 1;
              }

              break;
            }
          default:
            {

              // We take the log
              var decimals = Math.floor(Math.log(unitPerTick) / Math.log(10));
              /*
              Example:
              13'453 => Math.log10() = 4.12 => 4
              0.0000341 => Math.log10() = -4.46 => -5
              */

              var numberToNatural = unitPerTick * Math.pow(10, -decimals);

              /*
              Example:
              13'453 (4) => 1.345
              0.0000341 (-5) => 3.41
              */

              this.decimals = -decimals;

              var possibleTicks = [1, 2, 5, 10];
              var closest = false;
              for (var _i = possibleTicks.length - 1; _i >= 0; _i--) {
                if (!closest || Math.abs(possibleTicks[_i] - numberToNatural) < Math.abs(closest - numberToNatural)) {
                  closest = possibleTicks[_i];
                }
              }

              // Ok now closest is the number of unit per tick in the natural number
              /*
              Example:
              13'453 (4) (1.345) => 1
              0.0000341 (-5) (3.41) => 5
              */

              // Let's scale it back
              var unitPerTickCorrect = closest * Math.pow(10, decimals);

              /*
              Example:
              13'453 (4) (1.345) (1) => 10'000
              0.0000341 (-5) (3.41) (5) => 0.00005
              */
              break;
            }
        }

        var nbTicks = valrange / unitPerTickCorrect;

        var pxPerTick = px / nbTick;
        return [unitPerTickCorrect, nbTicks, pxPerTick];
      }
    }, {
      key: 'setMinMaxToFitSeries',
      value: function setMinMaxToFitSeries(noNotify) {

        var interval = this.getInterval();

        if (this.options.logScale) {

          this.currentAxisMin = Math.max(1e-50, this.getMinValue() * 0.9);
          this.currentAxisMax = Math.max(1e-50, this.getMaxValue() * 1.1);
        } else {

          this.currentAxisMin = this.getMinValue();
          this.currentAxisMax = this.getMaxValue();

          if (this.getForcedMin() === false) {
            this.currentAxisMin -= this.options.axisDataSpacing.min * interval;
          }

          if (this.getForcedMax() === false) {
            this.currentAxisMax += this.options.axisDataSpacing.max * interval;
          }
        }

        if (isNaN(this.currentAxisMin) || isNaN(this.currentAxisMax)) {
          this.currentAxisMax = undefined;
          this.currentAxisMin = undefined;
        }

        this.cache();

        this._zoomed = false;

        this.adapt();

        if (!noNotify) {
          this.graph._axisHasChanged(this);
        }

        this.emit('zoomOutFull', [this.currentAxisMin, this.currentAxisMax, this]);

        return this;
      }
    }, {
      key: 'getInterval',
      value: function getInterval() {
        return this.getMaxValue() - this.getMinValue();
      }
    }, {
      key: 'getCurrentInterval',
      value: function getCurrentInterval() {
        return this.cachedInterval;
      }
    }, {
      key: 'getCurrentMin',
      value: function getCurrentMin() {
        return this.cachedCurrentMin;
      }
    }, {
      key: 'getCurrentMax',
      value: function getCurrentMax() {
        return this.cachedCurrentMax;
      }
    }, {
      key: 'cacheCurrentMin',
      value: function cacheCurrentMin() {
        this.cachedCurrentMin = this.currentAxisMin == this.currentAxisMax ? this.options.logScale ? this.currentAxisMin / 10 : this.currentAxisMin - 1 : this.currentAxisMin;
      }
    }, {
      key: 'cacheCurrentMax',
      value: function cacheCurrentMax() {
        this.cachedCurrentMax = this.currentAxisMax == this.currentAxisMin ? this.options.logScale ? this.currentAxisMax * 10 : this.currentAxisMax + 1 : this.currentAxisMax;
      }
    }, {
      key: 'cacheInterval',
      value: function cacheInterval() {
        this.cachedInterval = this.cachedCurrentMax - this.cachedCurrentMin;
      }
    }, {
      key: 'cache',
      value: function cache() {
        this.cacheCurrentMin();
        this.cacheCurrentMax();
        this.cacheInterval();
      }
    }, {
      key: 'setCurrentMin',
      value: function setCurrentMin(val) {

        if (val === undefined || this.getForcedMin() !== false && (val < this.getForcedMin() || val < this.options.lowestMin || val === undefined)) {
          val = this.getMinValue();
        }
        this.currentAxisMin = val;
        if (this.options.logScale) {
          this.currentAxisMin = Math.max(1e-50, val);
        }

        this.cacheCurrentMin();
        this.cacheInterval();

        this.graph._axisHasChanged(this);
        return this;
      }
    }, {
      key: 'setCurrentMax',
      value: function setCurrentMax(val) {

        if (val === undefined || this.getForcedMax() !== false && (val > this.getForcedMax() || val > this.options.highestMax || val === undefined)) {
          val = this.getMaxValue();
        }

        this.currentAxisMax = val;

        if (this.options.logScale) {
          this.currentAxisMax = Math.max(1e-50, val);
        }

        this.cacheCurrentMax();
        this.cacheInterval();

        this.graph._axisHasChanged(this);
      }
    }, {
      key: 'flip',
      value: function flip(_flip) {
        this.options.flipped = _flip;
        this.setMinMaxFlipped();
        return this;
      }
    }, {
      key: 'isFlipped',
      value: function isFlipped() {
        return this.options.flipped;
      }
    }, {
      key: '_draw',
      value: function _draw() {
        // Redrawing of the axis

        var self = this;
        // var visible;

        //    this.drawInit();

        if (this.currentAxisMin === undefined || this.currentAxisMax === undefined) {
          this.setMinMaxToFitSeries(true); // We reset the min max as a function of the series
        }

        // this.cache();

        //   this.setSlaveAxesBoundaries();

        // The data min max is stored in this.dataMin, this.dataMax

        //var widthPx = this.maxPx - this.minPx;
        var widthPx = Math.abs(this.getMaxPx() - this.getMinPx());
        var valrange = this.getCurrentInterval();

        /* Number of px per unit */
        /* Example: width: 1000px
        /* 			10 - 100 => 11.11
        /*			0 - 2 => 500
        /*			0 - 0.00005 => 20'000'000
        */

        if (!this.isShown()) {
          this.line.setAttribute('display', 'none');
          return 0;
        }

        this.line.setAttribute('display', 'block');

        if (this.options.scientificScale == true) {

          if (this.options.scientificScaleExponent) {

            this.scientificExponent = this.options.scientificScaleExponent;
          } else {
            this.scientificExponent = Math.floor(Math.log(Math.max(Math.abs(this.getCurrentMax()), Math.abs(this.getCurrentMin()))) / Math.log(10));
          }
        } else {
          this.scientificExponent = 0;
        }

        /************************************/
        /*** DRAWING LABEL ******************/
        /************************************/

        this.gridLinePath.primary = '';
        this.gridLinePath.secondary = '';

        /*
        var label;
        if ( label = this.getLabel() ) {
          // Sets the label
          this.labelTspan.textContent = label;
        }
        */
        var letter = void 0;
        if (!this.options.useKatexForLabel || !this.graph.hasKatexRenderer()) {

          if (this.options.unitDecade && this.options.unit && this.scientificExponent !== 0 && (this.scientificExponent = this.getEngineeringExponent(this.scientificExponent)) && (letter = this.getExponentGreekLetter(this.scientificExponent))) {

            this.preunit = letter;
            this.unitTspan.setAttribute('dx', 0);
          } else if (this.scientificExponent !== 0 && !isNaN(this.scientificExponent)) {

            if (this.options.engineeringScale) {
              this.scientificExponent = this.getEngineeringExponent(this.scientificExponent);
            }

            this.preunit = '';

            this.expTspan.setAttribute('display', 'visible');
            this.expTspanExp.setAttribute('display', 'visible');

            this.expTspan.textContent = 'x10';
            this.expTspanExp.textContent = this.scientificExponent;
          } else {

            if (!this.options.unit) {
              this.unitTspan.setAttribute('display', 'none');
            }

            this.preunit = '';
            this.expTspan.setAttribute('display', 'none');
            this.expTspanExp.setAttribute('display', 'none');
          }

          this.writeUnit();
        } else {

          var string = this.getLabel();
          /*,
                  domEl;*/

          if (this.options.unitDecade && this.options.unit && this.scientificExponent !== 0 && (this.scientificExponent = this.getEngineeringExponent(this.scientificExponent)) && (letter = this.getExponentGreekLetter(this.scientificExponent))) {

            string += letter;
            this.preunitTspan.innerHTML = letter;
            this.preunitTspan.setAttribute('display', 'visible');
            this.unitTspan.setAttribute('dx', 0);

            string += ' ' + letter + ' ' + this.options.unit;
          } else if (this.scientificExponent !== 0 && !isNaN(this.scientificExponent)) {

            if (this.options.engineeringScale) {
              this.scientificExponent = this.getEngineeringExponent(this.scientificExponent);
            }
            string += ' \\cdot 10^' + this.scientificExponent + ' ' + this.options.unit;
          }

          this.katexElement = this.graph.renderWithKatex(string, this.katexElement);
        }

        if (!this.options.hideTicks) {

          this.resetTicksLength();

          if (this.linkedToAxis) {
            // px defined, linked to another axis

            this.linkedToAxis.deltaPx = 10;
            var widthHeight = this.drawLinkedToAxisTicksWrapper(widthPx, valrange);
          } else if (!this.options.logScale) {
            // So the setting is: How many ticks in total ? Then we have to separate it

            var widthHeight = this.drawLinearTicksWrapper(widthPx, valrange);
          } else {

            var widthHeight = this.drawLogTicks();
          }
        } else {
          var widthHeight = 0;
        }

        this.removeUselessTicks();
        this.removeUselessTickLabels();

        this.gridPrimary.setAttribute('d', this.gridLinePath.primary);
        this.gridSecondary.setAttribute('d', this.gridLinePath.secondary);

        // Looks for axes linked to this current axis
        var axes = this.graph.findAxesLinkedTo(this);
        axes.forEach(function (axis) {

          if (!axis.linkedToAxis) {
            return;
          }
          axis.setMinPx(self.getMinPx());
          axis.setMaxPx(self.getMaxPx());

          axis.draw();
        });

        /************************************/
        /*** DRAW CHILDREN IMPL SPECIFIC ****/
        /************************************/

        //   this.drawSpecifics();

        return widthHeight;
      }
    }, {
      key: 'drawLines',
      value: function drawLines() {
        var _this3 = this;

        if (this.options.lineAt && Array.isArray(this.options.lineAt)) {

          this.options.lineAt.forEach(function (val, index) {

            if (!isNaN(val) && _this3.getCurrentMin() <= val && _this3.getCurrentMax() >= val) {

              _this3._lines[index] = _this3._drawLine(val, _this3._lines[index]);
            } else {
              _this3._hideLine(_this3._lines[index]);
            }
          });
        }
      }
    }, {
      key: 'writeUnit',
      value: function writeUnit() {
        if (this.options.unit) {

          this.unitTspan.setAttribute('display', 'visible');
          this.unitTspan.setAttribute('dx', 5);

          this.expTspan.setAttribute('display', 'none');
          this.expTspanExp.setAttribute('display', 'none');
          this.unitTspan.innerHTML = (this.options.unitWrapperBefore + this.preunit + this.options.unit + this.options.unitWrapperAfter).replace(/\^([-+0-9]*)(.*)/g, "<tspan dy='-5' font-size='0.7em'>$1</tspan><tspan dy='5' font-size='1em'>$2</tspan>");
        } else {
          this.unitTspan.setAttribute('display', 'none');
        }
      }
    }, {
      key: 'getExponentGreekLetter',
      value: function getExponentGreekLetter(val) {

        switch (val) {

          case 3:
            {
              return 'k';
            }

          case 6:
            {
              return 'M';
            }
          case 9:
            {
              return 'G';
            }
          case 12:
            {
              return 'T';
            }
          case 15:
            {
              return 'E';
            }
          case -3:
            {
              return 'm';
            }
          case -6:
            {
              return '&mu;';
            }
          case -9:
            {
              return 'n';
            }
          case -12:
            {
              return 'p';
            }
          case -15:
            {
              return 'f';
            }
          default:
            {
              return '';
            }
        }
      }
    }, {
      key: 'drawLinearTicksWrapper',
      value: function drawLinearTicksWrapper(widthPx, valrange) {

        var tickPrimaryUnit = void 0;

        if (this.options.primaryTickUnit) {

          tickPrimaryUnit = this.options.primaryTickUnit;
        } else {

          tickPrimaryUnit = this.getUnitPerTick(widthPx, this.getNbTicksPrimary(), valrange)[0];

          if (this.options.maxPrimaryTickUnit && this.options.maxPrimaryTickUnit < tickPrimaryUnit) {
            tickPrimaryUnit = this.options.maxPrimaryTickUnit;
          } else if (this.options.minPrimaryTickUnit && this.options.minPrimaryTickUnit > tickPrimaryUnit) {
            tickPrimaryUnit = this.options.minPrimaryTickUnit;
          }
        }

        // We need to get here the width of the ticks to display the axis properly, with the correct shift
        return this.drawTicks(tickPrimaryUnit, this.secondaryTicks());
      }
    }, {
      key: 'forcePrimaryTickUnit',
      value: function forcePrimaryTickUnit(primaryInterval) {
        this.options.primaryTickUnit = primaryInterval;

        this.decimals = Math.max(0, Math.round(-Math.log(primaryInterval) / Math.log(10)));
      }
    }, {
      key: 'forcePrimaryTickUnitMax',
      value: function forcePrimaryTickUnitMax(value) {
        this.options.maxPrimaryTickUnit = value;
      }
    }, {
      key: 'forcePrimaryTickUnitMin',
      value: function forcePrimaryTickUnitMin(value) {
        this.options.minPrimaryTickUnit = value;
      }
    }, {
      key: 'getPrimaryTickUnit',
      value: function getPrimaryTickUnit() {
        return this.incrTick;
      }
    }, {
      key: 'setTickLabelRatio',
      value: function setTickLabelRatio(tickRatio) {
        this.options.ticklabelratio = tickRatio;
      }
    }, {
      key: 'doesHideWhenNoSeriesShown',
      value: function doesHideWhenNoSeriesShown() {
        return this.options.hideWhenNoSeriesShown;
      }
    }, {
      key: 'draw',
      value: function draw() {

        this._widthLabels = 0;
        var drawn = this._draw();
        this._widthLabels += drawn;
        return drawn;
      }
    }, {
      key: 'drawTicks',
      value: function drawTicks(primary, secondary) {

        var unitPerTick = primary,
            min = this.getCurrentMin(),
            max = this.getCurrentMax(),
            secondaryIncr,
            incrTick,
            subIncrTick,
            loop = 0;

        if (secondary) {
          secondaryIncr = unitPerTick / secondary;
        }

        incrTick = this.options.shiftToZero ? this.dataMin - Math.ceil((this.dataMin - min) / unitPerTick) * unitPerTick : Math.floor(min / unitPerTick) * unitPerTick;
        this.incrTick = primary;

        while (incrTick <= max) {

          loop++;
          if (loop > 1000) {
            break;
          }

          if (secondary) {

            subIncrTick = incrTick + secondaryIncr;
            this.subIncrTick = subIncrTick;
            //widthHeight = Math.max(widthHeight, this.drawTick(subIncrTick, 1));
            var loop2 = 0;

            while (subIncrTick < incrTick + unitPerTick) {
              loop2++;
              if (loop2 > 100) {
                break;
              }

              if (subIncrTick < min || subIncrTick > max) {
                subIncrTick += secondaryIncr;
                continue;
              }

              this.drawTickWrapper(subIncrTick, false, Math.abs(subIncrTick - incrTick - unitPerTick / 2) < 1e-4 ? 2 : 3);

              subIncrTick += secondaryIncr;
            }
          }

          if (incrTick < min || incrTick > max) {
            incrTick += primary;
            continue;
          }

          this.drawTickWrapper(incrTick, true, 1);
          incrTick += primary;
        }

        this.widthHeightTick = this.getMaxSizeTick();
        return this.widthHeightTick;
      }
    }, {
      key: 'nextTick',
      value: function nextTick(level, callback) {

        this.ticks[level] = this.ticks[level] || [];
        this.lastCurrentTick[level] = this.lastCurrentTick[level] || 0;
        this.currentTick[level] = this.currentTick[level] || 0;

        if (this.currentTick[level] >= this.ticks[level].length) {
          var tick = document.createElementNS(this.graph.ns, 'line');
          this.groupTicks.appendChild(tick);
          this.ticks[level].push(tick);

          callback(tick);
        }

        var tick = this.ticks[level][this.currentTick[level]];

        if (this.currentTick[level] >= this.lastCurrentTick[level]) {
          tick.setAttribute('display', 'visible');
        }

        this.currentTick[level]++;

        return tick;
      }
    }, {
      key: 'nextTickLabel',
      value: function nextTickLabel(callback) {

        this.ticksLabels = this.ticksLabels || [];
        this.lastCurrentTickLabel = this.lastCurrentTickLabel || 0;
        this.currentTickLabel = this.currentTickLabel || 0;

        if (this.currentTickLabel >= this.ticksLabels.length) {

          var tickLabel = document.createElementNS(this.graph.ns, 'text');
          this.groupTickLabels.appendChild(tickLabel);
          this.ticksLabels.push(tickLabel);
          callback(tickLabel);
        }

        var tickLabel = this.ticksLabels[this.currentTickLabel];

        if (this.currentTickLabel >= this.lastCurrentTickLabel) {
          tickLabel.setAttribute('display', 'visible');
        }

        this.currentTickLabel++;

        return tickLabel;
      }
    }, {
      key: 'removeUselessTicks',
      value: function removeUselessTicks() {

        for (var j in this.currentTick) {

          for (var i = this.currentTick[j]; i < this.ticks[j].length; i++) {
            this.ticks[j][i].setAttribute('display', 'none');
          }

          this.lastCurrentTick[j] = this.currentTick[j];
          this.currentTick[j] = 0;
        }
      }
    }, {
      key: 'removeUselessTickLabels',
      value: function removeUselessTickLabels() {

        for (var i = this.currentTickLabel; i < this.ticksLabels.length; i++) {
          this.ticksLabels[i].setAttribute('display', 'none');
        }

        this.lastCurrentTickLabel = this.currentTickLabel;
        this.currentTickLabel = 0;
      }
    }, {
      key: 'nextGridLine',
      value: function nextGridLine(primary, x1, x2, y1, y2) {

        if (!(primary && this.options.primaryGrid || !primary && this.options.secondaryGrid)) {
          return;
        }

        this.gridLinePath[primary ? 'primary' : 'secondary'] += 'M ' + x1 + ' ' + y1 + ' L ' + x2 + ' ' + y2;
      }
    }, {
      key: 'setGridLineStyle',
      value: function setGridLineStyle(gridLine, primary) {

        gridLine.setAttribute('shape-rendering', 'crispEdges');
        gridLine.setAttribute('stroke', primary ? this.getPrimaryGridColor() : this.getSecondaryGridColor());
        gridLine.setAttribute('stroke-width', primary ? this.getPrimaryGridWidth() : this.getSecondaryGridWidth());
        gridLine.setAttribute('stroke-opacity', primary ? this.getPrimaryGridOpacity() : this.getSecondaryGridOpacity());

        var dasharray;
        if (dasharray = primary ? this.getPrimaryGridDasharray() : this.getSecondaryGridDasharray()) {
          gridLine.setAttribute('stroke-dasharray', dasharray);
        }
      }
    }, {
      key: 'setGridLinesStyle',
      value: function setGridLinesStyle() {
        this.setGridLineStyle(this.gridPrimary, true);
        this.setGridLineStyle(this.gridSecondary, false);
        return this;
      }
    }, {
      key: 'resetTicksLength',
      value: function resetTicksLength() {}
    }, {
      key: 'secondaryTicks',
      value: function secondaryTicks() {
        return this.options.nbTicksSecondary;
      }
    }, {
      key: 'drawLogTicks',
      value: function drawLogTicks() {
        var min = this.getCurrentMin(),
            max = this.getCurrentMax();
        var incr = Math.min(min, max);
        var max = Math.max(min, max);

        if (incr < 1e-50) {
          incr = 1e-50;
        }

        if (Math.log(incr) - Math.log(max) > 20) {
          max = Math.pow(10, Math.log(incr) * 20);
        }

        var optsMain = {
          fontSize: '1.0em',
          exponential: true,
          overwrite: false
        };

        if (incr < 0) {
          incr = 0;
        }

        var pow = incr == 0 ? 0 : Math.floor(Math.log(incr) / Math.log(10));
        var incr = 1,
            val;
        while ((val = incr * Math.pow(10, pow)) < max) {
          if (incr == 1) {
            // Superior power
            if (val > min) this.drawTickWrapper(val, true, 1, optsMain);
          }
          if (incr == 10) {
            incr = 1;
            pow++;
          } else {

            if (incr != 1 && val > min) {

              this.drawTickWrapper(val, false, 2, {
                overwrite: '',
                fontSize: '0.6em'
              });
            }

            incr++;
          }
        }

        this.widthHeightTick = this.getMaxSizeTick();
        return this.widthHeightTick;
      }
    }, {
      key: 'drawTickWrapper',
      value: function drawTickWrapper(value, label, level, options) {

        //var pos = this.getPos( value );

        this.drawTick(value, level, options);
      }
    }, {
      key: 'linkToAxis',
      value: function linkToAxis(axis, scalingFunction, decimals) {

        this.linkedToAxis = {
          axis: axis,
          scalingFunction: scalingFunction,
          decimals: decimals || 1
        };
      }
    }, {
      key: 'drawLinkedToAxisTicksWrapper',
      value: function drawLinkedToAxisTicksWrapper(widthPx, valrange) {

        var opts = this.linkedToAxis,
            px = 0,
            val,
            t,
            l,
            delta2;

        // Redrawing the main axis ? Why ?
        //opts.axis.draw();

        if (!opts.deltaPx) {
          opts.deltaPx = 10;
        }

        do {

          val = opts.scalingFunction(opts.axis.getVal(px + this.getMinPx()));

          if (opts.decimals) {
            this.decimals = opts.decimals;
          }

          t = this.drawTick(val, 1, {}, px + this.getMinPx());

          if (!t) {
            console.error(val, px, this.getMinPx());
            throw new Error('Unable to draw tick. Please report the test-case');
          }

          l = String(t[1].textContent).length * 8;
          delta2 = Math.round(l / 5) * 5;

          if (delta2 > opts.deltaPx) {
            opts.deltaPx = delta2;
            //     this.drawInit();
            this.drawLinkedToAxisTicksWrapper(widthPx, valrange);
            return;
          }

          px += opts.deltaPx;
        } while (px < widthPx);
      }
    }, {
      key: 'getPos',
      value: function getPos(value) {
        return this.getPx(value);
      }
    }, {
      key: 'getPx',
      value: function getPx(value) {
        //      if(this.getMaxPx() == undefined)
        //        console.log(this);
        //console.log(this.getMaxPx(), this.getMinPx(), this.getCurrentInterval());
        // Ex 50 / (100) * (1000 - 700) + 700

        //console.log( value, this.getCurrentMin(), this.getMaxPx(), this.getMinPx(), this.getCurrentInterval() );

        if (!this.options.logScale) {

          return (value - this.getCurrentMin()) / this.getCurrentInterval() * (this.getMaxPx() - this.getMinPx()) + this.getMinPx();
        } else {
          // 0 if value = min
          // 1 if value = max

          if (value < 0) return;

          var value = (Math.log(value) - Math.log(this.getCurrentMin())) / (Math.log(this.getCurrentMax()) - Math.log(this.getCurrentMin())) * (this.getMaxPx() - this.getMinPx()) + this.getMinPx();

          return value;
        }
      }
    }, {
      key: 'getRoundedPx',
      value: function getRoundedPx(value) {
        //      if(this.getMaxPx() == undefined)
        //        console.log(this);
        //console.log(this.getMaxPx(), this.getMinPx(), this.getCurrentInterval());
        // Ex 50 / (100) * (1000 - 700) + 700

        //console.log( value, this.getCurrentMin(), this.getMaxPx(), this.getMinPx(), this.getCurrentInterval() );
        return Math.round(this.getPx(value) * 10) / 10;
      }
    }, {
      key: 'getVal',
      value: function getVal(px) {

        if (!this.options.logScale) {

          return (px - this.getMinPx()) / (this.getMaxPx() - this.getMinPx()) * this.getCurrentInterval() + this.getCurrentMin();
        } else {

          return Math.exp((px - this.getMinPx()) / (this.getMaxPx() - this.getMinPx()) * (Math.log(this.getCurrentMax()) - Math.log(this.getCurrentMin())) + Math.log(this.getCurrentMin()));
        }
      }
    }, {
      key: 'getRelPx',
      value: function getRelPx(delta) {

        return delta / this.getCurrentInterval() * (this.getMaxPx() - this.getMinPx());
      }
    }, {
      key: 'getRelVal',
      value: function getRelVal(px) {
        return px / (this.getMaxPx() - this.getMinPx()) * this.getCurrentInterval();
      }
    }, {
      key: 'valueToText',
      value: function valueToText(value) {

        if (this.scientificExponent) {

          value /= Math.pow(10, this.scientificExponent);
          return value.toFixed(1);
        } else {

          value = value * Math.pow(10, this.getExponentialFactor()) * Math.pow(10, this.getExponentialLabelFactor());
          if (this.options.shiftToZero) {
            value -= this.dataMin;
          }
          if (this.options.ticklabelratio) {
            value *= this.options.ticklabelratio;
          }
          if (this.options.unitModification) {
            value = this.modifyUnit(value, this.options.unitModification);
            return value;
          }

          var dec = this.decimals - this.getExponentialFactor() - this.getExponentialLabelFactor();

          if (isNaN(value)) {
            return '';
          }

          if (dec > 0) {
            value = value.toFixed(dec);
          } else {
            value = value.toFixed(0);
          }

          if (this.options.unitInTicks && this.options.unit) {
            value += ' ' + this.options.unit;
          }

          return value;
        }
      }
    }, {
      key: 'valueToHtml',
      value: function valueToHtml(value, noScaling, noUnits) {

        var text = this.valueToText(value);
        var letter;

        if (this.options.unitDecade && this.options.unit && this.scientificExponent !== 0 && (this.scientificExponent = this.getEngineeringExponent(this.scientificExponent)) && (letter = this.getExponentGreekLetter(this.scientificExponent))) {

          text += letter;
        } else if (this.scientificExponent !== 0 && !isNaN(this.scientificExponent) && !noScaling) {
          text += 'x10';
          text += '<sup>' + this.scientificExponent + '</sup>';
        }

        if (this.options.unit && !noUnits) {

          text += this.options.unit.replace(/\^([-+0-9]*)/g, '<sup>$1</sup>');
        }

        return text;
      }
    }, {
      key: 'getModifiedValue',
      value: function getModifiedValue(value) {
        if (this.options.ticklabelratio) {
          value *= this.options.ticklabelratio;
        }

        if (this.options.shiftToZero) {
          value -= this.getMinValue() * (this.options.ticklabelratio || 1);
        }

        return value;
      }
    }, {
      key: 'modifyUnit',
      value: function modifyUnit(value, mode) {

        var text = '';
        var incr = this.incrTick;
        var umin;

        switch (mode) {

          case 'time':
            // val must be in seconds => transform in hours / days / months
            var max = this.getModifiedValue(this.getMaxValue()),
                units = [[60, 'min'], [3600, 'h'], [3600 * 24, 'd']];

            if (max < 3600) {
              // to minutes
              umin = 0;
            } else if (max < 3600 * 24) {
              umin = 1;
            } else if (max < 3600 * 24 * 30) {
              umin = 2;
            }

            if (!units[umin]) {
              return false;
            }

            value = value / units[umin][0];
            var valueRounded = Math.floor(value);
            text = valueRounded + units[umin][1];

            // Addind lower unit for precision
            umin--;
            while (incr < 1 * units[umin + 1][0] && umin > -1) {

              value = (value - valueRounded) * units[umin + 1][0] / units[umin][0];
              valueRounded = Math.round(value);
              text += ' ' + valueRounded + units[umin][1];
              umin--;
            }

            break;

          case 'time:min.sec':
            value = value / 60;
            var valueRounded = Math.floor(value);
            var s = '' + Math.round((value - valueRounded) * 60);
            s = s.length == 1 ? '0' + s : s;
            text = valueRounded + '.' + s;
            break;

          default:
            break;
        }

        return text;
      }
    }, {
      key: 'getExponentialFactor',
      value: function getExponentialFactor() {
        return this.options.exponentialFactor;
      }
    }, {
      key: 'setExponentialFactor',
      value: function setExponentialFactor(value) {
        this.options.exponentialFactor = value;
      }
    }, {
      key: 'setExponentialLabelFactor',
      value: function setExponentialLabelFactor(value) {
        this.options.exponentialLabelFactor = value;
      }
    }, {
      key: 'getExponentialLabelFactor',
      value: function getExponentialLabelFactor() {
        return this.options.exponentialLabelFactor;
      }
    }, {
      key: 'setLabel',
      value: function setLabel(label) {
        this.options.labelValue = label;
        return this;
      }
    }, {
      key: 'setLabelFont',
      value: function setLabelFont(font) {
        this.options.labelFont = font;
        return this;
      }
    }, {
      key: 'getLabel',
      value: function getLabel() {
        return this.options.labelValue;
      }
    }, {
      key: 'setSpan',
      value: function setSpan(_from, _to) {

        this.options.span = [_from, _to];
        return this;
      }
    }, {
      key: 'getSpan',
      value: function getSpan() {
        return this.options.span;
      }
    }, {
      key: 'setLevel',
      value: function setLevel(level) {
        this._level = level;
        return this;
      }
    }, {
      key: 'getLevel',
      value: function getLevel() {
        return this._level;
      }
    }, {
      key: 'setShift',
      value: function setShift(shift) {
        this.shift = shift;
      }
    }, {
      key: 'getShift',
      value: function getShift() {
        return this.shift;
      }
    }, {
      key: 'setTickPosition',
      value: function setTickPosition(pos) {
        switch (pos) {
          case 3:
          case 'outside':
          case _graphCore2.default.TICKS_OUTSIDE:
            {
              pos = 3;
              break;
            }

          case 2:
          case 'centered':
          case _graphCore2.default.TICKS_CENTERED:
            {
              pos = 2;
              break;
            }

          case 1:
          case 'inside':
          case _graphCore2.default.TICKS_INSIDE:
          default:
            {
              pos = 1;
              break;
            }
        }

        this.options.tickPosition = pos;

        switch (this.options.tickPosition) {
          case 3:
            this.tickPx1 = -2;
            this.tickPx2 = 0;
            break;

          case 2:
            this.tickPx1 = -1;
            this.tickPx2 = 1;
            break;

          default:
          case 1:
            this.tickPx1 = 0;
            this.tickPx2 = 2;
            break;
        }

        return this;
      }
    }, {
      key: 'setGrids',
      value: function setGrids(on) {
        this.options.primaryGrid = on;
        this.options.secondaryGrid = on;
        return this;
      }
    }, {
      key: 'setPrimaryGrid',
      value: function setPrimaryGrid(on) {
        this.options.primaryGrid = on;
        return this;
      }
    }, {
      key: 'setSecondaryGrid',
      value: function setSecondaryGrid(on) {
        this.options.secondaryGrid = on;
        return this;
      }
    }, {
      key: 'primaryGridOn',
      value: function primaryGridOn() {
        return this.setPrimaryGrid(true);
      }
    }, {
      key: 'primaryGridOff',
      value: function primaryGridOff() {
        return this.setPrimaryGrid(false);
      }
    }, {
      key: 'secondaryGridOn',
      value: function secondaryGridOn() {
        return this.setSecondaryGrid(true);
      }
    }, {
      key: 'secondaryGridOff',
      value: function secondaryGridOff() {
        return this.setSecondaryGrid(false);
      }
    }, {
      key: 'gridsOn',
      value: function gridsOn() {
        return this.setGrids(true);
      }
    }, {
      key: 'gridsOff',
      value: function gridsOff() {
        return this.setGrids(false);
      }
    }, {
      key: 'turnGridsOff',
      value: function turnGridsOff() {
        return this.gridsOff.apply(this, arguments);
      }
    }, {
      key: 'turnGridsOn',
      value: function turnGridsOn() {
        return this.gridsOn.apply(this, arguments);
      }
    }, {
      key: 'setColor',
      value: function setColor() {
        var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'black';

        this.options.axisColor = color;
        this.options.primaryTicksColor = color;
        this.options.secondaryTicksColor = color;
        this.options.ticksLabelColor = color;
        this.options.primaryGridColor = color;
        this.options.secondaryGridColor = color;
        this.options.labelColor = color;
        return this;
      }
    }, {
      key: 'setAxisColor',
      value: function setAxisColor(color) {
        this.options.axisColor = color;
        return this;
      }
    }, {
      key: 'getAxisColor',
      value: function getAxisColor() {
        return this.options.axisColor || 'black';
      }
    }, {
      key: 'setTickLabelOffset',
      value: function setTickLabelOffset(offsetValue) {
        this.options.tickLabelOffset = offsetValue;
        return this;
      }
    }, {
      key: 'setPrimaryTicksColor',
      value: function setPrimaryTicksColor(color) {
        this.options.primaryTicksColor = color;
        return this;
      }
    }, {
      key: 'getPrimaryTicksColor',
      value: function getPrimaryTicksColor() {
        return this.options.primaryTicksColor || 'black';
      }
    }, {
      key: 'setSecondaryTicksColor',
      value: function setSecondaryTicksColor(color) {
        this.options.secondaryTicksColor = color;
        return this;
      }
    }, {
      key: 'getSecondaryTicksColor',
      value: function getSecondaryTicksColor() {
        return this.options.secondaryTicksColor || 'black';
      }
    }, {
      key: 'setTicksLabelColor',
      value: function setTicksLabelColor(color) {
        this.options.ticksLabelColor = color;
        if (Array.isArray(this.ticksLabels)) {
          this.ticksLabels.forEach(function (tick) {
            tick.setAttribute('fill', color);
          });
        }
        return this;
      }
    }, {
      key: 'getTicksLabelColor',
      value: function getTicksLabelColor() {
        return this.options.ticksLabelColor || 'black';
      }
    }, {
      key: 'setPrimaryGridColor',
      value: function setPrimaryGridColor(color) {
        this.options.primaryGridColor = color;
        this.setGridLinesStyle();
        return this;
      }
    }, {
      key: 'getPrimaryGridColor',
      value: function getPrimaryGridColor() {
        return this.options.primaryGridColor;
      }
    }, {
      key: 'setSecondaryGridColor',
      value: function setSecondaryGridColor(color) {
        this.options.secondaryGridColor = color;
        this.setGridLinesStyle();
        return this;
      }
    }, {
      key: 'getSecondaryGridColor',
      value: function getSecondaryGridColor() {
        return this.options.secondaryGridColor;
      }
    }, {
      key: 'setPrimaryGridWidth',
      value: function setPrimaryGridWidth(width) {
        this.options.primaryGridWidth = width;
        this.setGridLinesStyle();
        return this;
      }
    }, {
      key: 'getPrimaryGridWidth',
      value: function getPrimaryGridWidth() {
        return this.options.primaryGridWidth;
      }
    }, {
      key: 'setSecondaryGridWidth',
      value: function setSecondaryGridWidth(width) {
        this.options.secondaryGridWidth = width;
        this.setGridLinesStyle();
        return this;
      }
    }, {
      key: 'getSecondaryGridWidth',
      value: function getSecondaryGridWidth() {
        return this.options.secondaryGridWidth;
      }
    }, {
      key: 'setPrimaryGridOpacity',
      value: function setPrimaryGridOpacity(opacity) {
        this.options.primaryGridOpacity = opacity;
        return this;
      }
    }, {
      key: 'getPrimaryGridOpacity',
      value: function getPrimaryGridOpacity() {
        return this.options.primaryGridOpacity;
      }
    }, {
      key: 'setSecondaryGridOpacity',
      value: function setSecondaryGridOpacity(opacity) {
        this.options.secondaryGridOpacity = opacity;
        return this;
      }
    }, {
      key: 'getSecondaryGridOpacity',
      value: function getSecondaryGridOpacity() {
        return this.options.secondaryGridOpacity;
      }
    }, {
      key: 'setPrimaryGridDasharray',
      value: function setPrimaryGridDasharray(dasharray) {
        this.options.primaryGridDasharray = dasharray;
        return this;
      }
    }, {
      key: 'getPrimaryGridDasharray',
      value: function getPrimaryGridDasharray() {
        return this.options.primaryGridDasharray;
      }
    }, {
      key: 'setSecondaryGridDasharray',
      value: function setSecondaryGridDasharray(dasharray) {
        this.options.secondaryGridDasharray = dasharray;
        return this;
      }
    }, {
      key: 'getSecondaryGridDasharray',
      value: function getSecondaryGridDasharray() {
        return this.options.secondaryGridDasharray;
      }
    }, {
      key: 'setLabelColor',
      value: function setLabelColor(color) {
        this.options.labelColor = color;
        return this;
      }
    }, {
      key: 'getLabelColor',
      value: function getLabelColor() {
        return this.options.labelColor;
      }
    }, {
      key: 'setTickContent',
      value: function setTickContent(dom, val, options) {
        if (!options) {
          options = {};
        }

        if (options.overwrite || !options.exponential) {

          dom.textContent = options.overwrite || this.valueToText(val);
        } else {
          var log = Math.round(Math.log(val) / Math.log(10));
          var unit = Math.floor(val * Math.pow(10, -log));

          dom.textContent = unit != 1 ? unit + 'x10' : '10';
          var tspan = document.createElementNS(this.graph.ns, 'tspan');
          tspan.textContent = log;
          tspan.setAttribute('font-size', '0.7em');
          tspan.setAttribute('dy', -5);
          dom.appendChild(tspan);
        }

        if (options.fontSize) {
          dom.setAttribute('font-size', options.fontSize);
        }
      }
    }, {
      key: 'isX',
      value: function isX() {
        return false;
      }
    }, {
      key: 'isY',
      value: function isY() {
        return false;
      }
    }, {
      key: 'setUnit',
      value: function setUnit(unit) {
        this.options.unit = unit;
        return this;
      }
    }, {
      key: 'setUnitInTicks',
      value: function setUnitInTicks(bool) {
        this.options.unitInTicks = bool;
        return this;
      }
    }, {
      key: 'setUnitWrapper',
      value: function setUnitWrapper(before, after) {
        this.options.unitWrapperBefore = before;
        this.options.unitWrapperAfter = after;
        return this;
      }
    }, {
      key: 'setUnitDecade',
      value: function setUnitDecade(on) {
        this.options.unitDecade = on;
        return this;
      }
    }, {
      key: 'setScientific',
      value: function setScientific(on) {
        this.options.scientificScale = on;
        return this;
      }
    }, {
      key: 'setScientificScaleExponent',
      value: function setScientificScaleExponent(scientificScaleExponent) {
        this.options.scientificScaleExponent = scientificScaleExponent;
        return this;
      }
    }, {
      key: 'setEngineering',
      value: function setEngineering(engineeringScaling) {
        //bool
        this.options.scientificScale = engineeringScaling;
        this.options.engineeringScale = engineeringScaling;
        return this;
      }
    }, {
      key: 'getEngineeringExponent',
      value: function getEngineeringExponent(scientificExponent) {

        if (scientificExponent > 0) {
          scientificExponent -= scientificExponent % 3;
        } else {
          scientificExponent -= (3 - -scientificExponent % 3) % 3;
        }

        return scientificExponent;
      }
    }, {
      key: 'setLogScale',
      value: function setLogScale(log) {
        this.options.logScale = log;
        return this;
      }
    }, {
      key: 'isZoomed',
      value: function isZoomed() {
        return !(this.currentAxisMin == this.getMinValue() || this.currentAxisMax == this.getMaxValue());
      }
    }, {
      key: 'hasAxis',
      value: function hasAxis() {
        return false;
      }
    }, {
      key: 'getType',
      value: function getType() {
        return null;
      }
    }, {
      key: 'useKatexForLabel',
      value: function useKatexForLabel() {
        var use = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        this.options.useKatexForLabel = use;
        return this;
      }
    }, {
      key: 'zoomLock',
      set: function set(bln) {
        this._zoomLocked = bln;
      },
      get: function get() {
        return this._zoomLocked || false;
      }
    }]);

    return Axis;
  }(_EventEmitter3.default);

  /**
   *  @alias Axis#getVal
   */
  Axis.prototype.getValue = Axis.prototype.getVal;

  /**
   *  @alias Axis#getRelPx
   */
  Axis.prototype.getDeltaPx = Axis.prototype.getRelPx;

  exports.default = Axis;
  module.exports = exports['default'];
});

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(5)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('../graph.util.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphUtil);
    global.graphMixinErrorbars = mod.exports;
  }
})(this, function (module, exports, _graphUtil) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var util = _interopRequireWildcard(_graphUtil);

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  var ErrorBarMixin = {
    /*
      doErrorDraw: function( orientation, error, originVal, originPx, xpx, ypx ) {
         if ( !( error instanceof Array ) ) {
          error = [ error ];
        }
         var functionName = orientation == 'y' ? 'getY' : 'getX';
        var bars = orientation == 'y' ? [ 'top', 'bottom' ] : [ 'left', 'right' ];
        var j;
         if ( isNaN( xpx ) || isNaN( ypx ) ) {
          return;
        }
         for ( var i = 0, l = error.length; i < l; i++ ) {
           if ( error[ i ] instanceof Array ) { // TOP
             j = bars[ 0 ];
            this.errorstyles[ i ].paths[ j ] += " M " + xpx + " " + ypx;
            this.errorstyles[ i ].paths[ j ] += this.makeError( orientation, i, this[ functionName ]( originVal + error[ i ][ 0 ] ), originPx, j );
             j = bars[ 1 ];
            this.errorstyles[ i ].paths[ j ] += " M " + xpx + " " + ypx;
            this.errorstyles[ i ].paths[ j ] += this.makeError( orientation, i, this[ functionName ]( originVal - error[ i ][ 1 ] ), originPx, j );
           } else {
             j = bars[ 0 ];
             this.errorstyles[ i ].paths[ j ] += " M " + xpx + " " + ypx;
            this.errorstyles[ i ].paths[ j ] += this.makeError( orientation, i, this[ functionName ]( originVal + error[ i ] ), originPx, j );
            j = bars[ 1 ];
            this.errorstyles[ i ].paths[ j ] += " M " + xpx + " " + ypx;
            this.errorstyles[ i ].paths[ j ] += this.makeError( orientation, i, this[ functionName ]( originVal - error[ i ] ), originPx, j );
          }
        }
      },
    */

    /*
      makeError: function( orientation, type, coord, origin, quadOrientation ) {
         var method;
        switch ( this.errorstyles[ level ].type ) {
          case 'bar':
            method = "makeBar";
            break;
           case 'box':
            method = "makeBox";
            break;
        }
         return this[ method + orientation.toUpperCase() ]( coord, origin, this.errorstyles[ level ][ quadOrientation ] );
       },*/

    makeBarY: function makeBarY(coordY, origin, style) {
      if (!coordY || style === undefined) {
        return;
      }
      var width = !util.isNumeric(style.width) ? 10 : style.width;
      return ' V ' + coordY + ' m -' + width / 2 + ' 0 h ' + width + ' m -' + width / 2 + ' 0 V ' + origin + ' ';
    },

    makeBoxY: function makeBoxY(coordY, origin, style) {
      if (!coordY || style === undefined) {
        return;
      }
      return ' m 5 0 V ' + coordY + ' h -10 V ' + origin + ' m 5 0 ';
    },

    makeBarX: function makeBarX(coordX, origin, style) {
      if (!coordX || style === undefined) {
        return;
      }
      var height = !util.isNumeric(style.width) ? 10 : style.width;
      return ' H ' + coordX + ' m 0 -' + height / 2 + ' v ' + height + ' m 0 -' + height / 2 + ' H ' + origin + ' ';
    },

    makeBoxX: function makeBoxX(coordX, origin, style) {
      if (!coordX || style === undefined) {
        return;
      }
      return ' v 5 H ' + coordX + ' v -10 H ' + origin + ' v 5 ';
    },
    /*
      check: function( index, valY, valX ) {
         var dx, dy;
         if ( ( this.getType() == Graph.SERIE_LINE || this.getType() == Graph.SERIE_SCATTER ) ) {
           if ( !( dx = this.data[ index * 2 ] ) || !( dy = this.data[ index * 2 + 1 ] ) ) { //
            return;
          }
        }
         if ( dx === undefined ) {
          return;
        }
         for ( var i = 0, l = valY.length; i < l; i++ ) {
           if ( Array.isArray( valY[ i ] ) ) {
             if ( !isNaN( valY[ i ][ 0 ] ) ) {
              this._checkY( dy + valY[ i ][ 0 ] );
            }
             if ( !isNaN( valY[ i ][ 1 ] ) ) {
              this._checkY( dy - valY[ i ][ 1 ] );
            }
           } else {
             if ( !isNaN( valY[ i ] ) ) {
              this._checkY( dy + valY[ i ] );
              this._checkY( dy - valY[ i ] );
            }
          }
        }
         for ( var i = 0, l = valX.length; i < l; i++ ) {
           if ( Array.isArray( valX[ i ] ) ) {
             if ( !isNaN( valX[ i ][ 0 ] ) ) {
              this._checkX( dx - valX[ i ][ 0 ] );
            }
             if ( !isNaN( valX[ i ][ 1 ] ) ) {
              this._checkX( dx + valX[ i ][ 1 ] );
            }
           } else {
             if ( !isNaN( valY[ i ] ) ) {
              this._checkX( dx - valX[ i ] );
              this._checkX( dx + valX[ i ] );
            }
          }
        }
       },
    */

    /**
     *
     *  @example serie.setErrorStyle( [ { type: 'bar', x: {} }, { type: 'box', top: { strokeColor: 'green', fillColor: 'olive' }, bottom: { strokeColor: 'red', fillColor: "#800000" }  } ] );
     */
    setErrorBarStyle: function setErrorBarStyle(errorstyle) {

      this.errorbarStyle = this._setErrorStyle(errorstyle);
      return this;
    },

    setErrorBoxStyle: function setErrorBoxStyle(errorstyle) {

      this.errorboxStyle = this._setErrorStyle(errorstyle);
      return this;
    },

    _setErrorStyle: function _setErrorStyle() {
      var _this = this;

      var errorstyles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};


      var styles = [];
      var pairs = [['y', 'top', 'bottom'], ['x', 'left', 'right']];

      var makePath = function makePath(style) {

        style.dom = document.createElementNS(_this.graph.ns, 'path');
        style.dom.setAttribute('fill', style.fillColor || 'none');
        style.dom.setAttribute('stroke', style.strokeColor || 'black');
        style.dom.setAttribute('stroke-opacity', style.strokeOpacity || 1);
        style.dom.setAttribute('fill-opacity', style.fillOpacity || 1);
        style.dom.setAttribute('stroke-width', style.strokeWidth || 1);

        _this.groupMain.appendChild(style.dom);
      };
      // i is bar or box

      var styles = {};

      if (typeof errorstyles == 'string') {
        errorstyles = {};
      }

      for (var j = 0, l = pairs.length; j < l; j++) {

        if (errorstyles.all) {

          errorstyles[pairs[j][1]] = util.extend(true, {}, errorstyles.all);
          errorstyles[pairs[j][2]] = util.extend(true, {}, errorstyles.all);
        }

        if (errorstyles[pairs[j][0]]) {
          //.x, .y

          errorstyles[pairs[j][1]] = util.extend(true, {}, errorstyles[pairs[j][0]]);
          errorstyles[pairs[j][2]] = util.extend(true, {}, errorstyles[pairs[j][0]]);
        }

        for (var k = 1; k <= 2; k++) {

          if (errorstyles[pairs[j][k]]) {

            styles[pairs[j][k]] = errorstyles[pairs[j][k]];
            makePath(styles[pairs[j][k]]);
          }
        }
      }

      return styles;
    },


    errorDrawInit: function errorDrawInit() {
      var error;
      //  var pathError = "M 0 0 ";

      if (this.errorboxStyle) {

        this.errorboxStyle.paths = {
          top: '',
          bottom: '',
          left: '',
          right: ''
        };
      }

      if (this.errorbarStyle) {

        this.errorbarStyle.paths = {
          top: '',
          bottom: '',
          left: '',
          right: ''
        };
      }
    },

    errorAddPoint: function errorAddPoint(index, dataX, dataY, xpx, ypx) {

      /* eslint-disable no-cond-assign */
      var error = void 0;
      if (error = this.waveform.getErrorBarXBelow(index)) {
        this.errorbarStyle.paths.left += ' M ' + xpx + ' ' + ypx;
        this.errorbarStyle.paths.left += this.makeBarX(this.getX(dataX - error), xpx, this.errorbarStyle.left);
      }

      if (error = this.waveform.getErrorBarXAbove(index)) {
        this.errorbarStyle.paths.right += ' M ' + xpx + ' ' + ypx;
        this.errorbarStyle.paths.right += this.makeBarX(this.getX(dataX + error), xpx, this.errorbarStyle.right);
      }

      if (error = this.waveform.getErrorBarYBelow(index)) {
        this.errorbarStyle.paths.bottom += ' M ' + xpx + ' ' + ypx;
        this.errorbarStyle.paths.bottom += this.makeBarY(this.getY(dataY - error), ypx, this.errorbarStyle.bottom);
      }

      if (error = this.waveform.getErrorBarYAbove(index)) {
        this.errorbarStyle.paths.top += ' M ' + xpx + ' ' + ypx;
        this.errorbarStyle.paths.top += this.makeBarY(this.getY(dataY + error), ypx, this.errorbarStyle.top);
      }

      if (error = this.waveform.getErrorBoxXBelow(index)) {
        this.errorboxStyle.paths.left += ' M ' + xpx + ' ' + ypx;
        this.errorboxStyle.paths.left += this.makeBoxX(this.getX(dataX - error), xpx, this.errorboxStyle.left);
      }

      if (error = this.waveform.getErrorBoxXAbove(index)) {
        this.errorboxStyle.paths.right += ' M ' + xpx + ' ' + ypx;

        this.errorboxStyle.paths.right += this.makeBoxX(this.getX(dataX + error), xpx, this.errorboxStyle.right);
      }

      if (error = this.waveform.getErrorBoxYBelow(index)) {
        this.errorboxStyle.paths.bottom += ' M ' + xpx + ' ' + ypx;
        this.errorboxStyle.paths.bottom += this.makeBoxY(this.getY(dataY - error), ypx, this.errorboxStyle.bottom);
      }

      if (error = this.waveform.getErrorBoxYAbove(index)) {
        this.errorboxStyle.paths.top += ' M ' + xpx + ' ' + ypx;
        this.errorboxStyle.paths.top += this.makeBoxY(this.getY(dataY + error), ypx, this.errorboxStyle.top);
      }
      /* eslint-enable */
    },

    errorAddPointBarChart: function errorAddPointBarChart(j, posY, xpx, ypx) {
      var error;
      if (this.error && (error = this.error[j])) {
        this.doErrorDraw('y', error, posY, ypx, xpx, ypx);
      }
    },

    errorDraw: function errorDraw() {

      if (this.errorbarStyle) {

        for (var j in this.errorbarStyle.paths) {

          if (this.errorbarStyle[j] && this.errorbarStyle[j].dom) {
            this.errorbarStyle[j].dom.setAttribute('d', this.errorbarStyle.paths[j]);
          }
        }
      }

      if (this.errorboxStyle) {

        for (var j in this.errorboxStyle.paths) {

          if (this.errorboxStyle[j] && this.errorboxStyle[j].dom) {
            this.errorboxStyle[j].dom.setAttribute('d', this.errorboxStyle.paths[j]);
          }
        }
      }
    }
  };

  exports.default = ErrorBarMixin;
  module.exports = exports['default'];
});

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4);
var document = __webpack_require__(2).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var core = __webpack_require__(19);
var LIBRARY = __webpack_require__(33);
var wksExt = __webpack_require__(105);
var defineProperty = __webpack_require__(8).f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(58)('keys');
var uid = __webpack_require__(36);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 78 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(2).document;
module.exports = document && document.documentElement;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(4);
var anObject = __webpack_require__(1);
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__(20)(Function.call, __webpack_require__(17).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),
/* 81 */
/***/ (function(module, exports) {

module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4);
var setPrototypeOf = __webpack_require__(80).set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toInteger = __webpack_require__(25);
var defined = __webpack_require__(24);

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};


/***/ }),
/* 84 */
/***/ (function(module, exports) {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};


/***/ }),
/* 85 */
/***/ (function(module, exports) {

// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(25);
var defined = __webpack_require__(24);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(33);
var $export = __webpack_require__(0);
var redefine = __webpack_require__(13);
var hide = __webpack_require__(12);
var Iterators = __webpack_require__(49);
var $iterCreate = __webpack_require__(88);
var setToStringTag = __webpack_require__(47);
var getPrototypeOf = __webpack_require__(18);
var ITERATOR = __webpack_require__(6)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(39);
var descriptor = __webpack_require__(35);
var setToStringTag = __webpack_require__(47);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(12)(IteratorPrototype, __webpack_require__(6)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__(62);
var defined = __webpack_require__(24);

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__(6)('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(49);
var ITERATOR = __webpack_require__(6)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__(8);
var createDesc = __webpack_require__(35);

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(54);
var ITERATOR = __webpack_require__(6)('iterator');
var Iterators = __webpack_require__(49);
module.exports = __webpack_require__(19).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(237);

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)

var toObject = __webpack_require__(10);
var toAbsoluteIndex = __webpack_require__(38);
var toLength = __webpack_require__(9);
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(34);
var step = __webpack_require__(121);
var Iterators = __webpack_require__(49);
var toIObject = __webpack_require__(16);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(87)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(20);
var invoke = __webpack_require__(111);
var html = __webpack_require__(79);
var cel = __webpack_require__(75);
var global = __webpack_require__(2);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(21)(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var macrotask = __webpack_require__(97).set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(21)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(11);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(2);
var DESCRIPTORS = __webpack_require__(7);
var LIBRARY = __webpack_require__(33);
var $typed = __webpack_require__(69);
var hide = __webpack_require__(12);
var redefineAll = __webpack_require__(44);
var fails = __webpack_require__(3);
var anInstance = __webpack_require__(42);
var toInteger = __webpack_require__(25);
var toLength = __webpack_require__(9);
var toIndex = __webpack_require__(130);
var gOPN = __webpack_require__(40).f;
var dP = __webpack_require__(8).f;
var arrayFill = __webpack_require__(95);
var setToStringTag = __webpack_require__(47);
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(73)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('./graph.axis.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphAxis);
    global.graphAxisX = mod.exports;
  }
})(this, function (module, exports, _graphAxis) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _graphAxis2 = _interopRequireDefault(_graphAxis);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var AxisX = function (_Axis) {
    _inherits(AxisX, _Axis);

    function AxisX(graph, topbottom) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      _classCallCheck(this, AxisX);

      var _this = _possibleConstructorReturn(this, (AxisX.__proto__ || Object.getPrototypeOf(AxisX)).call(this, graph, topbottom, options));

      _this.top = topbottom == 'top';
      return _this;
    }

    /**
     *  @private
     *  Returns the position of the axis, used by refreshDrawingZone in core module
     */


    _createClass(AxisX, [{
      key: 'getAxisPosition',
      value: function getAxisPosition() {

        if (!this.options.display) {
          return 0;
        }

        var size = void 0;

        if (this.options.tickLabelOffset == 0) {
          // Normal mode, no offset
          size = this.options.tickPosition == 1 ? 8 : 20;
          size += this.graph.options.fontSize * 1;
        } else {
          // With an offset, and ticks inside, axis position is actually 0. Otherwise, it's the heights of the ticks
          size = this.options.tickPosition == 1 ? 0 : 12;
        }

        if (this.getLabel()) {
          size += this.graph.options.fontSize;
        }

        return size;
      }
    }, {
      key: 'isX',
      value: function isX() {
        return true;
      }
    }, {
      key: 'isY',
      value: function isY() {
        return false;
      }
    }, {
      key: 'setShift',
      value: function setShift(shift) {

        this.shift = shift;
        if (this.getShift() === undefined || !this.graph.getDrawingHeight()) {
          return;
        }

        this.group.setAttribute('transform', 'translate(0 ' + (this.floating ? this.getShift() : this.top ? this.shift : this.graph.getDrawingHeight() - this.shift) + ')');
      }
    }, {
      key: 'getMaxSizeTick',
      value: function getMaxSizeTick() {
        return (this.top ? -1 : 1) * (this.options.tickPosition == 1 ? 10 : 10);
      }
    }, {
      key: 'drawTick',
      value: function drawTick(value, level, options, forcedPos) {
        var _this2 = this;

        var self = this,
            val;

        val = forcedPos || this.getPos(value);

        if (val == undefined || isNaN(val)) {
          return;
        }

        var tick = this.nextTick(level, function (tick) {

          tick.setAttribute('y1', (self.top ? 1 : -1) * self.tickPx1 * self.tickScaling[level]);
          tick.setAttribute('y2', (self.top ? 1 : -1) * self.tickPx2 * self.tickScaling[level]);

          if (level == 1) {
            tick.setAttribute('stroke', self.getPrimaryTicksColor());
          } else {
            tick.setAttribute('stroke', self.getSecondaryTicksColor());
          }
        });

        //      tick.setAttribute( 'shape-rendering', 'crispEdges' );
        tick.setAttribute('x1', val);
        tick.setAttribute('x2', val);

        this.nextGridLine(level == 1, val, val, 0, this.graph.getDrawingHeight());

        //  this.groupTicks.appendChild( tick );
        if (level == 1) {

          var tickLabel = this.nextTickLabel(function (tickLabel) {

            tickLabel.setAttribute('y', (self.top ? -1 : 1) * ((self.options.tickPosition == 1 ? 8 : 20) + (self.top ? 10 : 0)) + _this2.options.tickLabelOffset);
            tickLabel.setAttribute('text-anchor', 'middle');
            if (self.getTicksLabelColor() !== 'black') {
              tickLabel.setAttribute('fill', self.getTicksLabelColor());
            }
            tickLabel.style.dominantBaseline = 'hanging';
          });

          tickLabel.setAttribute('x', val);
          this.setTickContent(tickLabel, value, options);
        }
        //    this.ticks.push( tick );

        return [tick, tickLabel];
      }
    }, {
      key: 'drawLabel',
      value: function drawLabel() {
        // Place label correctly

        if (this.getLabelColor() !== 'black') {
          this.label.setAttribute('fill', this.getLabelColor());
        }

        if (this.options.labelFont) {
          this.label.setAttribute('font-family', this.options.labelFont);
        }

        this.label.setAttribute('text-anchor', 'middle');
        this.label.setAttribute('style', 'display: initial;');
        this.label.setAttribute('x', Math.abs(this.getMaxPx() + this.getMinPx()) / 2);
        this.label.setAttribute('y', (this.top ? -1 : 1) * ((this.options.tickPosition == 1 ? 10 : 25) + this.graph.options.fontSize));
        this.labelTspan.textContent = this.getLabel();
      }
    }, {
      key: 'draw',
      value: function draw() {
        var tickWidth = _get(AxisX.prototype.__proto__ || Object.getPrototypeOf(AxisX.prototype), 'draw', this).apply(this, arguments);
        this.drawSpecifics();

        return tickWidth;
      }
    }, {
      key: 'drawSpecifics',
      value: function drawSpecifics() {

        // Adjusts group shift
        //this.group.setAttribute('transform', 'translate(0 ' + this.getShift() + ')');

        this.drawLabel();

        this.line.setAttribute('x1', this.getMinPx());
        this.line.setAttribute('x2', this.getMaxPx());
        this.line.setAttribute('y1', 0);
        this.line.setAttribute('y2', 0);

        this.line.setAttribute('stroke', this.getAxisColor());

        if (!this.top) {

          this.labelTspan.style.dominantBaseline = 'hanging';
          this.expTspan.style.dominantBaseline = 'hanging';
          this.expTspanExp.style.dominantBaseline = 'hanging';

          this.unitTspan.style.dominantBaseline = 'hanging';
          //  this.preunitTspan.style.dominantBaseline = 'hanging';
        }

        var span = this.getSpan();
        this.line.setAttribute('marker-start', !this.options.splitMarks || span[0] == 0 ? '' : 'url(#horionzalsplit_' + this.graph.getId() + ')');
        this.line.setAttribute('marker-end', !this.options.splitMarks || span[1] == 1 ? '' : 'url(#horionzalsplit_' + this.graph.getId() + ')');
      }
    }, {
      key: '_drawLine',
      value: function _drawLine(pos, line) {

        var px = this.getPx(pos);

        if (!line) {
          line = document.createElementNS(this.graph.ns, 'line');
        } else {
          line.setAttribute('display', 'initial');
        }

        line.setAttribute('x1', px);
        line.setAttribute('x2', px);

        line.setAttribute('y1', 0);
        line.setAttribute('y2', this.graph.drawingSpaceHeight);

        line.setAttribute('stroke', 'black');
        this.group.appendChild(line);

        return line;
      }
    }, {
      key: '_hideLine',
      value: function _hideLine(line) {
        if (!line) {
          return;
        }
        line.setAttribute('display', 'none');
      }
    }, {
      key: 'handleMouseMoveLocal',
      value: function handleMouseMoveLocal(x) {
        // handleMouseMoveLocal( x, y, e )
        x -= this.graph.getPaddingLeft();
        this.mouseVal = this.getVal(x);
      }
    }, {
      key: 'setMinMaxFlipped',
      value: function setMinMaxFlipped() {

        var interval = this.maxPx - this.minPx;

        if (isNaN(interval)) {
          return;
        }

        var maxPx = interval * this.options.span[1] + this.minPx - this.options.marginMax;
        var minPx = interval * this.options.span[0] + this.minPx + this.options.marginMin;

        this.minPxFlipped = this.isFlipped() ? maxPx : minPx;
        this.maxPxFlipped = this.isFlipped() ? minPx : maxPx;
      }
    }, {
      key: 'getZProj',
      value: function getZProj(zValue) {
        return zValue * this.graph.options.zAxis.shiftX;
      }
    }]);

    return AxisX;
  }(_graphAxis2.default);

  exports.default = AxisX;
  module.exports = exports['default'];
});

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(28)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('./graph.shape.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphShape);
    global.graphShapeLine = mod.exports;
  }
})(this, function (module, exports, _graphShape) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _graphShape2 = _interopRequireDefault(_graphShape);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var ShapeLine = function (_GraphShape) {
    _inherits(ShapeLine, _GraphShape);

    function ShapeLine(graph, options) {
      _classCallCheck(this, ShapeLine);

      return _possibleConstructorReturn(this, (ShapeLine.__proto__ || Object.getPrototypeOf(ShapeLine)).call(this, graph, options));
    }

    /**
     * Creates the DOM
     * @private
     * @return {Shape} The current shape
     */


    _createClass(ShapeLine, [{
      key: 'createDom',
      value: function createDom() {

        this._dom = document.createElementNS(this.graph.ns, 'line');

        if (!this.getStrokeColor()) {
          this.setStrokeColor('black');
        }

        if (!this.getStrokeWidth()) {
          this.setStrokeWidth(1);
        }
      }
    }, {
      key: 'createHandles',
      value: function createHandles() {

        this._createHandles(2, 'rect', {
          transform: 'translate(-3 -3)',
          width: 6,
          height: 6,
          stroke: 'black',
          fill: 'white',
          cursor: 'nwse-resize'
        });
      }
    }, {
      key: 'applyPosition',
      value: function applyPosition() {

        var position = this.calculatePosition(0);
        var position2 = this.calculatePosition(1);

        if (!position || !position.x || !position.y) {
          return;
        }

        this.setDom('x2', position.x);
        this.setDom('y2', position.y);

        this.setDom('y1', position2.y);
        this.setDom('x1', position2.x);

        this.currentPos2x = position2.x;
        this.currentPos2y = position2.y;

        this.currentPos1x = position.x;
        this.currentPos1y = position.y;

        return true;
      }
    }, {
      key: 'handleMouseMoveImpl',
      value: function handleMouseMoveImpl(e, deltaX, deltaY, deltaXPx, deltaYPx) {

        if (this.isLocked()) {
          return;
        }

        var pos = this.getPosition(0);
        var pos2 = this.getPosition(1);

        var posToChange;
        if (this.handleSelected == 1) {

          posToChange = pos;
        } else if (this.handleSelected == 2) {

          posToChange = pos2;
        }

        if (posToChange) {

          if (!this._data.vertical) {
            posToChange.deltaPosition('x', deltaX, this.getXAxis());
          }

          if (!this._data.horizontal) {
            posToChange.deltaPosition('y', deltaY, this.getYAxis());
          }
        }

        if (this.moving) {
          console.log(this._data);
          // If the pos2 is defined by a delta, no need to move them
          if (pos.x && !this._data.noX) {
            pos.deltaPosition('x', deltaX, this.getXAxis());
          }
          if (pos.y && !this._data.noY) {
            pos.deltaPosition('y', deltaY, this.getYAxis());
          }

          // If the pos2 is defined by a delta, no need to move them
          if (pos2.x && !this._data.noX) {
            pos2.deltaPosition('x', deltaX, this.getXAxis());
          }
          if (pos2.y && !this._data.noY) {
            pos2.deltaPosition('y', deltaY, this.getYAxis());
          }
        }

        if (this._data.forcedCoords) {

          var forced = this._data.forcedCoords;

          if (forced.y !== undefined) {

            if (typeof forced.y == 'function') {
              pos2.y = pos.y = forced.y(this);
            } else {
              pos2.y = forced.y;
              pos.y = forced.y;
            }
          }

          if (forced.x !== undefined) {

            if (typeof forced.x == 'function') {
              pos2.x = pos.x = forced.x(this);
            } else {
              pos2.x = forced.x;
              pos.x = forced.x;
            }
          }
        }

        if (this.rectEvent) {
          this.setEventReceptacle();
        }

        this.redraw();
        this.changed();
        this.setHandles();

        return true;
      }
    }, {
      key: 'setHandles',
      value: function setHandles() {

        if (!this.areHandlesInDom()) {
          return;
        }

        if (isNaN(this.currentPos1x)) {
          return;
        }

        this.handles[1].setAttribute('x', this.currentPos1x);
        this.handles[1].setAttribute('y', this.currentPos1y);

        this.handles[2].setAttribute('x', this.currentPos2x);
        this.handles[2].setAttribute('y', this.currentPos2y);
      }
    }, {
      key: 'setEventReceptacle',
      value: function setEventReceptacle() {

        if (!this.currentPos1x) {
          return;
        }

        if (!this.rectEvent) {
          this.rectEvent = document.createElementNS(this.graph.ns, 'line');
          this.rectEvent.setAttribute('pointer-events', 'stroke');
          this.rectEvent.setAttribute('stroke', 'transparent');
          this.rectEvent.jsGraphIsShape = this;
          this.group.appendChild(this.rectEvent);
        }

        this.rectEvent.setAttribute('x1', this.currentPos1x);
        this.rectEvent.setAttribute('y1', this.currentPos1y);
        this.rectEvent.setAttribute('x2', this.currentPos2x);
        this.rectEvent.setAttribute('y2', this.currentPos2y);
        this.rectEvent.setAttribute('stroke-width', this.getProp('strokeWidth') + 2);
      }
    }]);

    return ShapeLine;
  }(_graphShape2.default);

  exports.default = ShapeLine;
  module.exports = exports['default'];
});

/***/ }),
/* 103 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(7) && !__webpack_require__(3)(function () {
  return Object.defineProperty(__webpack_require__(75)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(6);


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(15);
var toIObject = __webpack_require__(16);
var arrayIndexOf = __webpack_require__(59)(false);
var IE_PROTO = __webpack_require__(77)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(8);
var anObject = __webpack_require__(1);
var getKeys = __webpack_require__(37);

module.exports = __webpack_require__(7) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(16);
var gOPN = __webpack_require__(40).f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __webpack_require__(37);
var gOPS = __webpack_require__(60);
var pIE = __webpack_require__(53);
var toObject = __webpack_require__(10);
var IObject = __webpack_require__(52);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(3)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var aFunction = __webpack_require__(11);
var isObject = __webpack_require__(4);
var invoke = __webpack_require__(111);
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};


/***/ }),
/* 111 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

var $parseInt = __webpack_require__(2).parseInt;
var $trim = __webpack_require__(48).trim;
var ws = __webpack_require__(81);
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

var $parseFloat = __webpack_require__(2).parseFloat;
var $trim = __webpack_require__(48).trim;

module.exports = 1 / $parseFloat(__webpack_require__(81) + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

var cof = __webpack_require__(21);
module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(4);
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};


/***/ }),
/* 116 */
/***/ (function(module, exports) {

// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var sign = __webpack_require__(84);
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(1);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(11);
var toObject = __webpack_require__(10);
var IObject = __webpack_require__(52);
var toLength = __webpack_require__(9);

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)

var toObject = __webpack_require__(10);
var toAbsoluteIndex = __webpack_require__(38);
var toLength = __webpack_require__(9);

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};


/***/ }),
/* 121 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags()
if (__webpack_require__(7) && /./g.flags != 'g') __webpack_require__(8).f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(64)
});


/***/ }),
/* 123 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(1);
var isObject = __webpack_require__(4);
var newPromiseCapability = __webpack_require__(99);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(126);
var validate = __webpack_require__(50);
var MAP = 'Map';

// 23.1 Map Objects
module.exports = __webpack_require__(68)(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP = __webpack_require__(8).f;
var create = __webpack_require__(39);
var redefineAll = __webpack_require__(44);
var ctx = __webpack_require__(20);
var anInstance = __webpack_require__(42);
var forOf = __webpack_require__(43);
var $iterDefine = __webpack_require__(87);
var step = __webpack_require__(121);
var setSpecies = __webpack_require__(41);
var DESCRIPTORS = __webpack_require__(7);
var fastKey = __webpack_require__(32).fastKey;
var validate = __webpack_require__(50);
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(126);
var validate = __webpack_require__(50);
var SET = 'Set';

// 23.2 Set Objects
module.exports = __webpack_require__(68)(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var each = __webpack_require__(27)(0);
var redefine = __webpack_require__(13);
var meta = __webpack_require__(32);
var assign = __webpack_require__(109);
var weak = __webpack_require__(129);
var isObject = __webpack_require__(4);
var fails = __webpack_require__(3);
var validate = __webpack_require__(50);
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = __webpack_require__(68)(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var redefineAll = __webpack_require__(44);
var getWeak = __webpack_require__(32).getWeak;
var anObject = __webpack_require__(1);
var isObject = __webpack_require__(4);
var anInstance = __webpack_require__(42);
var forOf = __webpack_require__(43);
var createArrayMethod = __webpack_require__(27);
var $has = __webpack_require__(15);
var validate = __webpack_require__(50);
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = __webpack_require__(25);
var toLength = __webpack_require__(9);
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

// all object keys, includes non-enumerable and symbols
var gOPN = __webpack_require__(40);
var gOPS = __webpack_require__(60);
var anObject = __webpack_require__(1);
var Reflect = __webpack_require__(2).Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var isArray = __webpack_require__(61);
var isObject = __webpack_require__(4);
var toLength = __webpack_require__(9);
var ctx = __webpack_require__(20);
var IS_CONCAT_SPREADABLE = __webpack_require__(6)('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      spreadable = false;
      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
}

module.exports = flattenIntoArray;


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-string-pad-start-end
var toLength = __webpack_require__(9);
var repeat = __webpack_require__(83);
var defined = __webpack_require__(24);

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

var getKeys = __webpack_require__(37);
var toIObject = __webpack_require__(16);
var isEnum = __webpack_require__(53).f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) if (isEnum.call(O, key = keys[i++])) {
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(54);
var from = __webpack_require__(136);
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__(43);

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};


/***/ }),
/* 137 */
/***/ (function(module, exports) {

// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
  if (
    arguments.length === 0
      // eslint-disable-next-line no-self-compare
      || x != x
      // eslint-disable-next-line no-self-compare
      || inLow != inLow
      // eslint-disable-next-line no-self-compare
      || inHigh != inHigh
      // eslint-disable-next-line no-self-compare
      || outLow != outLow
      // eslint-disable-next-line no-self-compare
      || outHigh != outHigh
  ) return NaN;
  if (x === Infinity || x === -Infinity) return x;
  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
};


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports);
    global.fit_lm = mod.exports;
  }
})(this, function (module, exports) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    } else {
      return Array.from(arr);
    }
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var FitHost = function () {
    function FitHost(options) {
      _classCallCheck(this, FitHost);

      this.DELTAP = 1e-6;
      this.BIGVAL = 9e99;
      this.WEIGHT = 1.0;

      this.setYData(options.dataY);
      this.setXData(options.dataX);
      this.setWeight(options.weight);
      this.setInitialParams(options.params);

      if (options.subsetIndex) {
        this.setSubset.apply(this, _toConsumableArray(options.subsetIndex));
      }

      this.setFunction(options.function);

      if (options.progress) {
        this.hookIteration(options.progress);
      }

      this.options = options;
    }

    //[ [ x1, y1 ], [ x2, y2 ] ]


    _createClass(FitHost, [{
      key: 'setYData',
      value: function setYData(data) {
        // Waveform instance
        this.data = data;
      }
    }, {
      key: 'setXData',
      value: function setXData(data) {
        // Waveform instance
        this.dataX = data;
      }
    }, {
      key: 'setWeight',
      value: function setWeight(weight) {
        // Waveform instance
        this.weight = weight;
      }
    }, {
      key: 'setInitialParams',
      value: function setInitialParams(params) {
        var _this = this;

        this.parms = params;

        this.parms = this.parms.map(function (el) {
          if (typeof el == 'function') {
            return el(_this.data, _this.dataX);
          } else {
            return el;
          }
        });
        this.NPARMS = params.length;
      }
    }, {
      key: 'setSubset',
      value: function setSubset(fromIndex, toIndex) {
        if (fromIndex !== undefined && toIndex !== undefined) {
          this._from = fromIndex;
          this._to = toIndex;
        }
      }
    }, {
      key: 'hookIteration',
      value: function hookIteration(f) {
        var _this2 = this;

        this._hookIteration = function (params) {
          var data = _this2.buildFit(params, 200);
          f(data);
        };
      }
    }, {
      key: 'setFunction',
      value: function setFunction(func) {
        this._func = func;
      }
    }, {
      key: 'init',
      value: function init() {
        var _this3 = this;

        // Get data length
        if (this._from !== undefined && this._to !== undefined) {

          if (this._from >= this._to) {
            throw 'Impossible to fit negative subranges. The starting index must be lower than the ending index';
          }

          this.NPTS = this._to - this._from + 1;

          if (this.data && this.data.getLength() <= this._to) {
            throw 'Wave Y has not enough point to be fitted to subrange [' + this._from + ', ' + this._to + ']';
          }

          if (this._from < 0) {
            throw 'Impossible to fit a subrange with negative indices';
          }
        } else {

          this.NPTS = this.data.getLength();
          this._from = 0;
          this._to = this.data.getLength() - 1;
        }

        if (this.dataX && this.dataX.getLength() <= this._to) {
          throw 'Wave X has not enough point to be fitted to subrange [' + this._from + ', ' + this._to + ']';
        }

        this.arrY = this.data.getDataY();

        if (this.dataX) {
          this.arrX = this.dataX.getDataY();
        } else {
          this.arrX = this.data.getDataX();
        }

        this.resid = new Array(this.NPTS).fill(0);
        this.jac = new Array(this.NPTS).fill(0);
        this.jac = this.jac.map(function (el) {
          return new Array(_this3.NPARMS);
        });
      }
    }, {
      key: 'fit',
      value: function fit() {

        this.log('Starting the fit with initial parameter list {' + this.parms.join() + '};');
        new LM(this, this.NPARMS, this.NPTS, this._hookIteration);
        this.log('Fit successful. Output parameters {' + this.parms.join() + '};');

        this._result = this.buildFit(this.parms, 200);

        if (this.options.done) {
          this.options.done(this.parms, this._result);
        }

        return this._result;
      }
    }, {
      key: 'func',
      value: function func(x, param) {
        return this._func(x, param);
      }
    }, {
      key: 'computeResiduals',
      value: function computeResiduals() {
        var sumsq = 0;
        for (var i = 0; i < this.NPTS; i++) {
          this.resid[i] = (this.func(this.arrX[i + this._from], this.parms) - this.arrY[i + this._from]) * this.WEIGHT;
          sumsq += this.resid[i] * this.resid[i];
        }

        return sumsq;
      }
    }, {
      key: 'log',
      value: function log(message) {
        if (this.options.log) {
          console.log(message);
        }
      }
    }, {
      key: 'nudge',
      value: function nudge(dp) {

        for (var j = 0; j < this.NPARMS; j++) {
          this.parms[j] += dp[j];
        }
        return this.computeResiduals();
      }
    }, {
      key: 'buildJacobian',
      value: function buildJacobian() {
        // Allows LM to compute a new Jacobian.
        // Uses current parms[] and two-sided finite difference.
        // If current parms[] is bad, returns false.
        var delta = new Array(this.NPARMS);
        var FACTOR = 0.5 / this.DELTAP;
        var d = 0;

        for (var j = 0; j < this.NPARMS; j++) {
          for (var k = 0; k < this.NPARMS; k++) {
            delta[k] = k == j ? this.DELTAP : 0.0;
          }d = this.nudge(delta); // resid at pplus
          if (d == this.BIGVAL) {
            throw 'Bad dBuildJacobian() exit 2';
          }

          for (var i = 0; i < this.NPTS; i++) {
            this.jac[i][j] = this.getResidualElement(i);
          }

          for (var k = 0; k < this.NPARMS; k++) {
            delta[k] = k == j ? -2 * this.DELTAP : 0.0;
          }

          d = this.nudge(delta); // resid at pminus
          if (d == this.BIGVAL) {
            throw 'Bad dBuildJacobian(). exit 3';
          }

          for (var i = 0; i < this.NPTS; i++) {
            this.jac[i][j] -= this.getResidualElement(i);
          } // fetches resid[]

          for (var i = 0; i < this.NPTS; i++) {
            this.jac[i][j] *= FACTOR;
          }for (var k = 0; k < this.NPARMS; k++) {
            delta[k] = k == j ? this.DELTAP : 0.0;
          }d = this.nudge(delta);
          if (d == this.BIGVAL) {
            throw 'Bad dBuildJacobian(). exit 4';
          }
        }
        return true;
      }
    }, {
      key: 'getResidualElement',
      value: function getResidualElement(i) {
        // Allows LM to see one element of the resid[] vector.
        return this.resid[i];
      }
    }, {
      key: 'getJacobianElement',
      value: function getJacobianElement(i, j) {
        // Allows LM to see one element of the Jacobian matrix.
        return this.jac[i][j];
      }
    }, {
      key: 'buildFit',
      value: function buildFit(parms, length) {
        var x = void 0;

        if (!length) {
          x = this.arrX;
        } else {

          var xmin = this.dataX.getMin(this._from, this._to);
          var xmax = this.dataX.getMax(this._from, this._to);

          x = new Array(length).fill(0).map(function (el, index) {
            return index * (xmax - xmin) / (length - 1) + xmin;
          });
        }

        var fit = new Array(x.length);
        for (var i = 0, l = x.length; i < l; i++) {
          fit[i] = this.func(x[i], this.parms);
        }

        var waveformResult = this.options.waveform;
        waveformResult.setData(fit, x);
        //waveformResult.setXWaveform( x );

        return waveformResult;
      }
    }]);

    return FitHost;
  }();

  var LM = function () {
    function LM(gH, gnadj, gnpnts, hook) {
      var _this4 = this;

      _classCallCheck(this, LM);

      this.LMITER = 100; // max number of L-M iterations
      this.LMBOOST = 2.0; // damping increase per failed step
      this.LMSHRINK = 0.10; // damping decrease per successful step
      this.LAMBDAZERO = 0.001; // initial damping
      this.LAMBDAMAX = 1E9; // max damping
      this.LMTOL = 1E-12; // exit tolerance
      this.BIGVAL = 9e99; // trouble flag

      this.sos;
      this.sosprev;
      this.lambda;

      this.myH = null; // overwritten by constructor
      this.nadj = 0; // overwritten by constructor
      this.npts = 0; // overwritten by constructor

      this.delta; // local parm change
      this.beta;
      this.alpha;
      this.amatrix;

      // Constructor sets up fields and drives iterations.
      this.myH = gH;
      this.nadj = gnadj;
      this.npts = gnpnts;

      this.delta = new Array(this.nadj).fill(0);
      this.beta = new Array(this.nadj).fill(0);

      this.alpha = new Array(this.nadj).fill(0);
      this.amatrix = new Array(this.nadj).fill(0);

      this.alpha = this.alpha.map(function () {
        return new Array(_this4.nadj);
      });
      this.amatrix = this.amatrix.map(function () {
        return new Array(_this4.nadj);
      });

      this.lambda = this.LAMBDAZERO;

      var niter = 0;
      var done = false;
      do {
        done = this.bLMiter();

        if (hook) {
          hook(this.myH.params);
        }

        niter++;
      } while (!done && niter < this.LMITER);
    }

    _createClass(LM, [{
      key: 'bLMiter',
      value: function bLMiter() {
        // Each call performs one LM iteration.
        // Returns true if done with iterations; false=wants more.
        // Global nadj, npts; needs nadj, myH to be preset.
        // Ref: M.Lampton, Computers in Physics v.11 pp.110-115 1997.
        for (var k = 0; k < this.nadj; k++) {
          this.delta[k] = 0.0;
        }this.sos = this.myH.nudge(this.delta);
        if (this.sos == this.BIGVAL) {
          console.error('  bLMiter finds faulty initial nudge()');
          return false;
        }
        this.sosprev = this.sos;

        this.myH.log('  bLMiter..SumOfSquares= ' + this.sos);
        if (!this.myH.buildJacobian()) {
          console.error('  bLMiter finds buildJacobian()=false');
          return false;
        }

        for (var k = 0; k < this.nadj; k++) // get downhill gradient beta
        {
          this.beta[k] = 0.0;
          for (var i = 0; i < this.npts; i++) {
            this.beta[k] -= this.myH.getResidualElement(i) * this.myH.getJacobianElement(i, k);
          }
        }

        for (var k = 0; k < this.nadj; k++) {
          // get curvature matrix alpha
          for (var j = 0; j < this.nadj; j++) {
            this.alpha[j][k] = 0.0;
            for (var i = 0; i < this.npts; i++) {
              this.alpha[j][k] += this.myH.getJacobianElement(i, j) * this.myH.getJacobianElement(i, k);
            }
          }
        }var rrise = 0;
        do // inner damping loop searches for one downhill step
        {
          for (var k = 0; k < this.nadj; k++) {
            // copy and damp it
            for (var j = 0; j < this.nadj; j++) {
              this.amatrix[j][k] = this.alpha[j][k] + (j == k ? this.lambda : 0.0);
            }
          }

          this.gaussj(this.amatrix, this.nadj); // invert

          for (var k = 0; k < this.nadj; k++) // compute delta[]
          {
            this.delta[k] = 0.0;
            for (var j = 0; j < this.nadj; j++) {
              this.delta[k] += this.amatrix[j][k] * this.beta[j];
            }
          }
          this.sos = this.myH.nudge(this.delta); // try it out.
          if (this.sos == this.BIGVAL) {
            console.error('  LMinner failed SOS step');
            return false;
          }
          rrise = (this.sos - this.sosprev) / (1 + this.sos);
          if (rrise <= 0.0) // good step!
            {
              this.lambda *= this.LMSHRINK; // shrink lambda
              break; // leave lmInner.
            }
          for (var q = 0; q < this.nadj; q++) {
            // reverse course!
            this.delta[q] *= -1.0;
          }
          this.myH.nudge(this.delta); // sosprev should still be OK
          if (rrise < this.LMTOL) {
            // finished but keep prev parms
            break; // leave inner loop
          }
          this.lambda *= this.LMBOOST; // else try more damping.
        } while (this.lambda < this.LAMBDAMAX);
        return rrise > -this.LMTOL || this.lambda > this.LAMBDAMAX;
      }
    }, {
      key: 'gaussj',
      value: function gaussj(a, N) {
        // Inverts the double array a[N][N] by Gauss-Jordan method
        // M.Lampton UCB SSL (c)2003, 2005

        var det = 1.0,
            big,
            save;
        var i, j, k, L;
        var ik = new Array(100);
        var jk = new Array(100);

        for (k = 0; k < N; k++) {
          big = 0.0;
          for (i = k; i < N; i++) {
            for (j = k; j < N; j++) {
              // find biggest element
              if (Math.abs(big) <= Math.abs(a[i][j])) {
                big = a[i][j];
                ik[k] = i;
                jk[k] = j;
              }
            }
          }if (big == 0.0) return 0.0;
          i = ik[k];
          if (i > k) for (j = 0; j < N; j++) // exchange rows
          {
            save = a[k][j];
            a[k][j] = a[i][j];
            a[i][j] = -save;
          }
          j = jk[k];
          if (j > k) for (i = 0; i < N; i++) {
            save = a[i][k];
            a[i][k] = a[i][j];
            a[i][j] = -save;
          }
          for (i = 0; i < N; i++) {
            // build the inverse
            if (i != k) a[i][k] = -a[i][k] / big;
          }for (i = 0; i < N; i++) {
            for (j = 0; j < N; j++) {
              if (i != k && j != k) a[i][j] += a[i][k] * a[k][j];
            }
          }for (j = 0; j < N; j++) {
            if (j != k) a[k][j] /= big;
          }a[k][k] = 1.0 / big;
          det *= big; // bomb point
        } // end k loop
        for (L = 0; L < N; L++) {
          k = N - L - 1;
          j = ik[k];
          if (j > k) for (i = 0; i < N; i++) {
            save = a[i][k];
            a[i][k] = -a[i][j];
            a[i][j] = save;
          }
          i = jk[k];
          if (i > k) for (j = 0; j < N; j++) {
            save = a[k][j];
            a[k][j] = -a[i][j];
            a[i][j] = save;
          }
        }
        return det;
      }
    }]);

    return LM;
  }();

  exports.default = FitHost;
  module.exports = exports['default'];
});

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(73)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('./graph.axis.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphAxis);
    global.graphAxisY = mod.exports;
  }
})(this, function (module, exports, _graphAxis) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _graphAxis2 = _interopRequireDefault(_graphAxis);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var AxisY = function (_Axis) {
    _inherits(AxisY, _Axis);

    function AxisY(graph, leftright, options) {
      _classCallCheck(this, AxisY);

      var _this = _possibleConstructorReturn(this, (AxisY.__proto__ || Object.getPrototypeOf(AxisY)).call(this, graph, leftright, options));

      _this.leftright = leftright;
      _this.left = leftright == 'left';

      return _this;
    }

    /**
     *  @private
     */


    _createClass(AxisY, [{
      key: 'setAxisPosition',
      value: function setAxisPosition(shift) {
        this.shiftPosition = shift;
      }
    }, {
      key: 'getAxisPosition',
      value: function getAxisPosition() {
        return this.shiftPosition || 0;
      }
    }, {
      key: 'getAdditionalWidth',
      value: function getAdditionalWidth() {
        var pos = 0;
        if (this.getLabel()) {
          pos += this.graph.options.fontSize;
        }

        if (this.isShown()) {
          pos += Math.abs(this.tickMargin);
        }
        return pos;
      }
    }, {
      key: 'isX',
      value: function isX() {
        return false;
      }
    }, {
      key: 'isY',
      value: function isY() {
        return true;
      }
    }, {
      key: 'resetTicksLength',
      value: function resetTicksLength() {
        this.longestTick = [false, 0];
      }
    }, {
      key: 'getMaxSizeTick',
      value: function getMaxSizeTick() {
        // Gives an extra margin of 5px
        return this.longestTick && this.longestTick[0] ? this.longestTick[0].getComputedTextLength() + 5 : 0; //(this.left ? 10 : 0);
      }
    }, {
      key: 'draw',
      value: function draw() {

        this.tickMargin = this.left ? -5 - this.tickPx1 * this.tickScaling[1] : 2 - this.tickPx1 * this.tickScaling[1];
        var tickWidth = _get(AxisY.prototype.__proto__ || Object.getPrototypeOf(AxisY.prototype), 'draw', this).apply(this, arguments);
        tickWidth += this.getAdditionalWidth();
        this.drawSpecifics(tickWidth);

        this.fullwidthlabel = tickWidth;

        return tickWidth;
      }
    }, {
      key: 'equalizePosition',
      value: function equalizePosition(width) {

        this.placeLabel(this.left ? -width : width);

        if (this.getLabel()) {
          return width + this.graph.options.fontSize;
        }

        return 0;
      }
    }, {
      key: 'drawTick',
      value: function drawTick(value, level, options, forcedPos) {
        var _this2 = this;

        var pos = void 0,
            tick = void 0,
            tickLabel = void 0;

        pos = forcedPos || this.getPos(value);

        if (pos == undefined || isNaN(pos)) {
          return;
        }

        tick = this.nextTick(level, function (tick) {

          tick.setAttribute('x1', (_this2.left ? 1 : -1) * _this2.tickPx1 * _this2.tickScaling[level]);
          tick.setAttribute('x2', (_this2.left ? 1 : -1) * _this2.tickPx2 * _this2.tickScaling[level]);

          if (level == 1) {
            tick.setAttribute('stroke', _this2.getPrimaryTicksColor());
          } else {
            tick.setAttribute('stroke', _this2.getSecondaryTicksColor());
          }
        });

        tick.setAttribute('y1', pos);
        tick.setAttribute('y2', pos);

        this.nextGridLine(level == 1, 0, this.graph.getDrawingWidth(), pos, pos);

        //  this.groupTicks.appendChild( tick );
        if (level == 1) {
          tickLabel = this.nextTickLabel(function (tickLabel) {

            tickLabel.setAttribute('x', _this2.tickMargin + _this2.options.tickLabelOffset);
            if (_this2.getTicksLabelColor() !== 'black') {
              tickLabel.setAttribute('fill', _this2.getTicksLabelColor());
            }

            if (_this2.left) {
              tickLabel.setAttribute('text-anchor', 'end');
            } else {
              tickLabel.setAttribute('text-anchor', 'start');
            }
            tickLabel.style.dominantBaseline = 'central';
          });

          tickLabel.setAttribute('y', pos);
          this.setTickContent(tickLabel, value, options);

          if (String(tickLabel.textContent).length >= this.longestTick[1]) {
            this.longestTick[0] = tickLabel;
            this.longestTick[1] = String(tickLabel.textContent).length;
          }
        }
      }
    }, {
      key: 'drawLabel',
      value: function drawLabel() {

        if (this.getLabelColor() !== 'black') {
          this.label.setAttribute('fill', this.getLabelColor());
        }

        this.label.setAttribute('dominant-baseline', !this.left ? 'auto' : 'auto');
        this.labelTspan.textContent = this.getLabel();
      }
    }, {
      key: 'placeLabel',
      value: function placeLabel(y) {
        this.label.setAttribute('transform', 'translate(' + y + ', ' + Math.abs(this.getMaxPx() + this.getMinPx()) / 2 + ') rotate(-90)');
      }
    }, {
      key: 'drawSpecifics',
      value: function drawSpecifics() {
        // Place label correctly
        //this.label.setAttribute('x', (this.getMaxPx() - this.getMinPx()) / 2);
        /*
        if ( !this.left ) {
           this.labelTspan.style.dominantBaseline = 'hanging';
          this.expTspan.style.dominantBaseline = 'hanging';
          this.expTspanExp.style.dominantBaseline = 'hanging';
           this.unitTspan.style.dominantBaseline = 'hanging';
          this.preunitTspan.style.dominantBaseline = 'hanging';
        }
        */
        this.line.setAttribute('y1', this.getMinPx());
        this.line.setAttribute('y2', this.getMaxPx());
        this.line.setAttribute('x1', 0);
        this.line.setAttribute('x2', 0);

        this.line.setAttribute('stroke', this.getAxisColor());

        var span = this.getSpan();
        this.line.setAttribute('marker-start', !this.options.splitMarks || span[0] == 0 ? '' : 'url(#verticalsplit_' + this.graph.getId() + ')');
        this.line.setAttribute('marker-end', !this.options.splitMarks || span[1] == 1 ? '' : 'url(#verticalsplit_' + this.graph.getId() + ')');
      }
    }, {
      key: 'setShift',
      value: function setShift(shift) {

        this.shift = shift;

        if (!this.shift || !this.graph.getWidth()) {
          return;
        }

        var xshift = this.shift;
        xshift = this.floating ? xshift : this.isLeft() ? xshift : this.graph.getWidth() - this.graph.getPaddingRight() - this.graph.getPaddingLeft() - xshift;
        this.group.setAttribute('transform', 'translate( ' + xshift + ' 0 )');
        this.drawLabel();
      }
    }, {
      key: 'isLeft',
      value: function isLeft() {
        return this.left;
      }
    }, {
      key: 'isRight',
      value: function isRight() {
        return !this.left;
      }
    }, {
      key: 'isFlipped',
      value: function isFlipped() {
        return !this.options.flipped;
      }
    }, {
      key: '_drawLine',
      value: function _drawLine(pos, line) {

        var px = this.getPx(pos);

        if (!line) {
          line = document.createElementNS(this.graph.ns, 'line');
        } else {
          line.setAttribute('display', 'initial');
        }

        line.setAttribute('y1', px);
        line.setAttribute('y2', px);

        line.setAttribute('x1', 0);
        line.setAttribute('x2', this.graph.drawingSpaceWidth);

        line.setAttribute('stroke', 'black');
        this.group.appendChild(line);

        return line;
      }
    }, {
      key: '_hideLine',
      value: function _hideLine(line) {
        if (!line) {
          return;
        }

        line.setAttribute('display', 'none');
      }
    }, {
      key: 'handleMouseMoveLocal',
      value: function handleMouseMoveLocal(x, y) {
        y -= this.graph.getPaddingTop();
        this.mouseVal = this.getVal(y);
      }
    }, {
      key: 'scaleToFitAxis',
      value: function scaleToFitAxis(axis, excludeSerie, start, end, min, max) {
        //console.log( axis instanceof GraphAxis );
        if (!axis || !axis.isX()) {
          axis = this.graph.getXAxis();
        }

        if (isNaN(start)) {
          start = axis.getCurrentMin();
        }

        if (isNaN(end)) {
          end = axis.getCurrentMax();
        }

        if (min === undefined) {
          min = true;
        }

        if (max === undefined) {
          max = true;
        }

        if (typeof excludeSerie == 'number') {
          end = start;
          start = excludeSerie;
          excludeSerie = false;
        }

        var maxV = -Infinity,
            minV = Infinity,
            j = 0;

        for (var i = 0, l = this.graph.series.length; i < l; i++) {

          if (!this.graph.series[i].isShown()) {
            continue;
          }

          if (this.graph.series[i] == excludeSerie) {
            continue;
          }

          if (!(this.graph.series[i].getXAxis() == axis) || this.graph.series[i].getYAxis() !== this) {
            continue;
          }

          j++;

          maxV = max ? Math.max(maxV, this.graph.series[i].getMax(start, end)) : 0;
          minV = min ? Math.min(minV, this.graph.series[i].getMin(start, end)) : 0;
        }

        if (j == 0) {

          this.setMinMaxToFitSeries(); // No point was found
        } else {

          // If we wanted originally to resize min and max. Otherwise we use the current value
          minV = min ? minV : this.getCurrentMin();
          maxV = max ? maxV : this.getCurrentMax();

          var interval = maxV - minV;

          minV -= this.options.axisDataSpacing.min * interval;
          maxV += this.options.axisDataSpacing.max * interval;

          this._doZoomVal(minV, maxV);
        }

        return this;
      }
    }, {
      key: 'setMinMaxFlipped',
      value: function setMinMaxFlipped() {

        var interval = this.maxPx - this.minPx;

        if (isNaN(interval)) {
          return;
        }

        var maxPx = this.maxPx - interval * this.options.span[0] - this.options.marginMin;
        var minPx = this.maxPx - interval * this.options.span[1] + this.options.marginMax;

        this.minPxFlipped = this.isFlipped() ? maxPx : minPx;
        this.maxPxFlipped = this.isFlipped() ? minPx : maxPx;
      }
    }, {
      key: 'getZProj',
      value: function getZProj(zValue) {
        return zValue * this.graph.options.zAxis.shiftY;
      }
    }]);

    return AxisY;
  }(_graphAxis2.default);

  exports.default = AxisY;
  module.exports = exports['default'];
});

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports);
    global.graphMixinSerie3d = mod.exports;
  }
})(this, function (module, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var Serie3DMixin = {

    /**
     * Returns the x position of a certain value in pixels position, based on the serie's axis
     * @memberof Serie
     * @param {Number} val - Value to convert to pixels position
     * @returns {Number} The x position in px corresponding to the x value
     */
    getX: function getX(val) {
      return (val = this.getXAxis().getPx(val)) - val % 0.2 + this.getXAxis().getZProj(this.options.zpos);
    },

    /**
     * Returns the y position of a certain value in pixels position, based on the serie's axis
     * @memberof Serie3DMixin
     * @param {Number} val - Value to convert to pixels position
     * @returns {Number} The y position in px corresponding to the y value
     */
    getY: function getY(val) {
      return (val = this.getYAxis().getPx(val)) - val % 0.2 + this.getYAxis().getZProj(this.options.zpos);
    },

    getZPos: function getZPos() {
      return this.options.zpos;
    },

    /**
     * @returns {Number} Lowest x value of the serie's data
     * @memberof Serie
     */
    getMinX: function getMinX(useZValues) {
      if (!useZValues) {
        return this.minX;
      }

      return getZCorrectedValue(this, true, true);
    },

    /**
     * @returns {Number} Highest x value of the serie's data
     * @memberof Serie
     */
    getMaxX: function getMaxX(useZValues) {

      if (!useZValues) {
        return this.maxX;
      }
      return getZCorrectedValue(this, true, false);
    },

    /**
     * @returns {Number} Lowest y value of the serie's data
     * @memberof Serie
     */
    getMinY: function getMinY(useZValues) {

      if (!useZValues) {
        return this.minY;
      }
      return getZCorrectedValue(this, false, true);
    },

    /**
     * @returns {Number} Highest y value of the serie's data
     * @memberof Serie
     */
    getMaxY: function getMaxY(useZValues) {

      if (!useZValues) {
        return this.maxY;
      }
      return getZCorrectedValue(this, false, false);
    }

  };

  function getZCorrectedValue(serie, x, min) {

    var i = void 0,
        l = void 0,
        data = void 0,
        val = void 0,
        valFinal = void 0;
    var wf = serie.getWaveforms();

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = wf[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var wave = _step.value;


        i = 0;
        l = wave.getLength();
        data = wave.getData();

        for (; i < l; i += 1) {

          if (x) {
            val = serie.getXAxis().getVal(serie.getX(wave.getX(i, true)));
          } else {
            val = serie.getYAxis().getVal(serie.getY(data[i]));
          }

          if (i == 0) {
            valFinal = val;
          } else {

            if (min) {
              valFinal = Math.min(valFinal, val);
            } else {
              valFinal = Math.max(valFinal, val);
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return valFinal;
  }

  exports.default = Serie3DMixin;
  module.exports = exports["default"];
});

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(5), __webpack_require__(74), __webpack_require__(57)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('../graph.util.js'), require('../mixins/graph.mixin.errorbars.js'), require('./graph.serie.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphUtil, global.graphMixinErrorbars, global.graphSerie);
    global.graphSerieScatter = mod.exports;
  }
})(this, function (module, exports, _graphUtil, _graphMixinErrorbars, _graphSerie) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var util = _interopRequireWildcard(_graphUtil);

  var _graphMixinErrorbars2 = _interopRequireDefault(_graphMixinErrorbars);

  var _graphSerie2 = _interopRequireDefault(_graphSerie);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var defaults = {};

  var type = 'scatter';

  /**
   * @static
   * @augments Serie
   * @example graph.newSerie( name, options, "scatter" );
   * @see Graph#newSerie
   */

  var SerieScatter = function (_Serie) {
    _inherits(SerieScatter, _Serie);

    function SerieScatter(graph, name, options) {
      _classCallCheck(this, SerieScatter);

      var _this = _possibleConstructorReturn(this, (SerieScatter.__proto__ || Object.getPrototypeOf(SerieScatter)).apply(this, arguments));

      _this.id = Math.random() + Date.now();
      _this.shapes = []; // Stores all shapes
      _this.shown = true;
      _this.data = [];

      _this.shapesDetails = [];
      _this.shapes = [];

      _this._type = type;

      util.mapEventEmission(_this.options, _this);

      _this._isMinOrMax = {
        x: {
          min: false,
          max: false
        },
        y: {
          min: false,
          max: false
        }
      };

      _this.groupPoints = document.createElementNS(_this.graph.ns, 'g');
      _this.groupMain = document.createElementNS(_this.graph.ns, 'g');

      _this.additionalData = {};

      _this.selectedStyleGeneral = {};
      _this.selectedStyleModifiers = {};

      _this.groupPoints.addEventListener('mouseover', function (e) {
        var id = parseInt(e.target.parentElement.getAttribute('data-shapeid'));
        _this.emit('mouseover', id, _this.waveform.getX(id), _this.waveform.getY(id));
      });

      _this.groupPoints.addEventListener('mouseout', function (e) {
        var id = parseInt(e.target.parentElement.getAttribute('data-shapeid'));
        _this.emit('mouseout', id, _this.waveform.getX(id), _this.waveform.getY(id));
      });

      _this.minX = Number.MAX_VALUE;
      _this.minY = Number.MAX_VALUE;
      _this.maxX = Number.MIN_VALUE;
      _this.maxY = Number.MIN_VALUE;

      _this.groupMain.appendChild(_this.groupPoints);
      _this.currentAction = false;

      if (_this.initExtended1) {
        _this.initExtended1();
      }

      _this.styles = {};
      _this.styles.unselected = {};
      _this.styles.selected = {};

      _this.styles.unselected.default = {
        shape: 'circle',
        cx: 0,
        cy: 0,
        r: 3,
        stroke: 'transparent',
        fill: 'black'
      };

      _this.styles.selected.default = {
        shape: 'circle',
        cx: 0,
        cy: 0,
        r: 4,
        stroke: 'transparent',
        fill: 'black'
      };

      return _this;
    }

    /**
     * Applies for x as the category axis
     * @example serie.setDataCategory( { x: "someName", y: Waveform } );
     */


    _createClass(SerieScatter, [{
      key: 'setDataCategory',
      value: function setDataCategory(data) {

        var minY = +Infinity;
        var maxY = -Infinity;

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var dataCategory = _step.value;


            this._checkY(dataCategory.y.getMaxY());
            this._checkY(dataCategory.y.getMinY());
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        this.data = data;
        this.dataHasChanged();
        this.graph.updateDataMinMaxAxes();
        return this;
      }
    }, {
      key: 'empty',
      value: function empty() {

        while (this.groupPoints.firstChild) {
          this.groupPoints.removeChild(this.groupPoints.firstChild);
        }
      }
    }, {
      key: 'getSymbolForLegend',
      value: function getSymbolForLegend() {

        if (this.symbol) {
          return this.symbol;
        }

        var g = document.createElementNS(this.graph.ns, 'g');
        g.setAttribute('data-shapeid', -1);
        var shape = this.doShape(g, this.styles.unselected.default);

        var style = this.getStyle('unselected', -1, true);

        for (var i in style[-1]) {
          if (i == 'shape') {
            continue;
          }
          shape.setAttribute(i, style[-1][i]);
        }

        return g;
      }
    }, {
      key: 'setStyle',
      value: function setStyle(all, modifiers) {
        var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'unselected';


        if (typeof modifiers == 'string') {
          mode = modifiers;
          modifiers = false;
        }

        /*
        if( ! this.styles[ mode ] ) {
         }
         if ( mode !== "selected" && mode !== "unselected" ) {
          throw "Style mode is not correct. Should be selected or unselected";
        }
        */

        this.styles[mode] = this.styles[mode] || {};
        this.styles[mode].all = all;
        this.styles[mode].modifiers = modifiers;

        this.styleHasChanged(mode);

        return this;
      }
    }, {
      key: 'draw',
      value: function draw(force) {
        // Serie redrawing

        if (!force && !this.hasDataChanged() && !this.hasStyleChanged('unselected')) {
          return;
        }

        var x,
            y,
            xpx,
            ypx,
            j = 0,
            k,
            m,
            currentLine,
            max;

        var isCategory = this.getXAxis().getType() == 'category';

        this._drawn = true;

        this.dataHasChanged(false);
        this.styleHasChanged(false);
        this.groupMain.removeChild(this.groupPoints);

        var keys = [];

        j = 0;
        k = 0;

        if (this.hasErrors()) {
          this.errorDrawInit();
        }

        if (isCategory) {

          var _k = 0;

          for (; j < this.data.length; j++) {

            if (!this.categoryIndices.hasOwnProperty(this.data[j].x)) {
              continue;
            }

            if (this.error) {
              //   this.errorAddPoint( j, position[ 0 ] + position[ 1 ] / 2, 0, this.getX( position[ 0 ] + position[ 1 ] / 2 ), ypx );
            }

            for (var n = 0, l = this.data[j].y.getLength(); n < l; n++) {

              //let xpos = i / ( l - 1 ) * ( position[ 1 ] ) + position[ 0 ];

              ypx = this.getY(this.data[j].y.getY(n));
              xpx = this.getX(n / (l - 1) * (0.8 / this.nbCategories) + this.categoryIndices[this.data[j].x] + 0.1 / this.nbCategories);
              n++;

              this.shapesDetails[_k] = this.shapesDetails[_k] || [];
              this.shapesDetails[_k][0] = xpx;
              this.shapesDetails[_k][1] = ypx;
              keys.push(_k);
              _k++;
            }
          }
        } else {

          for (; j < this.waveform.getLength(); j++) {

            if (this.waveform.getX(j) < this.getXAxis().getCurrentMin() || this.waveform.getX(j) > this.getXAxis().getCurrentMax() || this.waveform.getY(j) < this.getYAxis().getCurrentMin() || this.waveform.getY(j) > this.getYAxis().getCurrentMax()) {

              if (this.shapes[j]) {
                this.shapes[j].setAttribute('display', 'none');
              }
              continue;
            }

            if (this.shapes[j]) {
              this.shapes[j].setAttribute('display', 'initial');
            }

            xpx = this.getX(this.waveform.getX(j));
            ypx = this.getY(this.waveform.getY(j));

            if (this.hasErrors()) {
              this.errorAddPoint(j, this.waveform.getX(j), this.waveform.getY(j), xpx, ypx);
            }

            this.shapesDetails[j] = this.shapesDetails[j] || [];
            this.shapesDetails[j][0] = xpx;
            this.shapesDetails[j][1] = ypx;
            keys.push(j);

            //this.shapes[ j / 2 ] = this.shapes[ j / 2 ] || undefined;
          }
        }

        if (this.hasErrors()) {
          this.errorDraw();
        }

        // This will automatically create the shapes
        this.applyStyle('unselected', keys);

        this.groupMain.appendChild(this.groupPoints);
      }
    }, {
      key: '_addPoint',
      value: function _addPoint(xpx, ypx, k) {

        var shape = void 0;
        var g = document.createElementNS(this.graph.ns, 'g');
        g.setAttribute('transform', 'translate(' + xpx + ', ' + ypx + ')');
        g.setAttribute('data-shapeid', k);

        if (this.extraStyle && this.extraStyle[k]) {

          shape = this.doShape(g, this.extraStyle[k]);
        } else if (this.stdStylePerso) {

          shape = this.doShape(g, this.stdStylePerso);
        } else {

          shape = this.doShape(g, this.stdStyle);
        }

        this.shapes[k] = shape;
        this.groupPoints.appendChild(g);
      }
    }, {
      key: 'doShape',
      value: function doShape(group, shape) {
        var el = document.createElementNS(this.graph.ns, shape.shape);
        group.appendChild(el);
        return el;
      }
    }, {
      key: 'getStyle',
      value: function getStyle(selection, index, noSetPosition) {

        var selection = selection || 'unselected';
        var indices;

        var styles = {};

        if (typeof index == 'number') {
          indices = [index];
        } else if (Array.isArray(index)) {
          indices = index;
        }

        var shape, index, modifier, style, j; // loop variables
        var styleAll;

        if (this.styles[selection].all !== undefined) {

          styleAll = this.styles[selection].all;

          if (typeof styleAll == 'function') {

            styleAll = styleAll();
          } else if (styleAll === false) {

            styleAll = {};
          }
        }

        var i = 0,
            l = indices.length;

        for (; i < l; i++) {

          index = indices[i];
          shape = this.shapes[index];

          if ((modifier = this.styles[selection].modifiers) && (typeof modifier == 'function' || modifier[index])) {

            if (typeof modifier == 'function') {

              style = modifier(index, shape);
            } else if (modifier[index]) {

              style = modifier[index];
            }

            styles[index] = Object.assign({}, styleAll, style);
          } else if (styleAll !== undefined) {

            styles[index] = styleAll;
          } else {

            styles[index] = this.styles[selection].default;
          }

          if (!styles[index]) {
            styles[index] = styleAll;
          }

          if (!shape) {
            // Shape doesn't exist, let's create it

            if (!styles[index].shape) {
              console.error(style);
              throw 'No shape was defined with this style.';
            }

            var g = document.createElementNS(this.graph.ns, 'g');
            g.setAttribute('data-shapeid', index);
            this.shapes[index] = this.doShape(g, styles[index]);
            this.groupPoints.appendChild(g);
            shape = this.shapes[index];
          }

          if (!noSetPosition) {
            shape.parentNode.setAttribute('transform', 'translate(' + this.shapesDetails[index][0] + ', ' + this.shapesDetails[index][1] + ')');
          }
        }

        return styles;
      }
    }, {
      key: 'applyStyle',
      value: function applyStyle(selection, index, noSetPosition) {

        var i, j;
        var styles = this.getStyle(selection, index, noSetPosition);

        for (i in styles) {

          for (j in styles[i]) {

            if (j !== 'shape') {

              if (styles[i][j]) {

                this.shapes[i].setAttribute(j, styles[i][j]);
              } else {

                this.shapes[i].removeAttribute(j);
              }
            }
          }
        }
      }
    }, {
      key: 'unselectPoint',
      value: function unselectPoint(index) {
        this.selectPoint(index, false);
      }
    }, {
      key: 'selectPoint',
      value: function selectPoint(index, setOn, selectionType) {

        if (this.shapesDetails[index][2] && this.shapesDetails[index][2] == selectionType) {
          return;
        }

        if (typeof setOn == 'string') {
          selectionType = setOn;
          setOn = undefined;
        }

        if (Array.isArray(index)) {
          return this.selectPoints(index);
        }

        if (this.shapes[index] && this.shapesDetails[index]) {

          if ((this.shapesDetails[index][2] || setOn === false) && setOn !== true) {

            var selectionStyle = this.shapesDetails[index][2];
            this.shapesDetails[index][2] = false;

            var allStyles = this.getStyle(selectionStyle, index, true);
            for (var i in allStyles[index]) {
              this.shapes[index].removeAttribute(i);
            }

            this.applyStyle('unselected', index, true);
          } else {

            selectionType = selectionType || 'selected';
            this.shapesDetails[index][2] = selectionType;

            this.applyStyle(selectionType, index, true);
          }
        }
      }
    }, {
      key: 'getUsedCategories',
      value: function getUsedCategories() {

        if (_typeof(this.data[0]) == 'object') {
          return this.data.map(function (d) {
            return d.x;
          });
        }

        return [];
      }
    }]);

    return SerieScatter;
  }(_graphSerie2.default);

  util.mix(SerieScatter, _graphMixinErrorbars2.default);

  exports.default = SerieScatter;
  module.exports = exports['default'];
});

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(46), __webpack_require__(5), __webpack_require__(57)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('../util/waveform.js'), require('../graph.util.js'), require('./graph.serie.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.waveform, global.graphUtil, global.graphSerie);
    global.graphSerieZone = mod.exports;
  }
})(this, function (module, exports, _waveform, _graphUtil, _graphSerie) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _waveform2 = _interopRequireDefault(_waveform);

  var _graphSerie2 = _interopRequireDefault(_graphSerie);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var SerieZone = function (_Serie) {
    _inherits(SerieZone, _Serie);

    _createClass(SerieZone, null, [{
      key: 'default',
      value: function _default() {
        return {
          fillColor: 'rgba( 0, 0, 0, 0.1 )',
          lineColor: 'rgba( 0, 0, 0, 1 )',
          lineWidth: '1px'
        };
      }
    }]);

    function SerieZone(graph, name, options) {
      _classCallCheck(this, SerieZone);

      var _this = _possibleConstructorReturn(this, (SerieZone.__proto__ || Object.getPrototypeOf(SerieZone)).apply(this, arguments));

      _this.selectionType = 'unselected';
      _this.id = (0, _graphUtil.guid)();

      _this.groupZones = document.createElementNS(_this.graph.ns, 'g');
      _this.groupMain = document.createElementNS(_this.graph.ns, 'g');
      _this.lineZone = document.createElementNS(_this.graph.ns, 'path');
      _this.lineZone.setAttribute('stroke', 'black');
      _this.lineZone.setAttribute('stroke-width', '1px');

      _this.groupMain.appendChild(_this.groupZones);
      _this.groupZones.appendChild(_this.lineZone);

      _this.applyLineStyle(_this.lineZone);
      _this.styleHasChanged();

      _this.clip = document.createElementNS(_this.graph.ns, 'clipPath');
      _this.clipId = (0, _graphUtil.guid)();
      _this.clip.setAttribute('id', _this.clipId);

      _this.graph.defs.appendChild(_this.clip);

      return _this;
    }

    /**
     * Assigns a collection of waveforms that make up the zone
     * The waveforms will appended one after the other, without break
     * @param {...Waveform} waveforms - The collection of waveforms
     * @return {SerieZone} - The current serie zone instance
     * @memberof SerieZone
     */


    _createClass(SerieZone, [{
      key: 'setWaveform',
      value: function setWaveform() {
        var _this2 = this;

        for (var _len = arguments.length, waveforms = Array(_len), _key = 0; _key < _len; _key++) {
          waveforms[_key] = arguments[_key];
        }

        this.waveforms = waveforms;

        this.waveforms = this.waveforms.map(function (wave) {

          if (!(wave instanceof _waveform2.default)) {
            return new _waveform2.default(wave);
          } else {
            return wave;
          }
        });

        this.minX = this.waveforms[0].getXMin();
        this.maxX = this.waveforms[0].getXMax();
        this.minY = this.waveforms[0].getMin();
        this.maxY = this.waveforms[0].getMax();

        this.waveforms.map(function (wave) {

          _this2.minX = Math.min(wave.getXMin(), _this2.minX);
          _this2.maxX = Math.max(wave.getXMin(), _this2.maxX);
          _this2.minY = Math.min(wave.getMin(), _this2.minY);
          _this2.maxY = Math.max(wave.getMax(), _this2.maxY);
        });

        this.graph.updateDataMinMaxAxes();
        this.dataHasChanged();
        return this;
      }
    }, {
      key: 'setWaveforms',
      value: function setWaveforms() {
        return this.setWaveform.apply(this, arguments);
      }
    }, {
      key: 'getWaveforms',
      value: function getWaveforms() {
        return this.waveforms;
      }
    }, {
      key: 'setMinMaxWaveforms',
      value: function setMinMaxWaveforms(min, max) {
        this.waveforms = [min, max.reverse()];
        return this;
      }
    }, {
      key: 'empty',
      value: function empty() {

        while (this.group.firstChild) {
          this.group.removeChild(this.group.firstChild);
        }
      }
    }, {
      key: 'draw',
      value: function draw(force) {
        // Serie redrawing

        if (force || this.hasDataChanged()) {

          if (!this.waveforms) {
            return;
          }

          var dataX = 0,
              dataY = 0,
              xpx = 0,
              ypx = 0,
              j = 0,
              line = '',
              buffer = void 0,
              move = false;

          var xminpx = this.getXAxis().getMinPx(),
              xmaxpx = this.getXAxis().getMaxPx(),
              yminpx = this.getYAxis().getMinPx(),
              ymaxpx = this.getYAxis().getMaxPx();

          var xmin = this.getXAxis().getCurrentMin(),
              xmax = this.getXAxis().getCurrentMax(),
              ymin = this.getYAxis().getCurrentMin(),
              ymax = this.getYAxis().getCurrentMax();

          //this.clipRect.setAttribute( "x", Math.min( xmin, xmax ) );
          //this.clipRect.setAttribute( "y", Math.min( ymin, ymax ) );
          //this.clipRect.setAttribute( "width", Math.abs( xmax - xmin ) );
          //this.clipRect.setAttribute( "height", Math.abs( ymax - ymin ) );

          this.groupMain.removeChild(this.groupZones);

          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = this.waveforms[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var waveform = _step.value;


              for (j = 0; j < waveform.getLength(); j += 1) {
                dataX = waveform.getX(j, true);
                dataY = waveform.getY(j, true);

                // The y axis in screen coordinate is inverted vs cartesians
                if (dataY[j] < ymin) {
                  ypx = this.getY(ymin);
                } else if (dataY[j] > ymax) {
                  ypx = this.getY(ymax);
                }

                if (dataX !== dataX) {
                  continue;
                }

                if (dataY !== dataY) {
                  // Let's make a new line

                  if (line.length == 0) {
                    continue;
                  }

                  line += 'L ' + xpx + ', ' + this.getY(waveform.getMinY());
                  move = true;
                  continue;
                }

                ypx = this.getY(dataY);
                xpx = this.getX(dataX);

                if (dataX < xmin || dataX > xmax) {
                  buffer = [dataX, dataY[j], xpx, ypx];
                  continue;
                }

                if (move) {
                  line += ' M ' + xpx + ', ' + this.getY(waveform.getMinY()) + ' ';
                  move = false;
                }

                if (line.length > 0) {
                  line += ' L ';
                }

                if (buffer) {
                  line += buffer[2] + ',' + buffer[3] + ' ';
                  buffer = false;
                } else {
                  line += xpx + ',' + ypx + ' ';
                }
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          if (line !== '') {
            this.lineZone.setAttribute('d', 'M ' + line + ' z');
          } else {
            this.lineZone.setAttribute('d', '');
          }
          this.groupMain.appendChild(this.groupZones);
        }

        if (this.hasStyleChanged(this.selectionType)) {
          this.applyLineStyle(this.lineZone);
          this.styleHasChanged(false);
        }
      }
    }, {
      key: 'applyLineStyle',
      value: function applyLineStyle(line) {

        line.setAttribute('stroke', this.getLineColor());
        line.setAttribute('stroke-width', this.getLineWidth());
        line.setAttribute('fill', this.getFillColor());
        line.setAttribute('fill-opacity', this.getFillOpacity());
        line.setAttribute('stroke-opacity', this.getLineOpacity());
      }
    }, {
      key: 'setLineWidth',
      value: function setLineWidth(width) {
        this.options.lineWidth = width;
        this.styleHasChanged();
        return this;
      }
    }, {
      key: 'getLineWidth',
      value: function getLineWidth() {
        return this.options.lineWidth;
      }
    }, {
      key: 'setLineOpacity',
      value: function setLineOpacity(opacity) {
        this.options.lineOpacity = opacity;
        this.styleHasChanged();
        return this;
      }
    }, {
      key: 'getLineOpacity',
      value: function getLineOpacity() {
        return this.options.lineOpacity;
      }
    }, {
      key: 'setLineColor',
      value: function setLineColor(color) {
        this.options.lineColor = color;
        this.styleHasChanged();
        return this;
      }
    }, {
      key: 'getLineColor',
      value: function getLineColor() {
        return this.options.lineColor;
      }
    }, {
      key: 'setFillOpacity',
      value: function setFillOpacity(opacity) {
        this.options.fillOpacity = opacity;
        this.styleHasChanged();
        return this;
      }
    }, {
      key: 'getFillOpacity',
      value: function getFillOpacity() {
        return this.options.fillOpacity;
      }
    }, {
      key: 'setFillColor',
      value: function setFillColor(color) {
        this.options.fillColor = color;
        this.styleHasChanged();
        return this;
      }
    }, {
      key: 'getFillColor',
      value: function getFillColor() {
        return this.options.fillColor;
      }
    }]);

    return SerieZone;
  }(_graphSerie2.default);

  exports.default = SerieZone;
  module.exports = exports['default'];
});

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(5), __webpack_require__(28)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('../graph.util.js'), require('./graph.shape.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphUtil, global.graphShape);
    global.graphShapeRect = mod.exports;
  }
})(this, function (module, exports, _graphUtil, _graphShape) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var util = _interopRequireWildcard(_graphUtil);

  var _graphShape2 = _interopRequireDefault(_graphShape);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var ShapeRectangle = function (_GraphShape) {
    _inherits(ShapeRectangle, _GraphShape);

    function ShapeRectangle(graph, options) {
      _classCallCheck(this, ShapeRectangle);

      return _possibleConstructorReturn(this, (ShapeRectangle.__proto__ || Object.getPrototypeOf(ShapeRectangle)).call(this, graph, options));
    }

    /**
     * Creates the DOM
     * @private
     * @return {Shape} The current shape
     */


    _createClass(ShapeRectangle, [{
      key: 'createDom',
      value: function createDom() {
        this._dom = document.createElementNS(this.graph.ns, 'rect');

        if (!this.getStrokeColor()) {
          this.setStrokeColor('black');
        }

        if (!this.getStrokeWidth()) {
          this.setStrokeWidth(1);
        }

        if (!this.getFillColor()) {
          this.setFillColor('transparent');
        }

        return this;
      }
    }, {
      key: 'createHandles',
      value: function createHandles() {
        if (!this.hasHandles()) {
          return;
        }

        /*
              this._data.handles = this._data.handles || {
                type: 'corners'
              };
        */

        var handles = this.getProp('handles');

        if ((typeof handles === 'undefined' ? 'undefined' : _typeof(handles)) != 'object') {
          handles = {};
        }

        if (!handles.type) {
          handles.type = 'corners';
        }

        switch (handles.type) {

          case 'sides':

            util.extend(handles, {
              sides: {
                top: true,
                bottom: true,
                left: true,
                right: true
              }
            });

            var j = 0;
            for (var i in handles.sides) {
              if (handles.sides[i]) {
                j++;
              }
            }

            this._createHandles(j, 'g').map(function (g) {

              var r = document.createElementNS(self.graph.ns, 'rect');
              r.setAttribute('x', '-3');
              r.setAttribute('width', '6');
              r.setAttribute('y', '-6');
              r.setAttribute('height', '12');
              r.setAttribute('stroke', 'black');
              r.setAttribute('fill', 'white');
              r.setAttribute('cursor', 'pointer');

              g.appendChild(r);
            });

            var j = 1;

            for (var i in handles.sides) {
              if (handles.sides[i]) {
                this.handles[i] = this['handle' + j];
                this.sides[j] = i;
                j++;
              }
            }

            break;

          case 'corners':
            this._createHandles(4, 'rect', {
              transform: 'translate(-3 -3)',
              width: 6,
              height: 6,
              stroke: 'black',
              fill: 'white'
            });

            if (this.handles) {
              this.handles[2].setAttribute('cursor', 'nesw-resize');
              this.handles[4].setAttribute('cursor', 'nesw-resize');

              this.handles[1].setAttribute('cursor', 'nwse-resize');
              this.handles[3].setAttribute('cursor', 'nwse-resize');
            }

            break;

          case 'seamlessX':

            this._createHandles(2, 'rect', {
              transform: 'translate(-3 -3)',
              stroke: 'transparent',
              fill: 'transparent',
              width: '20px',
              cursor: 'ew-resize'
            });

            break;
        }

        _get(ShapeRectangle.prototype.__proto__ || Object.getPrototypeOf(ShapeRectangle.prototype), 'createHandles', this).call(this);

        return this;
      }
    }, {
      key: 'applyPosition',
      value: function applyPosition() {

        var pos = this.computePosition(0),
            pos2 = this.computePosition(1),
            x,
            y,
            width,
            height;

        if (pos.x < pos2.x) {
          x = pos.x;
          width = pos2.x - pos.x;
        } else {
          x = pos2.x;
          width = pos.x - pos2.x;
        }

        if (pos.y < pos2.y) {
          y = pos.y;
          height = pos2.y - pos.y;
        } else {
          y = pos2.y;
          height = pos.y - pos2.y;
        }

        this.currentX = x;
        this.currentY = y;
        this.currentW = width;
        this.currentH = height;

        if (!isNaN(x) && !isNaN(y) && x !== false && y !== false) {

          this.setDom('width', width);
          this.setDom('height', height);
          this.setDom('x', x);
          this.setDom('y', y);

          this.setHandles();
          this.updateMask();

          return true;
        }

        return false;
      }
    }, {
      key: 'handleMouseMoveImpl',
      value: function handleMouseMoveImpl(e, deltaX, deltaY, deltaXPx, deltaYPx) {

        var handles = this.getProp('handles');

        if (!this.moving && !this.handleSelected) {
          return;
        }

        var pos = this.getPosition(0);
        var pos2 = this.getPosition(1);

        var invX = this.getXAxis().isFlipped(),
            invY = this.getYAxis().isFlipped(),
            posX = pos.x,
            posY = pos.y,
            pos2X = pos2.x,
            pos2Y = pos2.y;

        if (this.moving) {

          pos.deltaPosition('x', deltaX, this.getXAxis());
          pos.deltaPosition('y', deltaY, this.getYAxis());

          pos2.deltaPosition('x', deltaX, this.getXAxis());
          pos2.deltaPosition('y', deltaY, this.getYAxis());
        } else {

          switch (handles.type) {

            case 'seamlessX':
              // Do nothing for now

              switch (this.handleSelected) {

                case 1:
                  pos.deltaPosition('x', deltaX, this.getXAxis());
                  break;

                case 2:
                  pos2.deltaPosition('x', deltaX, this.getXAxis());
                  break;
              }

              break;

            case 'sides':
              // Do nothing for now

              switch (this.sides[this.handleSelected]) {

                case 'left':
                  pos.deltaPosition('x', deltaX, this.getXAxis());
                  break;

                case 'right':
                  pos2.deltaPosition('x', deltaX, this.getXAxis());
                  break;

                case 'top':
                  pos.deltaPosition('y', deltaY, this.getYAxis());
                  break;

                case 'bottom':
                  pos2.deltaPosition('y', deltaY, this.getYAxis());
                  break;

              }

              break;

            case 'corners':
            default:

              if (this.handleSelected == 1) {

                pos.deltaPosition('x', deltaX, this.getXAxis());
                pos.deltaPosition('y', deltaY, this.getYAxis());
              } else if (this.handleSelected == 2) {

                pos2.deltaPosition('x', deltaX, this.getXAxis());
                pos.deltaPosition('y', deltaY, this.getYAxis());
              } else if (this.handleSelected == 3) {

                pos2.deltaPosition('y', deltaY, this.getYAxis());
                pos2.deltaPosition('x', deltaX, this.getXAxis());
              } else if (this.handleSelected == 4) {

                pos.deltaPosition('x', deltaX, this.getXAxis());
                pos2.deltaPosition('y', deltaY, this.getYAxis());
              }

              break;

          }
        }

        this.redraw();
        this.changed();
        this.setHandles();

        return true;
      }
    }, {
      key: 'setHandles',
      value: function setHandles() {

        if (this.isLocked() || !this.isSelectable() && !this._staticHandles) {
          return;
        }

        if (!this.handlesInDom) {
          return;
        }

        var pos = this.computePosition(0);
        var pos2 = this.computePosition(1);

        var handles = this.getProp('handles');

        switch (handles.type) {

          case 'seamlessX':

            if (this.handles[1]) {
              this.handles[1].setAttribute('transform', 'translate(-10) translate(' + pos.x + ')');
              this.handles[1].setAttribute('height', Math.abs(pos2.y - pos.y));
              this.handles[1].setAttribute('y', Math.min(pos2.y, pos.y));
            }

            if (this.handles[2]) {
              this.handles[2].setAttribute('transform', 'translate(-10)  translate(' + pos2.x + ')');
              this.handles[2].setAttribute('height', Math.abs(pos2.y - pos.y));
              this.handles[2].setAttribute('y', Math.min(pos2.y, pos.y));
            }

            break;

          case 'sides':

            if (this.handles.left) {
              this.handles.left.setAttribute('transform', 'translate(' + this.currentX + ' ' + (this.currentY + this.currentH / 2) + ')');
            }

            if (this.handles.right) {
              this.handles.right.setAttribute('transform', 'translate( ' + (this.currentX + this.currentW) + ' ' + (this.currentY + this.currentH / 2) + ')');
            }

            if (this.handles.top) {
              this.handles.top.setAttribute('transform', 'translate( ' + (this.currentX + this.currentW / 2) + ' ' + this.currentY + ')');
            }

            if (this.handles.bottom) {
              this.handles.bottom.setAttribute('transform', 'translate( ' + (this.currentX + this.currentW / 2) + ' ' + (this.currentY + this.currentH) + ')');
            }

            break;

          case 'corners':
          default:

            this.handles[1].setAttribute('x', pos.x);
            this.handles[1].setAttribute('y', pos.y);

            this.handles[2].setAttribute('x', pos2.x);
            this.handles[2].setAttribute('y', pos.y);

            this.handles[3].setAttribute('x', pos2.x);
            this.handles[3].setAttribute('y', pos2.y);

            this.handles[4].setAttribute('x', pos.x);
            this.handles[4].setAttribute('y', pos2.y);

            break;

        }
      }
    }]);

    return ShapeRectangle;
  }(_graphShape2.default);

  exports.default = ShapeRectangle;
  module.exports = exports['default'];
});

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(145);
module.exports = __webpack_require__(347);


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

__webpack_require__(146);

__webpack_require__(343);

__webpack_require__(344);

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}
global._babelPolyfill = true;

var DEFINE_PROPERTY = "defineProperty";
function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);

"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(103)))

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(147);
__webpack_require__(149);
__webpack_require__(150);
__webpack_require__(151);
__webpack_require__(152);
__webpack_require__(153);
__webpack_require__(154);
__webpack_require__(155);
__webpack_require__(156);
__webpack_require__(157);
__webpack_require__(158);
__webpack_require__(159);
__webpack_require__(160);
__webpack_require__(161);
__webpack_require__(162);
__webpack_require__(163);
__webpack_require__(165);
__webpack_require__(166);
__webpack_require__(167);
__webpack_require__(168);
__webpack_require__(169);
__webpack_require__(170);
__webpack_require__(171);
__webpack_require__(172);
__webpack_require__(173);
__webpack_require__(174);
__webpack_require__(175);
__webpack_require__(176);
__webpack_require__(177);
__webpack_require__(178);
__webpack_require__(179);
__webpack_require__(180);
__webpack_require__(181);
__webpack_require__(182);
__webpack_require__(183);
__webpack_require__(184);
__webpack_require__(185);
__webpack_require__(186);
__webpack_require__(187);
__webpack_require__(188);
__webpack_require__(189);
__webpack_require__(190);
__webpack_require__(191);
__webpack_require__(192);
__webpack_require__(193);
__webpack_require__(194);
__webpack_require__(195);
__webpack_require__(196);
__webpack_require__(197);
__webpack_require__(198);
__webpack_require__(199);
__webpack_require__(200);
__webpack_require__(201);
__webpack_require__(202);
__webpack_require__(203);
__webpack_require__(204);
__webpack_require__(205);
__webpack_require__(206);
__webpack_require__(207);
__webpack_require__(208);
__webpack_require__(209);
__webpack_require__(210);
__webpack_require__(211);
__webpack_require__(212);
__webpack_require__(213);
__webpack_require__(214);
__webpack_require__(215);
__webpack_require__(216);
__webpack_require__(217);
__webpack_require__(218);
__webpack_require__(219);
__webpack_require__(220);
__webpack_require__(221);
__webpack_require__(222);
__webpack_require__(223);
__webpack_require__(224);
__webpack_require__(225);
__webpack_require__(227);
__webpack_require__(228);
__webpack_require__(230);
__webpack_require__(231);
__webpack_require__(232);
__webpack_require__(233);
__webpack_require__(234);
__webpack_require__(235);
__webpack_require__(236);
__webpack_require__(238);
__webpack_require__(239);
__webpack_require__(240);
__webpack_require__(241);
__webpack_require__(242);
__webpack_require__(243);
__webpack_require__(244);
__webpack_require__(245);
__webpack_require__(246);
__webpack_require__(247);
__webpack_require__(248);
__webpack_require__(249);
__webpack_require__(250);
__webpack_require__(96);
__webpack_require__(251);
__webpack_require__(252);
__webpack_require__(122);
__webpack_require__(253);
__webpack_require__(254);
__webpack_require__(255);
__webpack_require__(256);
__webpack_require__(257);
__webpack_require__(125);
__webpack_require__(127);
__webpack_require__(128);
__webpack_require__(258);
__webpack_require__(259);
__webpack_require__(260);
__webpack_require__(261);
__webpack_require__(262);
__webpack_require__(263);
__webpack_require__(264);
__webpack_require__(265);
__webpack_require__(266);
__webpack_require__(267);
__webpack_require__(268);
__webpack_require__(269);
__webpack_require__(270);
__webpack_require__(271);
__webpack_require__(272);
__webpack_require__(273);
__webpack_require__(274);
__webpack_require__(275);
__webpack_require__(276);
__webpack_require__(277);
__webpack_require__(278);
__webpack_require__(279);
__webpack_require__(280);
__webpack_require__(281);
__webpack_require__(282);
__webpack_require__(283);
__webpack_require__(284);
__webpack_require__(285);
__webpack_require__(286);
__webpack_require__(287);
__webpack_require__(288);
__webpack_require__(289);
__webpack_require__(290);
__webpack_require__(291);
__webpack_require__(292);
__webpack_require__(293);
__webpack_require__(294);
__webpack_require__(295);
__webpack_require__(296);
__webpack_require__(297);
__webpack_require__(298);
__webpack_require__(299);
__webpack_require__(300);
__webpack_require__(301);
__webpack_require__(302);
__webpack_require__(303);
__webpack_require__(304);
__webpack_require__(305);
__webpack_require__(306);
__webpack_require__(307);
__webpack_require__(308);
__webpack_require__(309);
__webpack_require__(310);
__webpack_require__(311);
__webpack_require__(312);
__webpack_require__(313);
__webpack_require__(314);
__webpack_require__(315);
__webpack_require__(316);
__webpack_require__(317);
__webpack_require__(318);
__webpack_require__(319);
__webpack_require__(320);
__webpack_require__(321);
__webpack_require__(322);
__webpack_require__(323);
__webpack_require__(324);
__webpack_require__(325);
__webpack_require__(326);
__webpack_require__(327);
__webpack_require__(328);
__webpack_require__(329);
__webpack_require__(330);
__webpack_require__(331);
__webpack_require__(332);
__webpack_require__(333);
__webpack_require__(334);
__webpack_require__(335);
__webpack_require__(336);
__webpack_require__(337);
__webpack_require__(338);
__webpack_require__(339);
__webpack_require__(340);
__webpack_require__(341);
__webpack_require__(342);
module.exports = __webpack_require__(19);


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(2);
var has = __webpack_require__(15);
var DESCRIPTORS = __webpack_require__(7);
var $export = __webpack_require__(0);
var redefine = __webpack_require__(13);
var META = __webpack_require__(32).KEY;
var $fails = __webpack_require__(3);
var shared = __webpack_require__(58);
var setToStringTag = __webpack_require__(47);
var uid = __webpack_require__(36);
var wks = __webpack_require__(6);
var wksExt = __webpack_require__(105);
var wksDefine = __webpack_require__(76);
var enumKeys = __webpack_require__(148);
var isArray = __webpack_require__(61);
var anObject = __webpack_require__(1);
var isObject = __webpack_require__(4);
var toIObject = __webpack_require__(16);
var toPrimitive = __webpack_require__(23);
var createDesc = __webpack_require__(35);
var _create = __webpack_require__(39);
var gOPNExt = __webpack_require__(108);
var $GOPD = __webpack_require__(17);
var $DP = __webpack_require__(8);
var $keys = __webpack_require__(37);
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(40).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(53).f = $propertyIsEnumerable;
  __webpack_require__(60).f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(33)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(12)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(37);
var gOPS = __webpack_require__(60);
var pIE = __webpack_require__(53);
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__(39) });


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(7), 'Object', { defineProperty: __webpack_require__(8).f });


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !__webpack_require__(7), 'Object', { defineProperties: __webpack_require__(107) });


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__(16);
var $getOwnPropertyDescriptor = __webpack_require__(17).f;

__webpack_require__(26)('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__(10);
var $getPrototypeOf = __webpack_require__(18);

__webpack_require__(26)('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(10);
var $keys = __webpack_require__(37);

__webpack_require__(26)('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__(26)('getOwnPropertyNames', function () {
  return __webpack_require__(108).f;
});


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__(4);
var meta = __webpack_require__(32).onFreeze;

__webpack_require__(26)('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.17 Object.seal(O)
var isObject = __webpack_require__(4);
var meta = __webpack_require__(32).onFreeze;

__webpack_require__(26)('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.15 Object.preventExtensions(O)
var isObject = __webpack_require__(4);
var meta = __webpack_require__(32).onFreeze;

__webpack_require__(26)('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.12 Object.isFrozen(O)
var isObject = __webpack_require__(4);

__webpack_require__(26)('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.13 Object.isSealed(O)
var isObject = __webpack_require__(4);

__webpack_require__(26)('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.11 Object.isExtensible(O)
var isObject = __webpack_require__(4);

__webpack_require__(26)('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(0);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(109) });


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.10 Object.is(value1, value2)
var $export = __webpack_require__(0);
$export($export.S, 'Object', { is: __webpack_require__(164) });


/***/ }),
/* 164 */
/***/ (function(module, exports) {

// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(0);
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(80).set });


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.3.6 Object.prototype.toString()
var classof = __webpack_require__(54);
var test = {};
test[__webpack_require__(6)('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  __webpack_require__(13)(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = __webpack_require__(0);

$export($export.P, 'Function', { bind: __webpack_require__(110) });


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(8).f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || __webpack_require__(7) && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isObject = __webpack_require__(4);
var getPrototypeOf = __webpack_require__(18);
var HAS_INSTANCE = __webpack_require__(6)('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(8).f(FunctionProto, HAS_INSTANCE, { value: function (O) {
  if (typeof this != 'function' || !isObject(O)) return false;
  if (!isObject(this.prototype)) return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
  return false;
} });


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $parseInt = __webpack_require__(112);
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $parseFloat = __webpack_require__(113);
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(2);
var has = __webpack_require__(15);
var cof = __webpack_require__(21);
var inheritIfRequired = __webpack_require__(82);
var toPrimitive = __webpack_require__(23);
var fails = __webpack_require__(3);
var gOPN = __webpack_require__(40).f;
var gOPD = __webpack_require__(17).f;
var dP = __webpack_require__(8).f;
var $trim = __webpack_require__(48).trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(__webpack_require__(39)(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = __webpack_require__(7) ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  __webpack_require__(13)(global, NUMBER, $Number);
}


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toInteger = __webpack_require__(25);
var aNumberValue = __webpack_require__(114);
var repeat = __webpack_require__(83);
var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function (n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function () {
  var i = 6;
  var s = '';
  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !__webpack_require__(3)(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR);
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = f;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $fails = __webpack_require__(3);
var aNumberValue = __webpack_require__(114);
var $toPrecision = 1.0.toPrecision;

$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(0);

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.2 Number.isFinite(number)
var $export = __webpack_require__(0);
var _isFinite = __webpack_require__(2).isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(0);

$export($export.S, 'Number', { isInteger: __webpack_require__(115) });


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.4 Number.isNaN(number)
var $export = __webpack_require__(0);

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.5 Number.isSafeInteger(number)
var $export = __webpack_require__(0);
var isInteger = __webpack_require__(115);
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(0);

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = __webpack_require__(0);

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $parseFloat = __webpack_require__(113);
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $parseInt = __webpack_require__(112);
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.3 Math.acosh(x)
var $export = __webpack_require__(0);
var log1p = __webpack_require__(116);
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.5 Math.asinh(x)
var $export = __webpack_require__(0);
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.7 Math.atanh(x)
var $export = __webpack_require__(0);
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.9 Math.cbrt(x)
var $export = __webpack_require__(0);
var sign = __webpack_require__(84);

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.11 Math.clz32(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.12 Math.cosh(x)
var $export = __webpack_require__(0);
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.14 Math.expm1(x)
var $export = __webpack_require__(0);
var $expm1 = __webpack_require__(85);

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', { fround: __webpack_require__(117) });


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])
var $export = __webpack_require__(0);
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.18 Math.imul(x, y)
var $export = __webpack_require__(0);
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * __webpack_require__(3)(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.21 Math.log10(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.20 Math.log1p(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', { log1p: __webpack_require__(116) });


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', { sign: __webpack_require__(84) });


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.30 Math.sinh(x)
var $export = __webpack_require__(0);
var expm1 = __webpack_require__(85);
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * __webpack_require__(3)(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.33 Math.tanh(x)
var $export = __webpack_require__(0);
var expm1 = __webpack_require__(85);
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.34 Math.trunc(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var toAbsoluteIndex = __webpack_require__(38);
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var toIObject = __webpack_require__(16);
var toLength = __webpack_require__(9);

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.1.3.25 String.prototype.trim()
__webpack_require__(48)('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(86)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(87)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $at = __webpack_require__(86)(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])

var $export = __webpack_require__(0);
var toLength = __webpack_require__(9);
var context = __webpack_require__(89);
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * __webpack_require__(90)(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)

var $export = __webpack_require__(0);
var context = __webpack_require__(89);
var INCLUDES = 'includes';

$export($export.P + $export.F * __webpack_require__(90)(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: __webpack_require__(83)
});


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])

var $export = __webpack_require__(0);
var toLength = __webpack_require__(9);
var context = __webpack_require__(89);
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * __webpack_require__(90)(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.2 String.prototype.anchor(name)
__webpack_require__(14)('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.3 String.prototype.big()
__webpack_require__(14)('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.4 String.prototype.blink()
__webpack_require__(14)('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.5 String.prototype.bold()
__webpack_require__(14)('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.6 String.prototype.fixed()
__webpack_require__(14)('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.7 String.prototype.fontcolor(color)
__webpack_require__(14)('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.8 String.prototype.fontsize(size)
__webpack_require__(14)('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.9 String.prototype.italics()
__webpack_require__(14)('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.10 String.prototype.link(url)
__webpack_require__(14)('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.11 String.prototype.small()
__webpack_require__(14)('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.12 String.prototype.strike()
__webpack_require__(14)('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.13 String.prototype.sub()
__webpack_require__(14)('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.14 String.prototype.sup()
__webpack_require__(14)('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = __webpack_require__(0);

$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toObject = __webpack_require__(10);
var toPrimitive = __webpack_require__(23);

$export($export.P + $export.F * __webpack_require__(3)(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = __webpack_require__(0);
var toISOString = __webpack_require__(226);

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var fails = __webpack_require__(3);
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
module.exports = (fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
})) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  __webpack_require__(13)(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

var TO_PRIMITIVE = __webpack_require__(6)('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) __webpack_require__(12)(proto, TO_PRIMITIVE, __webpack_require__(229));


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var anObject = __webpack_require__(1);
var toPrimitive = __webpack_require__(23);
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(0);

$export($export.S, 'Array', { isArray: __webpack_require__(61) });


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx = __webpack_require__(20);
var $export = __webpack_require__(0);
var toObject = __webpack_require__(10);
var call = __webpack_require__(118);
var isArrayIter = __webpack_require__(91);
var toLength = __webpack_require__(9);
var createProperty = __webpack_require__(92);
var getIterFn = __webpack_require__(93);

$export($export.S + $export.F * !__webpack_require__(63)(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var createProperty = __webpack_require__(92);

// WebKit Array.of isn't generic
$export($export.S + $export.F * __webpack_require__(3)(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */) {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.13 Array.prototype.join(separator)
var $export = __webpack_require__(0);
var toIObject = __webpack_require__(16);
var arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (__webpack_require__(52) != Object || !__webpack_require__(22)(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var html = __webpack_require__(79);
var cof = __webpack_require__(21);
var toAbsoluteIndex = __webpack_require__(38);
var toLength = __webpack_require__(9);
var arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * __webpack_require__(3)(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = new Array(size);
    var i = 0;
    for (; i < size; i++) cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var aFunction = __webpack_require__(11);
var toObject = __webpack_require__(10);
var fails = __webpack_require__(3);
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !__webpack_require__(22)($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $forEach = __webpack_require__(27)(0);
var STRICT = __webpack_require__(22)([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4);
var isArray = __webpack_require__(61);
var SPECIES = __webpack_require__(6)('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $map = __webpack_require__(27)(1);

$export($export.P + $export.F * !__webpack_require__(22)([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $filter = __webpack_require__(27)(2);

$export($export.P + $export.F * !__webpack_require__(22)([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $some = __webpack_require__(27)(3);

$export($export.P + $export.F * !__webpack_require__(22)([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $every = __webpack_require__(27)(4);

$export($export.P + $export.F * !__webpack_require__(22)([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $reduce = __webpack_require__(119);

$export($export.P + $export.F * !__webpack_require__(22)([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $reduce = __webpack_require__(119);

$export($export.P + $export.F * !__webpack_require__(22)([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $indexOf = __webpack_require__(59)(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(22)($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toIObject = __webpack_require__(16);
var toInteger = __webpack_require__(25);
var toLength = __webpack_require__(9);
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(22)($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;
    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
    return -1;
  }
});


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = __webpack_require__(0);

$export($export.P, 'Array', { copyWithin: __webpack_require__(120) });

__webpack_require__(34)('copyWithin');


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__(0);

$export($export.P, 'Array', { fill: __webpack_require__(95) });

__webpack_require__(34)('fill');


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = __webpack_require__(0);
var $find = __webpack_require__(27)(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(34)(KEY);


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = __webpack_require__(0);
var $find = __webpack_require__(27)(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(34)(KEY);


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(41)('Array');


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var inheritIfRequired = __webpack_require__(82);
var dP = __webpack_require__(8).f;
var gOPN = __webpack_require__(40).f;
var isRegExp = __webpack_require__(62);
var $flags = __webpack_require__(64);
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (__webpack_require__(7) && (!CORRECT_NEW || __webpack_require__(3)(function () {
  re2[__webpack_require__(6)('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  __webpack_require__(13)(global, 'RegExp', $RegExp);
}

__webpack_require__(41)('RegExp');


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

__webpack_require__(122);
var anObject = __webpack_require__(1);
var $flags = __webpack_require__(64);
var DESCRIPTORS = __webpack_require__(7);
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  __webpack_require__(13)(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (__webpack_require__(3)(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

// @@match logic
__webpack_require__(65)('match', 1, function (defined, MATCH, $match) {
  // 21.1.3.11 String.prototype.match(regexp)
  return [function match(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

// @@replace logic
__webpack_require__(65)('replace', 2, function (defined, REPLACE, $replace) {
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue) {
    'use strict';
    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined
      ? fn.call(searchValue, O, replaceValue)
      : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

// @@search logic
__webpack_require__(65)('search', 1, function (defined, SEARCH, $search) {
  // 21.1.3.15 String.prototype.search(regexp)
  return [function search(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

// @@split logic
__webpack_require__(65)('split', 2, function (defined, SPLIT, $split) {
  'use strict';
  var isRegExp = __webpack_require__(62);
  var _split = $split;
  var $push = [].push;
  var $SPLIT = 'split';
  var LENGTH = 'length';
  var LAST_INDEX = 'lastIndex';
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
    // based on es5-shim implementation, need to rework it
    $split = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return _split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var separator2, match, lastIndex, lastLength, i;
      // Doesn't need flags gy, but they don't hurt
      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
      while (match = separatorCopy.exec(string)) {
        // `separatorCopy.lastIndex` is not reliable cross-browser
        lastIndex = match.index + match[0][LENGTH];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
          // eslint-disable-next-line no-loop-func
          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
            for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;
          });
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    $split = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
    };
  }
  // 21.1.3.17 String.prototype.split(separator, limit)
  return [function split(separator, limit) {
    var O = defined(this);
    var fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(33);
var global = __webpack_require__(2);
var ctx = __webpack_require__(20);
var classof = __webpack_require__(54);
var $export = __webpack_require__(0);
var isObject = __webpack_require__(4);
var aFunction = __webpack_require__(11);
var anInstance = __webpack_require__(42);
var forOf = __webpack_require__(43);
var speciesConstructor = __webpack_require__(66);
var task = __webpack_require__(97).set;
var microtask = __webpack_require__(98)();
var newPromiseCapabilityModule = __webpack_require__(99);
var perform = __webpack_require__(123);
var userAgent = __webpack_require__(67);
var promiseResolve = __webpack_require__(124);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(6)('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(44)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(47)($Promise, PROMISE);
__webpack_require__(41)(PROMISE);
Wrapper = __webpack_require__(19)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(63)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var weak = __webpack_require__(129);
var validate = __webpack_require__(50);
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
__webpack_require__(68)(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $typed = __webpack_require__(69);
var buffer = __webpack_require__(100);
var anObject = __webpack_require__(1);
var toAbsoluteIndex = __webpack_require__(38);
var toLength = __webpack_require__(9);
var isObject = __webpack_require__(4);
var ArrayBuffer = __webpack_require__(2).ArrayBuffer;
var speciesConstructor = __webpack_require__(66);
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * __webpack_require__(3)(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

__webpack_require__(41)(ARRAY_BUFFER);


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
$export($export.G + $export.W + $export.F * !__webpack_require__(69).ABV, {
  DataView: __webpack_require__(100).DataView
});


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(30)('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(30)('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(30)('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(30)('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(30)('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(30)('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(30)('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(30)('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(30)('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = __webpack_require__(0);
var aFunction = __webpack_require__(11);
var anObject = __webpack_require__(1);
var rApply = (__webpack_require__(2).Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !__webpack_require__(3)(function () {
  rApply(function () { /* empty */ });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});


/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = __webpack_require__(0);
var create = __webpack_require__(39);
var aFunction = __webpack_require__(11);
var anObject = __webpack_require__(1);
var isObject = __webpack_require__(4);
var fails = __webpack_require__(3);
var bind = __webpack_require__(110);
var rConstruct = (__webpack_require__(2).Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});


/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = __webpack_require__(8);
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);
var toPrimitive = __webpack_require__(23);

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * __webpack_require__(3)(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = __webpack_require__(0);
var gOPD = __webpack_require__(17).f;
var anObject = __webpack_require__(1);

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});


/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 26.1.5 Reflect.enumerate(target)
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);
var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = [];      // keys
  var key;
  for (key in iterated) keys.push(key);
};
__webpack_require__(88)(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;
  do {
    if (that._i >= keys.length) return { value: undefined, done: true };
  } while (!((key = keys[that._i++]) in that._t));
  return { value: key, done: false };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});


/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = __webpack_require__(17);
var getPrototypeOf = __webpack_require__(18);
var has = __webpack_require__(15);
var $export = __webpack_require__(0);
var isObject = __webpack_require__(4);
var anObject = __webpack_require__(1);

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });


/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = __webpack_require__(17);
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});


/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.8 Reflect.getPrototypeOf(target)
var $export = __webpack_require__(0);
var getProto = __webpack_require__(18);
var anObject = __webpack_require__(1);

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});


/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.9 Reflect.has(target, propertyKey)
var $export = __webpack_require__(0);

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});


/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.10 Reflect.isExtensible(target)
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});


/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.11 Reflect.ownKeys(target)
var $export = __webpack_require__(0);

$export($export.S, 'Reflect', { ownKeys: __webpack_require__(131) });


/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.12 Reflect.preventExtensions(target)
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = __webpack_require__(8);
var gOPD = __webpack_require__(17);
var getPrototypeOf = __webpack_require__(18);
var has = __webpack_require__(15);
var $export = __webpack_require__(0);
var createDesc = __webpack_require__(35);
var anObject = __webpack_require__(1);
var isObject = __webpack_require__(4);

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      dP.f(receiver, propertyKey, existingDescriptor);
    } else dP.f(receiver, propertyKey, createDesc(0, V));
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });


/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = __webpack_require__(0);
var setProto = __webpack_require__(80);

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/Array.prototype.includes
var $export = __webpack_require__(0);
var $includes = __webpack_require__(59)(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(34)('includes');


/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
var $export = __webpack_require__(0);
var flattenIntoArray = __webpack_require__(132);
var toObject = __webpack_require__(10);
var toLength = __webpack_require__(9);
var aFunction = __webpack_require__(11);
var arraySpeciesCreate = __webpack_require__(94);

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

__webpack_require__(34)('flatMap');


/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten
var $export = __webpack_require__(0);
var flattenIntoArray = __webpack_require__(132);
var toObject = __webpack_require__(10);
var toLength = __webpack_require__(9);
var toInteger = __webpack_require__(25);
var arraySpeciesCreate = __webpack_require__(94);

$export($export.P, 'Array', {
  flatten: function flatten(/* depthArg = 1 */) {
    var depthArg = arguments[0];
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});

__webpack_require__(34)('flatten');


/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/mathiasbynens/String.prototype.at
var $export = __webpack_require__(0);
var $at = __webpack_require__(86)(true);

$export($export.P, 'String', {
  at: function at(pos) {
    return $at(this, pos);
  }
});


/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-string-pad-start-end
var $export = __webpack_require__(0);
var $pad = __webpack_require__(133);
var userAgent = __webpack_require__(67);

// https://github.com/zloirock/core-js/issues/280
$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});


/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-string-pad-start-end
var $export = __webpack_require__(0);
var $pad = __webpack_require__(133);
var userAgent = __webpack_require__(67);

// https://github.com/zloirock/core-js/issues/280
$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});


/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
__webpack_require__(48)('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');


/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
__webpack_require__(48)('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');


/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/String.prototype.matchAll/
var $export = __webpack_require__(0);
var defined = __webpack_require__(24);
var toLength = __webpack_require__(9);
var isRegExp = __webpack_require__(62);
var getFlags = __webpack_require__(64);
var RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function (regexp, string) {
  this._r = regexp;
  this._s = string;
};

__webpack_require__(88)($RegExpStringIterator, 'RegExp String', function next() {
  var match = this._r.exec(this._s);
  return { value: match, done: match === null };
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp) {
    defined(this);
    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
    var S = String(this);
    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});


/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(76)('asyncIterator');


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(76)('observable');


/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = __webpack_require__(0);
var ownKeys = __webpack_require__(131);
var toIObject = __webpack_require__(16);
var gOPD = __webpack_require__(17);
var createProperty = __webpack_require__(92);

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});


/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(0);
var $values = __webpack_require__(134)(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});


/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(0);
var $entries = __webpack_require__(134)(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});


/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toObject = __webpack_require__(10);
var aFunction = __webpack_require__(11);
var $defineProperty = __webpack_require__(8);

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
__webpack_require__(7) && $export($export.P + __webpack_require__(70), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter) {
    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
  }
});


/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toObject = __webpack_require__(10);
var aFunction = __webpack_require__(11);
var $defineProperty = __webpack_require__(8);

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
__webpack_require__(7) && $export($export.P + __webpack_require__(70), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter) {
    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
  }
});


/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toObject = __webpack_require__(10);
var toPrimitive = __webpack_require__(23);
var getPrototypeOf = __webpack_require__(18);
var getOwnPropertyDescriptor = __webpack_require__(17).f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
__webpack_require__(7) && $export($export.P + __webpack_require__(70), 'Object', {
  __lookupGetter__: function __lookupGetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
    } while (O = getPrototypeOf(O));
  }
});


/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toObject = __webpack_require__(10);
var toPrimitive = __webpack_require__(23);
var getPrototypeOf = __webpack_require__(18);
var getOwnPropertyDescriptor = __webpack_require__(17).f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
__webpack_require__(7) && $export($export.P + __webpack_require__(70), 'Object', {
  __lookupSetter__: function __lookupSetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
    } while (O = getPrototypeOf(O));
  }
});


/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(0);

$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(135)('Map') });


/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(0);

$export($export.P + $export.R, 'Set', { toJSON: __webpack_require__(135)('Set') });


/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
__webpack_require__(71)('Map');


/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
__webpack_require__(71)('Set');


/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
__webpack_require__(71)('WeakMap');


/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
__webpack_require__(71)('WeakSet');


/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
__webpack_require__(72)('Map');


/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
__webpack_require__(72)('Set');


/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
__webpack_require__(72)('WeakMap');


/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
__webpack_require__(72)('WeakSet');


/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__(0);

$export($export.G, { global: __webpack_require__(2) });


/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__(0);

$export($export.S, 'System', { global: __webpack_require__(2) });


/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/ljharb/proposal-is-error
var $export = __webpack_require__(0);
var cof = __webpack_require__(21);

$export($export.S, 'Error', {
  isError: function isError(it) {
    return cof(it) === 'Error';
  }
});


/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  clamp: function clamp(x, lower, upper) {
    return Math.min(upper, Math.max(lower, x));
  }
});


/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);

$export($export.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });


/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);
var RAD_PER_DEG = 180 / Math.PI;

$export($export.S, 'Math', {
  degrees: function degrees(radians) {
    return radians * RAD_PER_DEG;
  }
});


/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);
var scale = __webpack_require__(137);
var fround = __webpack_require__(117);

$export($export.S, 'Math', {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround(scale(x, inLow, inHigh, outLow, outHigh));
  }
});


/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});


/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});


/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  imulh: function imulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});


/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);

$export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });


/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);
var DEG_PER_RAD = Math.PI / 180;

$export($export.S, 'Math', {
  radians: function radians(degrees) {
    return degrees * DEG_PER_RAD;
  }
});


/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);

$export($export.S, 'Math', { scale: __webpack_require__(137) });


/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  umulh: function umulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});


/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

// http://jfbastien.github.io/papers/Math.signbit.html
var $export = __webpack_require__(0);

$export($export.S, 'Math', { signbit: function signbit(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
} });


/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally

var $export = __webpack_require__(0);
var core = __webpack_require__(19);
var global = __webpack_require__(2);
var speciesConstructor = __webpack_require__(66);
var promiseResolve = __webpack_require__(124);

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });


/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-promise-try
var $export = __webpack_require__(0);
var newPromiseCapability = __webpack_require__(99);
var perform = __webpack_require__(123);

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });


/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(31);
var anObject = __webpack_require__(1);
var toMetaKey = metadata.key;
var ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
} });


/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(31);
var anObject = __webpack_require__(1);
var toMetaKey = metadata.key;
var getOrCreateMetadataMap = metadata.map;
var store = metadata.store;

metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
  var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
  var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
  if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
  if (metadataMap.size) return true;
  var targetMetadata = store.get(target);
  targetMetadata['delete'](targetKey);
  return !!targetMetadata.size || store['delete'](target);
} });


/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(31);
var anObject = __webpack_require__(1);
var getPrototypeOf = __webpack_require__(18);
var ordinaryHasOwnMetadata = metadata.has;
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

var ordinaryGetMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });


/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

var Set = __webpack_require__(127);
var from = __webpack_require__(136);
var metadata = __webpack_require__(31);
var anObject = __webpack_require__(1);
var getPrototypeOf = __webpack_require__(18);
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

var ordinaryMetadataKeys = function (O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });


/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(31);
var anObject = __webpack_require__(1);
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });


/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(31);
var anObject = __webpack_require__(1);
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });


/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(31);
var anObject = __webpack_require__(1);
var getPrototypeOf = __webpack_require__(18);
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

var ordinaryHasMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });


/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(31);
var anObject = __webpack_require__(1);
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });


/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

var $metadata = __webpack_require__(31);
var anObject = __webpack_require__(1);
var aFunction = __webpack_require__(11);
var toMetaKey = $metadata.key;
var ordinaryDefineOwnMetadata = $metadata.set;

$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
  return function decorator(target, targetKey) {
    ordinaryDefineOwnMetadata(
      metadataKey, metadataValue,
      (targetKey !== undefined ? anObject : aFunction)(target),
      toMetaKey(targetKey)
    );
  };
} });


/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export = __webpack_require__(0);
var microtask = __webpack_require__(98)();
var process = __webpack_require__(2).process;
var isNode = __webpack_require__(21)(process) == 'process';

$export($export.G, {
  asap: function asap(fn) {
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});


/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/zenparsing/es-observable
var $export = __webpack_require__(0);
var global = __webpack_require__(2);
var core = __webpack_require__(19);
var microtask = __webpack_require__(98)();
var OBSERVABLE = __webpack_require__(6)('observable');
var aFunction = __webpack_require__(11);
var anObject = __webpack_require__(1);
var anInstance = __webpack_require__(42);
var redefineAll = __webpack_require__(44);
var hide = __webpack_require__(12);
var forOf = __webpack_require__(43);
var RETURN = forOf.RETURN;

var getMethod = function (fn) {
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function (subscription) {
  var cleanup = subscription._c;
  if (cleanup) {
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function (subscription) {
  return subscription._o === undefined;
};

var closeSubscription = function (subscription) {
  if (!subscriptionClosed(subscription)) {
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function (observer, subscriber) {
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup = subscriber(observer);
    var subscription = cleanup;
    if (cleanup != null) {
      if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); };
      else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch (e) {
    observer.error(e);
    return;
  } if (subscriptionClosed(this)) cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe() { closeSubscription(this); }
});

var SubscriptionObserver = function (subscription) {
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if (m) return m.call(observer, value);
      } catch (e) {
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value) {
    var subscription = this._s;
    if (subscriptionClosed(subscription)) throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if (!m) throw value;
      value = m.call(observer, value);
    } catch (e) {
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    } cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch (e) {
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      } cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber) {
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer) {
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn) {
    var that = this;
    return new (core.Promise || global.Promise)(function (resolve, reject) {
      aFunction(fn);
      var subscription = that.subscribe({
        next: function (value) {
          try {
            return fn(value);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x) {
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if (method) {
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function (observer) {
        return observable.subscribe(observer);
      });
    }
    return new C(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          try {
            if (forOf(x, false, function (it) {
              observer.next(it);
              if (done) return RETURN;
            }) === RETURN) return;
          } catch (e) {
            if (done) throw e;
            observer.error(e);
            return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  },
  of: function of() {
    for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++];
    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          for (var j = 0; j < items.length; ++j) {
            observer.next(items[j]);
            if (done) return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function () { return this; });

$export($export.G, { Observable: $Observable });

__webpack_require__(41)('Observable');


/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

// ie9- setTimeout & setInterval additional parameters fix
var global = __webpack_require__(2);
var $export = __webpack_require__(0);
var userAgent = __webpack_require__(67);
var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});


/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $task = __webpack_require__(97);
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});


/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

var $iterators = __webpack_require__(96);
var getKeys = __webpack_require__(37);
var redefine = __webpack_require__(13);
var global = __webpack_require__(2);
var hide = __webpack_require__(12);
var Iterators = __webpack_require__(49);
var wks = __webpack_require__(6);
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}


/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof global.process === "object" && global.process.domain) {
      invoke = global.process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(103)))

/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(345);
module.exports = __webpack_require__(19).RegExp.escape;


/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/benjamingr/RexExp.escape
var $export = __webpack_require__(0);
var $re = __webpack_require__(346)(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', { escape: function escape(it) { return $re(it); } });


/***/ }),
/* 346 */
/***/ (function(module, exports) {

module.exports = function (regExp, replace) {
  var replacer = replace === Object(replace) ? function (part) {
    return replace[part];
  } : replace;
  return function (it) {
    return String(it).replace(regExp, replacer);
  };
};


/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(45), __webpack_require__(55), __webpack_require__(348), __webpack_require__(101), __webpack_require__(139), __webpack_require__(349), __webpack_require__(350), __webpack_require__(51), __webpack_require__(351), __webpack_require__(352), __webpack_require__(353), __webpack_require__(354), __webpack_require__(141), __webpack_require__(142), __webpack_require__(355), __webpack_require__(356), __webpack_require__(357), __webpack_require__(28), __webpack_require__(358), __webpack_require__(359), __webpack_require__(377), __webpack_require__(360), __webpack_require__(361), __webpack_require__(102), __webpack_require__(362), __webpack_require__(363), __webpack_require__(143), __webpack_require__(364), __webpack_require__(365), __webpack_require__(366), __webpack_require__(29), __webpack_require__(367), __webpack_require__(368), __webpack_require__(369), __webpack_require__(370), __webpack_require__(371), __webpack_require__(373), __webpack_require__(374), __webpack_require__(375), __webpack_require__(376), __webpack_require__(46), __webpack_require__(138)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('./graph.core.js'), require('./graph.position.js'), require('./graph.legend.js'), require('./graph.axis.x.js'), require('./graph.axis.y.js'), require('./graph.axis.x.bar.js'), require('./graph.axis.x.time.js'), require('./series/graph.serie.line.js'), require('./series/graph.serie.line.3d.js'), require('./series/graph.serie.bar.js'), require('./series/graph.serie.box.js'), require('./series/graph.serie.line.colored.js'), require('./series/graph.serie.scatter.js'), require('./series/graph.serie.zone.js'), require('./series/graph.serie.zone.3d.js'), require('./series/graph.serie.densitymap.js'), require('./series/graph.serie.contour.js'), require('./shapes/graph.shape.js'), require('./shapes/graph.shape.areaundercurve.js'), require('./shapes/graph.shape.arrow.js'), require('./shapes/graph.shape.ellipse.js'), require('./shapes/graph.shape.label.js'), require('./shapes/graph.shape.polyline.js'), require('./shapes/graph.shape.line.js'), require('./shapes/graph.shape.nmrintegral.js'), require('./shapes/graph.shape.peakintegration2d.js'), require('./shapes/graph.shape.rect.js'), require('./shapes/graph.shape.cross.js'), require('./shapes/graph.shape.peakboundariescenter.js'), require('./shapes/graph.shape.html.js'), require('./plugins/graph.plugin.js'), require('./plugins/graph.plugin.drag.js'), require('./plugins/graph.plugin.shape.js'), require('./plugins/graph.plugin.selectScatter.js'), require('./plugins/graph.plugin.zoom.js'), require('./plugins/graph.plugin.timeseriemanager.js'), require('./plugins/graph.plugin.serielinedifference.js'), require('./plugins/graph.plugin.axissplitting.js'), require('./plugins/graph.plugin.makeTracesDifferent.js'), require('./plugins/graph.plugin.peakpicking.js'), require('./util/waveform.js'), require('./util/fit_lm.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphCore, global.graphPosition, global.graphLegend, global.graphAxisX, global.graphAxisY, global.graphAxisXBar, global.graphAxisXTime, global.graphSerieLine, global.graphSerieLine3d, global.graphSerieBar, global.graphSerieBox, global.graphSerieLineColored, global.graphSerieScatter, global.graphSerieZone, global.graphSerieZone3d, global.graphSerieDensitymap, global.graphSerieContour, global.graphShape, global.graphShapeAreaundercurve, global.graphShapeArrow, global.graphShapeEllipse, global.graphShapeLabel, global.graphShapePolyline, global.graphShapeLine, global.graphShapeNmrintegral, global.graphShapePeakintegration2d, global.graphShapeRect, global.graphShapeCross, global.graphShapePeakboundariescenter, global.graphShapeHtml, global.graphPlugin, global.graphPluginDrag, global.graphPluginShape, global.graphPluginSelectScatter, global.graphPluginZoom, global.graphPluginTimeseriemanager, global.graphPluginSerielinedifference, global.graphPluginAxissplitting, global.graphPluginMakeTracesDifferent, global.graphPluginPeakpicking, global.waveform, global.fit_lm);
    global.graph = mod.exports;
  }
})(this, function (module, exports, _graphCore, _graphPosition, _graphLegend, _graphAxisX, _graphAxisY, _graphAxisXBar, _graphAxisXTime, _graphSerieLine, _graphSerieLine3d, _graphSerieBar, _graphSerieBox, _graphSerieLineColored, _graphSerieScatter, _graphSerieZone, _graphSerieZone3d, _graphSerieDensitymap, _graphSerieContour, _graphShape, _graphShapeAreaundercurve, _graphShapeArrow, _graphShapeEllipse, _graphShapeLabel, _graphShapePolyline, _graphShapeLine, _graphShapeNmrintegral, _graphShapePeakintegration2d, _graphShapeRect, _graphShapeCross, _graphShapePeakboundariescenter, _graphShapeHtml, _graphPlugin, _graphPluginDrag, _graphPluginShape, _graphPluginSelectScatter, _graphPluginZoom, _graphPluginTimeseriemanager, _graphPluginSerielinedifference, _graphPluginAxissplitting, _graphPluginMakeTracesDifferent, _graphPluginPeakpicking, _waveform, _fit_lm) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _graphCore2 = _interopRequireDefault(_graphCore);

  var _graphPosition2 = _interopRequireDefault(_graphPosition);

  var _graphLegend2 = _interopRequireDefault(_graphLegend);

  var _graphAxisX2 = _interopRequireDefault(_graphAxisX);

  var _graphAxisY2 = _interopRequireDefault(_graphAxisY);

  var _graphAxisXBar2 = _interopRequireDefault(_graphAxisXBar);

  var _graphAxisXTime2 = _interopRequireDefault(_graphAxisXTime);

  var _graphSerieLine2 = _interopRequireDefault(_graphSerieLine);

  var _graphSerieLine3d2 = _interopRequireDefault(_graphSerieLine3d);

  var _graphSerieBar2 = _interopRequireDefault(_graphSerieBar);

  var _graphSerieBox2 = _interopRequireDefault(_graphSerieBox);

  var _graphSerieLineColored2 = _interopRequireDefault(_graphSerieLineColored);

  var _graphSerieScatter2 = _interopRequireDefault(_graphSerieScatter);

  var _graphSerieZone2 = _interopRequireDefault(_graphSerieZone);

  var _graphSerieZone3d2 = _interopRequireDefault(_graphSerieZone3d);

  var _graphSerieDensitymap2 = _interopRequireDefault(_graphSerieDensitymap);

  var _graphSerieContour2 = _interopRequireDefault(_graphSerieContour);

  var _graphShape2 = _interopRequireDefault(_graphShape);

  var _graphShapeAreaundercurve2 = _interopRequireDefault(_graphShapeAreaundercurve);

  var _graphShapeArrow2 = _interopRequireDefault(_graphShapeArrow);

  var _graphShapeEllipse2 = _interopRequireDefault(_graphShapeEllipse);

  var _graphShapeLabel2 = _interopRequireDefault(_graphShapeLabel);

  var _graphShapePolyline2 = _interopRequireDefault(_graphShapePolyline);

  var _graphShapeLine2 = _interopRequireDefault(_graphShapeLine);

  var _graphShapeNmrintegral2 = _interopRequireDefault(_graphShapeNmrintegral);

  var _graphShapePeakintegration2d2 = _interopRequireDefault(_graphShapePeakintegration2d);

  var _graphShapeRect2 = _interopRequireDefault(_graphShapeRect);

  var _graphShapeCross2 = _interopRequireDefault(_graphShapeCross);

  var _graphShapePeakboundariescenter2 = _interopRequireDefault(_graphShapePeakboundariescenter);

  var _graphShapeHtml2 = _interopRequireDefault(_graphShapeHtml);

  var _graphPlugin2 = _interopRequireDefault(_graphPlugin);

  var _graphPluginDrag2 = _interopRequireDefault(_graphPluginDrag);

  var _graphPluginShape2 = _interopRequireDefault(_graphPluginShape);

  var _graphPluginSelectScatter2 = _interopRequireDefault(_graphPluginSelectScatter);

  var _graphPluginZoom2 = _interopRequireDefault(_graphPluginZoom);

  var _graphPluginTimeseriemanager2 = _interopRequireDefault(_graphPluginTimeseriemanager);

  var _graphPluginSerielinedifference2 = _interopRequireDefault(_graphPluginSerielinedifference);

  var _graphPluginAxissplitting2 = _interopRequireDefault(_graphPluginAxissplitting);

  var _graphPluginMakeTracesDifferent2 = _interopRequireDefault(_graphPluginMakeTracesDifferent);

  var _graphPluginPeakpicking2 = _interopRequireDefault(_graphPluginPeakpicking);

  var _waveform2 = _interopRequireDefault(_waveform);

  var _fit_lm2 = _interopRequireDefault(_fit_lm);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  // Corrent naming is important here !

  _graphCore2.default.registerConstructor('graph.position', _graphPosition2.default);

  _graphCore2.default.registerConstructor('graph.axis.x', _graphAxisX2.default);
  _graphCore2.default.registerConstructor('graph.axis.y', _graphAxisY2.default);
  _graphCore2.default.registerConstructor('graph.axis.x.bar', _graphAxisXBar2.default);
  _graphCore2.default.registerConstructor('graph.axis.x.time', _graphAxisXTime2.default);

  _graphCore2.default.registerConstructor('graph.serie.line', _graphSerieLine2.default);
  _graphCore2.default.registerConstructor('graph.serie.line.3d', _graphSerieLine3d2.default);
  _graphCore2.default.registerConstructor('graph.serie.line.color', _graphSerieLineColored2.default);
  _graphCore2.default.registerConstructor('graph.serie.contour', _graphSerieContour2.default);
  _graphCore2.default.registerConstructor('graph.serie.bar', _graphSerieBar2.default);
  _graphCore2.default.registerConstructor('graph.serie.box', _graphSerieBox2.default);
  _graphCore2.default.registerConstructor('graph.serie.scatter', _graphSerieScatter2.default);
  _graphCore2.default.registerConstructor('graph.serie.zone', _graphSerieZone2.default);
  _graphCore2.default.registerConstructor('graph.serie.zone.3d', _graphSerieZone3d2.default);
  _graphCore2.default.registerConstructor('graph.serie.densitymap', _graphSerieDensitymap2.default);

  _graphCore2.default.registerConstructor(_graphCore2.default.SERIE_LINE, _graphSerieLine2.default);
  _graphCore2.default.registerConstructor(_graphCore2.default.SERIE_LINE_3D, _graphSerieLine3d2.default);
  _graphCore2.default.registerConstructor(_graphCore2.default.SERIE_LINE_COLORED, _graphSerieLineColored2.default);
  _graphCore2.default.registerConstructor(_graphCore2.default.SERIE_CONTOUR, _graphSerieContour2.default);
  _graphCore2.default.registerConstructor(_graphCore2.default.SERIE_BAR, _graphSerieBar2.default);
  _graphCore2.default.registerConstructor(_graphCore2.default.SERIE_BOX, _graphSerieBox2.default);
  _graphCore2.default.registerConstructor(_graphCore2.default.SERIE_SCATTER, _graphSerieScatter2.default);
  _graphCore2.default.registerConstructor(_graphCore2.default.SERIE_ZONE, _graphSerieZone2.default);
  _graphCore2.default.registerConstructor(_graphCore2.default.SERIE_ZONE_3D, _graphSerieZone3d2.default);
  _graphCore2.default.registerConstructor(_graphCore2.default.SERIE_DENSITYMAP, _graphSerieDensitymap2.default);

  //Graph.registerConstructor( "graph.serie.line.broken", GraphSerieLineBroken );

  _graphCore2.default.registerConstructor('graph.plugin.shape', _graphPluginShape2.default);
  _graphCore2.default.registerConstructor('graph.plugin.drag', _graphPluginDrag2.default);
  _graphCore2.default.registerConstructor('graph.plugin.zoom', _graphPluginZoom2.default);
  _graphCore2.default.registerConstructor('graph.plugin.selectScatter', _graphPluginSelectScatter2.default);
  _graphCore2.default.registerConstructor('graph.plugin.timeSerieManager', _graphPluginTimeseriemanager2.default);
  _graphCore2.default.registerConstructor('graph.plugin.serielinedifference', _graphPluginSerielinedifference2.default);
  _graphCore2.default.registerConstructor('graph.plugin.serieLineDifference', _graphPluginSerielinedifference2.default);
  _graphCore2.default.registerConstructor('graph.plugin.axissplitting', _graphPluginAxissplitting2.default);
  _graphCore2.default.registerConstructor('graph.plugin.makeTracesDifferent', _graphPluginMakeTracesDifferent2.default);
  _graphCore2.default.registerConstructor('graph.plugin.peakPicking', _graphPluginPeakpicking2.default);

  _graphCore2.default.registerConstructor('graph.shape', _graphShape2.default);
  _graphCore2.default.registerConstructor('graph.shape.areaundercurve', _graphShapeAreaundercurve2.default);
  _graphCore2.default.registerConstructor('graph.shape.arrow', _graphShapeArrow2.default);
  _graphCore2.default.registerConstructor('graph.shape.ellipse', _graphShapeEllipse2.default);
  _graphCore2.default.registerConstructor('graph.shape.label', _graphShapeLabel2.default);
  _graphCore2.default.registerConstructor('graph.shape.polyline', _graphShapePolyline2.default);
  _graphCore2.default.registerConstructor('graph.shape.line', _graphShapeLine2.default);
  _graphCore2.default.registerConstructor('graph.shape.nmrintegral', _graphShapeNmrintegral2.default);
  _graphCore2.default.registerConstructor('graph.shape.html', _graphShapeHtml2.default);
  _graphCore2.default.registerConstructor('graph.shape.peakintegration2d', _graphShapePeakintegration2d2.default);
  //  Graph.registerConstructor( "graph.shape.peakinterval", GraphShapePeakInterval );
  //  Graph.registerConstructor( "graph.shape.peakinterval2", GraphShapePeakInterval2 );
  //  Graph.registerConstructor( "graph.shape.rangex", GraphShapeRangeX );
  _graphCore2.default.registerConstructor('graph.shape.rect', _graphShapeRect2.default);
  _graphCore2.default.registerConstructor('graph.shape.rectangle', _graphShapeRect2.default);
  _graphCore2.default.registerConstructor('graph.shape.cross', _graphShapeCross2.default);
  //Graph.registerConstructor( "graph.shape.zoom2d", GraphShapeZoom2D );
  _graphCore2.default.registerConstructor('graph.shape.peakboundariescenter', _graphShapePeakboundariescenter2.default);

  //   Graph.registerConstructor( "graph.toolbar", GraphToolbar );
  _graphCore2.default.registerConstructor('graph.legend', _graphLegend2.default);
  _graphCore2.default.registerConstructor('graph.waveform', _waveform2.default);

  exports.default = _graphCore2.default;
  module.exports = exports['default'];
});

/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(55), __webpack_require__(5)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('./graph.position.js'), require('./graph.util.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphPosition, global.graphUtil);
    global.graphLegend = mod.exports;
  }
})(this, function (module, exports, _graphPosition, _graphUtil) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _graphPosition2 = _interopRequireDefault(_graphPosition);

  var util = _interopRequireWildcard(_graphUtil);

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  /**
   * Default legend configuration
   * @name LegendOptionsDefault
   * @object
   * @static
   * @prop {Boolean} frame - <code>true</code> to display a frame around the legend
   * @prop {Number} frameWidth - The width of the frame stroke
   * @prop {String} frameColor - The stroke color of the frame
   * @prop {String} backgroundColor - The background color of the frame
   * @prop {Number} paddingLeft - The left padding
   * @prop {Number} paddingRight - The right padding
   * @prop {Number} paddingTop - The top padding
   * @prop {Number} paddingBottom - The bottom padding
   * @prop {Boolean} shapesToggleable - <code>true</code> to toggle the shapes linked to serie with its status (shown or hidden)
   * @prop {Boolean} isSerieHideable - <code>true</code> to allow series to be hidden through the legend
   * @prop {Boolean} isSerieSelectable - <code>true</code> to allow series to be selected through the legend
   */
  var legendDefaults = {

    backgroundColor: 'rgba(255, 255, 255, 0.8)',
    frame: true,
    frameWidth: 1,
    frameColor: 'black',
    paddingTop: 10,
    paddingLeft: 10,
    paddingBottom: 10,
    paddingRight: 10,
    color: 'black',
    frameRounding: 0,

    movable: false,

    shapesToggleable: true,
    isSerieHideable: true,
    isSerieSelectable: true

  };

  /**
   * Legend constructor. You should not call this method directly, but rather use {@link graph.makeLegend}
   * @example var legend = graph.makeLegend( {  backgroundColor: 'rgba(255, 255, 255, 0.8)',
   * frame: true,
   * frameWidth: 1,
   * frameColor: 'black',
   * paddingTop: 10,
   * paddingLeft: 10,
   * paddingBottom: 10,
   * paddingRight: 10,
   * frameRounding: 3,
   *
   * movable: false,
   *
   * shapesToggleable: true,
   * isSerieHideable: true,
   * isSerieSelectable: true
   * } );
   */

  var Legend = function () {
    function Legend(graph, options) {
      _classCallCheck(this, Legend);

      this.options = util.extend({}, legendDefaults, options);

      this.graph = graph;
      this.svg = document.createElementNS(this.graph.ns, 'g');
      this.subG = document.createElementNS(this.graph.ns, 'g');

      this.groups = [];
      this.rect = document.createElementNS(this.graph.ns, 'rect');
      this.rectBottom = document.createElementNS(this.graph.ns, 'rect');

      this.rect.setAttribute('x', 0);
      this.rect.setAttribute('y', 0);

      this.rectBottom.setAttribute('x', 0);
      this.rectBottom.setAttribute('y', 0);

      this.series = false;

      this.svg.setAttribute('display', 'none');
      this.pos = {
        x: undefined,
        y: undefined,
        transformX: 0,
        transformY: 0
      };

      this.setEvents();

      this.eyeId = util.guid();
      this.eyeCrossedId = util.guid();

      var eyeClosed = util.SVGParser('<svg xmlns="http://www.w3.org/2000/svg"><symbol id="' + this.eyeCrossedId + '" viewBox="0 -256 1850 1850"><rect pointer-events="fill" fill="transparent" x="-256" y="0" width="2106" height="1850" /><g transform="matrix(1,0,0,-1,30.372881,1214.339)"><path d="m 555,201 78,141 q -87,63 -136,159 -49,96 -49,203 0,121 61,225 Q 280,812 128,576 295,318 555,201 z m 389,759 q 0,20 -14,34 -14,14 -34,14 -125,0 -214.5,-89.5 Q 592,829 592,704 q 0,-20 14,-34 14,-14 34,-14 20,0 34,14 14,14 14,34 0,86 61,147 61,61 147,61 20,0 34,14 14,14 14,34 z m 363,191 q 0,-7 -1,-9 Q 1201,954 991,576 781,198 675,9 l -49,-89 q -10,-16 -28,-16 -12,0 -134,70 -16,10 -16,28 0,12 44,87 Q 349,154 228.5,262 108,370 20,507 0,538 0,576 q 0,38 20,69 153,235 380,371 227,136 496,136 89,0 180,-17 l 54,97 q 10,16 28,16 5,0 18,-6 13,-6 31,-15.5 18,-9.5 33,-18.5 15,-9 31.5,-18.5 16.5,-9.5 19.5,-11.5 16,-10 16,-27 z m 37,-447 Q 1344,565 1265,450.5 1186,336 1056,286 l 280,502 q 8,-45 8,-84 z m 448,-128 q 0,-35 -20,-69 Q 1733,443 1663,362 1513,190 1315.5,95 1118,0 896,0 l 74,132 q 212,18 392.5,137 180.5,119 301.5,307 -115,179 -282,294 l 63,112 q 95,-64 182.5,-153 87.5,-89 144.5,-184 20,-34 20,-69 z" fill="#c0c0c0"></path></g></symbol></svg>');
      //  var eyeClosed = util.SVGParser('<svg xmlns="http://www.w3.org/2000/svg"><symbol id="' + this.eyeId + '" viewBox="0 0 100 100"><rect fill="black" x="0" y="0" width="100" height="100" /></symbol></svg>');

      /* var eyeClosed = document.createElementNS( this.graph.ns, "symbol");
        eyeClosed.setAttribute('id', this.eyeId );
        eyeClosed.setAttribute("viewBox", '0 0 100 100');
         var rect = document.createElementNS( this.graph.ns, "rect" );
        rect.setAttribute('width', 100 );
        rect.setAttribute('height', 100 );
        rect.setAttribute('x', 0 );
        rect.setAttribute('y', 0 );
        rect.setAttribute('fill', 'black');
        eyeClosed.appendChild( rect );
      */
      var eye = util.SVGParser('<svg xmlns="http://www.w3.org/2000/svg"><symbol id="' + this.eyeId + '" viewBox="0 -256 1850 1850"><rect pointer-events="fill" x="-256" y="0" fill="transparent" width="2106" height="1850" /><g transform="matrix(1,0,0,-1,30.372881,1259.8983)"><path d="m 1664,576 q -152,236 -381,353 61,-104 61,-225 0,-185 -131.5,-316.5 Q 1081,256 896,256 711,256 579.5,387.5 448,519 448,704 448,825 509,929 280,812 128,576 261,371 461.5,249.5 662,128 896,128 1130,128 1330.5,249.5 1531,371 1664,576 z M 944,960 q 0,20 -14,34 -14,14 -34,14 -125,0 -214.5,-89.5 Q 592,829 592,704 q 0,-20 14,-34 14,-14 34,-14 20,0 34,14 14,14 14,34 0,86 61,147 61,61 147,61 20,0 34,14 14,14 14,34 z m 848,-384 q 0,-34 -20,-69 Q 1632,277 1395.5,138.5 1159,0 896,0 633,0 396.5,139 160,278 20,507 0,542 0,576 q 0,34 20,69 140,229 376.5,368 236.5,139 499.5,139 263,0 499.5,-139 236.5,-139 376.5,-368 20,-35 20,-69 z" fill="#444444" /></g></symbol></svg>');

      this.svg.appendChild(document.adoptNode(eye.documentElement.firstChild));
      this.svg.appendChild(document.adoptNode(eyeClosed.documentElement.firstChild));

      this.svg.appendChild(this.subG);

      this.applyStyle();
    }

    /**
     * Sets the position of the legend
     * @param {Position} position - the position to set the legend to versus the graph main axes ({@link Graph#getXAxis} and {@link Graph#getYAxis})
     * @param {String} alignToX - "right" or "left". References the legend right or left boundary using the position parameter
     * @param {String} alignToY - "top" or "bottom". References the legend top or bottom boundary using the position parameter
     * @example legend.setPosition( { x: 'max', y: '0px' }, 'right', 'top' ); // The rightmost side of the legend will at the maximum value of the axis, and will be positioned at the top
     */


    _createClass(Legend, [{
      key: 'setPosition',
      value: function setPosition(position, alignToX, alignToY) {

        if (!position) {
          return;
        }

        this.position = position;
        this.alignToX = alignToX || 'left';
        this.alignToY = alignToY || 'top';
      }
    }, {
      key: 'setDraggable',
      value: function setDraggable(bln) {
        this.options.movable = bln;
      }
    }, {
      key: 'setAutoPosition',
      value: function setAutoPosition(position) {

        if (['bottom', 'left', 'top', 'right'].indexOf(position = position.toLowerCase()) > -1) {
          this.autoPosition = position;
          return this;
        }

        this.requireDelayedUpdate();
        this.autoPosition = false;
      }
    }, {
      key: 'autoPosition',
      value: function autoPosition() {
        return this.setAutoPosition.apply(this, arguments);
      }
    }, {
      key: 'buildLegendBox',
      value: function buildLegendBox() {

        var series = this.series || this.graph.getSeries(),
            posX = 0,
            posY = this.options.paddingTop;

        if (!this.autoPosition) {
          this.graph.graphingZone.appendChild(this.getDom());
        } else {
          this.graph.getDom().appendChild(this.getDom());
        }

        for (var i = 0, l = series.length; i < l; i++) {

          if (series[i].excludedFromLegend && !this.series) {
            continue;
          }

          if (this.autoPosition == 'bottom' || this.autoPosition == 'top') {

            var bbox = getBBox(this.groups[i]);

            if (posX + bbox.width > this.graph.getDrawingWidth() - this.options.paddingRight) {
              posY += 16;
              posX = 0;
            }
          }

          this.groups[i].setAttribute('transform', 'translate( ' + posX + ', ' + posY + ')');

          if (this.autoPosition == 'bottom' || this.autoPosition == 'top') {

            posX += bbox.width + 10;
            posY += 0;
          } else {

            posX = 0;
            posY += 16;
          }
        }

        var bbox = getBBox(this.subG);

        /* Independant on box position */
        this.width = bbox.width + this.options.paddingRight + this.options.paddingLeft;
        this.height = bbox.height + this.options.paddingBottom + this.options.paddingTop;

        this.rect.setAttribute('width', this.width);
        this.rect.setAttribute('height', this.height);
        this.rect.setAttribute('fill', 'none');
        this.rect.setAttribute('pointer-events', 'fill');

        this.rect.setAttribute('display', 'none');

        if (this.options.movable) {
          this.rectBottom.style.cursor = 'move';
        }

        this.rectBottom.setAttribute('width', this.width);
        this.rectBottom.setAttribute('height', this.height);

        this.rectBottom.setAttribute('x', bbox.x - this.options.paddingLeft);
        this.rectBottom.setAttribute('y', bbox.y - this.options.paddingTop);
        /* End independant on box position */

        this.position = this.position || {};

        switch (this.autoPosition) {

          case 'bottom':
            this.position.y = this.graph.getHeight() + 'px';
            // Try to center with respect to the drawing space, not the full graph. It's useful when the graph is fairly asymmetric (i.e. multiple axes on 1 side)
            this.position.x = (this.graph.drawingSpaceWidth - this.width) / 2 + this.graph.drawingSpaceMinX + 'px';
            this.alignToY = 'bottom';
            this.alignToX = false;
            break;

          case 'left':
            this.position.x = '6px';
            this.position.y = (this.graph.getHeight() - this.height) / 2 + 'px';
            this.alignToX = 'left';
            this.alignToY = false;
            break;

          case 'right':
            this.position.x = this.graph.getWidth() + 'px';
            this.position.y = (this.graph.getHeight() - this.height) / 2 + 'px';
            this.alignToX = 'right';
            this.alignToY = false;
            break;

          case 'top':
            this.position.x = (this.graph.drawingSpaceWidth - this.width) / 2 + this.graph.drawingSpaceMinX + 'px';
            this.position.y = '10px';
            this.alignToY = 'top';
            this.alignToX = false;
            break;
        }

        if (this.autoPosition) {
          switch (this.autoPosition) {

            case 'bottom':
              this.graph.options.paddingBottom = this.height + 10;
              break;

            case 'left':
              this.graph.options.paddingLeft = this.width + 5;
              break;

            case 'right':
              this.graph.options.paddingRight = this.width + 10;
              break;

            case 'top':
              this.graph.options.paddingTop = this.height + 14;
              break;
          }

          this.graph.updateGraphingZone();
          this.graph.getDrawingHeight();
          this.graph.getDrawingWidth();
          // this.graph.redraw( false );
        }

        this.bbox = bbox;
      }
    }, {
      key: 'calculatePosition',
      value: function calculatePosition() {

        var pos = _graphPosition2.default.check(this.position);
        var poscoords = pos.compute(this.graph, this.graph.getXAxis(), this.graph.getYAxis());

        if (!poscoords) {
          return;
        }

        if (pos.y == 'max') {
          poscoords.y += this.graph.getPaddingTop();
        }

        if (pos.x == 'max') {
          poscoords.x -= this.graph.getPaddingRight();
        }

        if (this.alignToX == 'right') {
          poscoords.x -= this.width;
          poscoords.x -= this.bbox.x;
        } else {
          //poscoords.x -= this.bbox.x;
        }

        if (this.alignToY == 'bottom') {
          poscoords.y -= this.height;
          poscoords.y -= this.bbox.y;
        } else {

          poscoords.y -= this.bbox.y;
        }

        this.pos.transformX = poscoords.x;
        this.pos.transformY = poscoords.y;

        this._setPosition();
      }
    }, {
      key: 'update',
      value: function update(onlyIfRequired) {

        if (this.graph.isDelayedUpdate() || !this._requiredUpdate && onlyIfRequired) {
          return;
        }

        this._requiredUpdate = false;

        var self = this;

        this.applyStyle();

        while (this.subG.hasChildNodes()) {
          this.subG.removeChild(this.subG.lastChild);
        }

        this.svg.insertBefore(this.rectBottom, this.svg.firstChild);

        var series = this.series || this.graph.getSeries(),
            line,
            text,
            g;

        if (series.length > 0) {
          this.svg.setAttribute('display', 'block');
        } else {
          return;
        }

        if (this.autoPosition == 'bottom' || this.autoPosition == 'top') {
          var fullWidth = this.graph.getDrawingWidth();
        }

        var posX, posY;

        for (var i = 0, l = series.length; i < l; i++) {

          if (series[i].excludedFromLegend && !this.series) {
            continue;
          }

          (function (j) {

            var g,
                line,
                text,
                xPadding = 0;

            if (this.autoPosition == 'bottom' || this.autoPosition == 'top') {
              var fullWidth = this.graph.getDrawingWidth();
            }

            g = document.createElementNS(self.graph.ns, 'g');
            var rect = document.createElementNS(self.graph.ns, 'rect');

            self.subG.appendChild(g);

            g.appendChild(rect);

            var line = series[j].getSymbolForLegend();
            var marker = series[j].getMarkerForLegend();
            var text = series[j].getTextForLegend();

            var dx = 35;

            if (this.isHideable()) {
              dx += 20;

              var eyeUse = document.createElementNS(self.graph.ns, 'use');
              eyeUse.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', '#' + (series[i].isShown() ? this.eyeId : this.eyeCrossedId));
              eyeUse.setAttribute('width', 15);
              eyeUse.setAttribute('height', 15);
              eyeUse.setAttribute('x', 35);
              eyeUse.setAttribute('y', -8);

              eyeUse.addEventListener('click', function (e) {
                e.stopPropagation();

                var id;
                if (series[j].isShown()) {
                  series[j].hide(self.options.hideShapesOnHideSerie);
                  id = self.eyeCrossedId;
                } else {
                  series[j].show(self.options.hideShapesOnHideSerie);
                  id = self.eyeId;
                }

                eyeUse.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', '#' + id);
              });
            }

            text.setAttribute('transform', 'translate(' + dx + ', 3)');
            text.setAttribute('fill', this.options.color);

            if (line) {
              g.appendChild(line);
            }

            if (series[j].getType() == 'scatter') {
              line.setAttribute('transform', 'translate( 20, 0 )');
            }

            if (marker) {
              g.appendChild(marker);
            }

            if (eyeUse) {
              g.appendChild(eyeUse);
            }

            g.appendChild(text);

            var bbox = getBBox(g);

            rect.setAttribute('x', bbox.x);
            rect.setAttribute('y', bbox.y);
            rect.setAttribute('width', bbox.width);
            rect.setAttribute('height', bbox.height);
            rect.setAttribute('fill', 'none');
            rect.setAttribute('pointer-events', 'fill');

            self.groups[j] = g;

            g.addEventListener('click', function (e) {

              var serie = series[j];

              if (!serie.isShown()) {
                return;
              }

              if (self.isSelectable() && !serie.isSelected()) {

                self.graph.selectSerie(serie);
              } else {

                self.graph.unselectSerie(serie);
              }

              e.preventDefault();
              e.stopPropagation();
            });
          }).call(this, i);
        }

        this.svg.appendChild(this.rect);
        this.buildLegendBox();
        this.calculatePosition();
      }
    }, {
      key: 'isHideable',
      value: function isHideable() {
        return this.options.isSerieHideable;
      }
    }, {
      key: 'notHideable',
      value: function notHideable() {
        this.options.isSerieHideable = false;
        return this;
      }
    }, {
      key: 'hideable',
      value: function hideable() {
        this.options.isSerieHideable = true;
        return this;
      }
    }, {
      key: 'isSelectable',
      value: function isSelectable() {
        return this.options.isSerieSelectable;
      }
    }, {
      key: 'isToggleShapes',
      value: function isToggleShapes() {
        return this.options.shapesToggleable;
      }
    }, {
      key: 'getDom',
      value: function getDom() {
        return this.svg;
      }
    }, {
      key: 'setEvents',
      value: function setEvents() {

        var self = this;
        var pos = this.pos;

        var mousedown = function mousedown(e) {

          e.stopPropagation();
          console.log('down');
          if (self.options.movable) {
            pos.x = e.clientX;
            pos.y = e.clientY;

            e.preventDefault();
            self.mousedown = true;
            self.graph.elementMoving(self);

            self.rect.setAttribute('display', 'block');
          }
        };

        var mousemove = function mousemove(e) {
          self.handleMouseMove(e);
        };

        this.svg.addEventListener('mousedown', mousedown);
        this.svg.addEventListener('click', function (e) {
          e.stopPropagation();
        });
        this.svg.addEventListener('dblclick', function (e) {
          e.stopPropagation();
        });
        this.svg.addEventListener('mousemove', mousemove);
        //this.rect.addEventListener( 'mousemove', mousemove );
      }
    }, {
      key: 'handleMouseUp',
      value: function handleMouseUp(e) {

        e.stopPropagation();
        e.preventDefault();
        this.mousedown = false;
        this.rect.setAttribute('display', 'none');
        this.graph.elementMoving(false);
      }
    }, {
      key: 'handleMouseMove',
      value: function handleMouseMove(e) {

        if (!this.mousedown) {
          return;
        }

        var pos = this.pos;

        var deltaX = e.clientX - pos.x;
        var deltaY = e.clientY - pos.y;

        pos.transformX += deltaX;
        pos.transformY += deltaY;

        pos.x = e.clientX;
        pos.y = e.clientY;

        e.stopPropagation();
        e.preventDefault();

        this._setPosition();
      }
    }, {
      key: '_setPosition',
      value: function _setPosition() {

        var pos = this.pos;
        if (!isNaN(pos.transformX) && !isNaN(pos.transformY) && pos.transformX !== false && pos.transformY !== false) {
          this.svg.setAttribute('transform', 'translate(' + pos.transformX + ', ' + pos.transformY + ')');
        }
      }
    }, {
      key: 'applyStyle',
      value: function applyStyle() {

        if (this.options.frame) {
          this.rectBottom.setAttribute('stroke', this.options.frameColor);
          this.rectBottom.setAttribute('stroke-width', this.options.frameWidth + 'px');
          this.rectBottom.setAttribute('rx', this.options.frameRounding);
          this.rectBottom.setAttribute('ry', this.options.frameRounding);
        }

        this.rectBottom.setAttribute('fill', this.options.backgroundColor);
      }
    }, {
      key: 'fixSeries',
      value: function fixSeries() {
        var series = [];

        if (arguments[0] === false) {
          this.series = false;
          this.update();
          return;
        }

        for (var i = 0, l = arguments.length; i < l; i++) {
          if (Array.isArray(arguments[i])) {
            series = series.concat(arguments[i]);
          } else {
            series.push(arguments[i]);
          }
        }

        this.update();
        this.series = series;
      }
    }, {
      key: 'fixSeriesAdd',
      value: function fixSeriesAdd(serie) {
        this.series = this.series || [];
        this.series.push(serie);
      }
    }, {
      key: 'requireDelayedUpdate',
      value: function requireDelayedUpdate() {
        this._requiredUpdate = true;
      }
    }, {
      key: 'seriesHideable',
      set: function set(hideable) {
        this.options.isSerieHideable = !!hideable;
      },
      get: function get() {
        return this.options.isSerieHideable;
      }
    }]);

    return Legend;
  }();

  function getBBox(svgElement) {
    // Firefox throws when trying to call getBBox() on elements
    // that are not yet rendered.
    try {
      return svgElement.getBBox();
    } catch (e) {
      return {
        height: 0,
        width: 0,
        x: 0,
        y: 0
      };
    }
  }

  exports.default = Legend;
  module.exports = exports['default'];
});

/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(101)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('./graph.axis.x.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphAxisX);
    global.graphAxisXBar = mod.exports;
  }
})(this, function (module, exports, _graphAxisX) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _graphAxisX2 = _interopRequireDefault(_graphAxisX);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var AxisXBar = function (_AxisX) {
    _inherits(AxisXBar, _AxisX);

    function AxisXBar(graph, topbottom) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      _classCallCheck(this, AxisXBar);

      return _possibleConstructorReturn(this, (AxisXBar.__proto__ || Object.getPrototypeOf(AxisXBar)).call(this, graph, topbottom, options));
    }

    /**
     * @param {Object[]} categories - Categories array
     * @param {(String|Number)} categories[].title - The title of the category (to be dispalyed)
     * @param {(String|Number)} categories[].name - The name of the category (to indentify series)
     * @returns {AxisBar} The current axis instance
     */


    _createClass(AxisXBar, [{
      key: 'draw',
      value: function draw() {

        var self = this,
            tickLabel,
            elements = this._barCategories;

        this.forceMin(0);
        this.forceMax(1);

        this.cacheCurrentMin();
        this.cacheCurrentMax();
        this.cacheInterval();

        if (!elements) {
          return;
        }

        if (!Array.isArray(elements)) {
          elements = [elements];
        }

        // this.drawInit();

        //var widthPerElement = width / elements.length;
        for (var i = 0; i <= elements.length; i++) {
          this.drawTick(i / elements.length, 2);

          if (i < elements.length) {
            tickLabel = this.nextTickLabel(function (tickLabel) {

              tickLabel.setAttribute('y', (self.top ? -1 : 1) * ((self.options.tickPosition == 1 ? 8 : 20) + (self.top ? 10 : 0)));
              tickLabel.setAttribute('text-anchor', 'middle');
              if (self.getTicksLabelColor() !== 'black') {
                tickLabel.setAttribute('fill', self.getTicksLabelColor());
              }
              tickLabel.style.dominantBaseline = 'hanging';
            });

            tickLabel.setAttribute('x', this.getPos((i + 0.5) / elements.length));
            tickLabel.textContent = elements[i].title;
          }
        }

        this.drawSpecifics();
        return this;
      }
    }, {
      key: 'autoSeries',
      value: function autoSeries() {

        var series = [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.graph.series[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var serie = _step.value;

            if (serie.getXAxis() == this) {
              series.push(serie);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        this.setSeries.apply(this, series);
        return this;
      }
    }, {
      key: 'setSeries',
      value: function setSeries() {

        var self = this;
        this.series = arguments;

        Array.prototype.map.call(this.series, function (serie, index) {

          if (!((typeof serie === 'undefined' ? 'undefined' : _typeof(serie)) == 'object')) {
            serie = self.graph.getSerie(serie);
          }

          if (serie.setCategoryConfig) {
            serie.setCategoryConfig(index, self._barCategories, self.series.length);
          }
        });

        this._getUsedCategories();

        return this;
      }
    }, {
      key: '_getUsedCategories',
      value: function _getUsedCategories() {

        var categories = {},
            total = 0;

        Array.prototype.map.call(this.series, function (serie) {
          var usedCategories = serie.getUsedCategories();
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = usedCategories[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var cat = _step2.value;


              if (!categories.hasOwnProperty(cat)) {
                categories[cat] = 1;
                total += 1;
              }

              categories[cat]++;
              total++;
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        });

        var accumulator = 0;
        for (var i in categories) {
          var temp = categories[i];
          categories[i] = accumulator;
          accumulator += temp;
        }

        var dispatchedCategories = {};

        Array.prototype.map.call(this.series, function (serie) {

          var scategories = serie.getUsedCategories(),
              indices = {};

          scategories.forEach(function (cat) {

            dispatchedCategories[cat] = dispatchedCategories[cat] || 0.5;
            indices[cat] = (categories[cat] + dispatchedCategories[cat]) / total;
            dispatchedCategories[cat]++;
          });

          serie.setDataIndices(indices, total);
        });
      }
    }, {
      key: 'getType',
      value: function getType() {
        return 'category';
      }
    }, {
      key: 'categories',
      set: function set(categories) {
        this._barCategories = categories;
        return this;
      }
    }]);

    return AxisXBar;
  }(_graphAxisX2.default);

  exports.default = AxisXBar;
  module.exports = exports['default'];
});

/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(73), __webpack_require__(5)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('./graph.axis.js'), require('./graph.util.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphAxis, global.graphUtil);
    global.graphAxisXTime = mod.exports;
  }
})(this, function (module, exports, _graphAxis, _graphUtil) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _graphAxis2 = _interopRequireDefault(_graphAxis);

  var util = _interopRequireWildcard(_graphUtil);

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var axisFormat = [{

    threshold: 20,
    increments: {

      1: {
        increment: 1, // 1 minute
        unit: 'i',
        format: 'HH"h"MM (dd/mm/yy)'
      },

      2: { // 10 seconds
        increment: 1,
        unit: 's',
        format: 'MM:ss"s"'
      }
    }
  }, {

    threshold: 50,
    increments: {

      1: {
        increment: 1, // 1 minute
        unit: 'i',
        format: 'HH"h"MM (dd/mm/yy)'
      },

      2: { // 2 seconds
        increment: 2,
        unit: 's',
        format: 'MM:ss"s"'
      }
    }
  }, {

    threshold: 100,
    increments: {

      1: {
        increment: 1, // 1 minute
        unit: 'i',
        format: 'HH"h"MM (dd/mm/yy)'
      },

      2: { // 5 seconds
        increment: 5,
        unit: 's',
        format: 'MM:ss"s"'
      }
    }
  }, {

    threshold: 600,
    increments: {

      1: {
        increment: 10, // 1 minute
        unit: 'i',
        format: 'HH"h"MM (dd/mm/yy)'
      },

      2: { // 10 seconds
        increment: 30,
        unit: 's',
        format: 'MM:ss"s"'
      }
    }
  }, { // One day

    threshold: 1000,
    increments: {

      1: { // 1h
        increment: 1,
        unit: 'h',
        format: 'HH"h"MM (dd/mm/yy)'
      },

      2: { // 10 minutes
        increment: 10,
        unit: 'i',
        format: 'MM"min"'
      }
    }
  }, { // One day

    threshold: 1500,
    increments: {

      1: {
        increment: 1, // One day on the first axis
        unit: 'd',
        format: 'dd/mm/yyyy'
      },

      2: {
        increment: 1,
        unit: 'i',
        format: 'H"h"MM'
      }
    }
  }, { // One day

    threshold: 3000,
    increments: {

      1: {
        increment: 1, // One day on the first axis
        unit: 'd',
        format: 'dd/mm/yyyy'
      },

      2: {
        increment: 2,
        unit: 'i',
        format: 'H"h"MM'
      }
    }
  }, { // One day

    threshold: 8000,
    increments: {

      1: {
        increment: 1, // One day on the first axis
        unit: 'd',
        format: 'dd/mm/yyyy'
      },

      2: {
        increment: 10,
        unit: 'i',
        format: 'H"h"MM'
      }
    }
  }, { // One day

    threshold: 26400,
    increments: {

      1: {
        increment: 1, // One day on the first axis
        unit: 'd',
        format: 'dd/mm/yyyy'
      },

      2: {
        increment: 20,
        unit: 'i',
        format: 'H"h"MM'
      }
    }
  }, { // One day

    threshold: 86400,
    increments: {

      1: {
        increment: 1, // One day on the first axis
        unit: 'd',
        format: 'dd/mm/yyyy'
      },

      2: {
        increment: 1,
        unit: 'h',
        format: 'H"h"MM'
      }
    }
  }, { // One day

    threshold: 200000,
    increments: {

      1: {

        increment: 1,
        unit: 'd',
        format: 'dd/mm/yyyy'
      },

      2: {

        increment: 2, // One day on the first axis
        unit: 'h',
        format: 'H"h"MM'
      }
    }
  }, { // One day

    threshold: 400000,
    increments: {

      1: {

        increment: 1,
        unit: 'd',
        format: 'dd/mm/yyyy'
      },

      2: {

        increment: 6, // One day on the first axis
        unit: 'h',
        format: 'H"h"MM'
      }
    }
  }, { // One day

    threshold: 1400000,
    increments: {

      1: {

        increment: 1,
        unit: 'd',
        format: 'dd/mm/yyyy'
      },

      2: {

        increment: 12, // One day on the first axis
        unit: 'h',
        format: 'HH"h"MM'
      }
    }
  }, { // One day

    threshold: 6400000,
    increments: {

      1: {

        increment: 1,
        unit: 'm',
        format: 'mmmm yyyy'
      },

      2: {

        increment: 1, // One day on the first axis
        unit: 'd',
        format: 'dd'
      }
    }
  }, { // One day

    threshold: 12400000,
    increments: {

      1: {

        increment: 1,
        unit: 'm',
        format: 'mmmm yyyy'
      },

      2: {

        increment: 2, // One day on the first axis
        unit: 'd',
        format: 'dd'
      }
    }
  }, { // One day

    threshold: 86400000 * 0.5,
    increments: {

      1: {

        increment: 1,
        unit: 'm',
        format: 'mmmm yyyy'
      },

      2: {

        increment: 7, // One day on the first axis
        unit: 'd',
        format: 'dd'
      }
    }
  }, { // One day

    threshold: 86400000 * 0.8,
    increments: {

      1: {

        increment: 1,
        unit: 'm',
        format: 'mmmm yyyy'
      },

      2: {

        increment: 15, // One day on the first axis
        unit: 'd',
        format: 'dd'
      }
    }
  }, { // One month

    threshold: 86400000 * 1,
    increments: {

      1: {
        increment: 1,
        unit: 'y',
        format: 'yyyy'
      },

      2: {

        increment: 3, // One day on the first axis
        unit: 'm',
        format: 'mm/yyyy'
      }
    }
  }, { // One month

    threshold: 86400000 * 2,
    increments: {

      1: {

        increment: 1,
        unit: 'y',
        format: 'yyyy'
      },

      2: {

        increment: 4, // One day on the first axis
        unit: 'm',
        format: 'mm/yyyy'
      }
    }
  }, { // One month

    threshold: 86400000 * 10,
    increments: {

      1: {

        increment: 1,
        unit: 'y',
        format: 'yyyy'
      },

      2: {

        increment: 6, // One day on the first axis
        unit: 'm',
        format: 'mm/yyyy'
      }
    }
  }, { // One month

    threshold: 86400000 * 12,
    increments: {

      1: {

        increment: 1,
        unit: 'y',
        format: 'yyyy'
      },

      2: {

        increment: 1, // One day on the first axis
        unit: 'y',
        format: 'yyyy'
      }
    }
  }];

  /*
   * Date Format 1.2.3
   * (c) 2007-2009 Steven Levithan <stevenlevithan.com>
   * MIT license
   *
   * Includes enhancements by Scott Trenda <scott.trenda.net>
   * and Kris Kowal <cixar.com/~kris.kowal/>
   *
   * Accepts a date, a mask, or a date and a mask.
   * Returns a formatted version of the given date.
   * The date defaults to the current date/time.
   * The mask defaults to dateFormat.masks.default.
   */

  var dateFormat = function () {
    var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[WLloSZ]|"[^"]*"|'[^']*'/g,
        timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
        timezoneClip = /[^-+\dA-Z]/g,
        pad = function pad(val, len) {
      val = String(val);
      len = len || 2;
      while (val.length < len) {
        val = '0' + val;
      }return val;
    },
        getWeek = function getWeek(d, f) {
      var onejan = new Date(d[f + 'FullYear'](), 0, 1);
      return Math.ceil(((d - onejan) / 86400000 + onejan[f + 'Day']() + 1) / 7);
    };

    // Regexes and supporting functions are cached through closure
    return function (date, mask, utc) {
      var dF = dateFormat;

      // You can't provide utc if you skip other args (use the "UTC:" mask prefix)
      if (arguments.length == 1 && Object.prototype.toString.call(date) == '[object String]' && !/\d/.test(date)) {
        mask = date;
        date = undefined;
      }

      // Passing date through Date applies Date.parse, if necessary
      date = date ? new Date(date) : new Date();
      if (isNaN(date)) throw SyntaxError('invalid date:' + date);

      mask = String(dF.masks[mask] || mask || dF.masks.default);

      // Allow setting the utc argument via the mask
      if (mask.slice(0, 4) == 'UTC:') {
        mask = mask.slice(4);
        utc = true;
      }

      var _ = utc ? 'getUTC' : 'get',
          d = date[_ + 'Date'](),
          D = date[_ + 'Day'](),
          m = date[_ + 'Month'](),
          y = date[_ + 'FullYear'](),
          H = date[_ + 'Hours'](),
          M = date[_ + 'Minutes'](),
          s = date[_ + 'Seconds'](),
          L = date[_ + 'Milliseconds'](),
          o = utc ? 0 : date.getTimezoneOffset(),
          flags = {
        d: d,
        dd: pad(d),
        ddd: dF.i18n.dayNames[D],
        dddd: dF.i18n.dayNames[D + 7],
        m: m + 1,
        mm: pad(m + 1),
        mmm: dF.i18n.monthNames[m],
        mmmm: dF.i18n.monthNames[m + 12],
        yy: String(y).slice(2),
        yyyy: y,
        h: H % 12 || 12,
        hh: pad(H % 12 || 12),
        H: H,
        HH: pad(H),
        M: M,
        MM: pad(M),
        s: s,
        ss: pad(s),
        l: pad(L, 3),
        L: pad(L > 99 ? Math.round(L / 10) : L),
        t: H < 12 ? 'a' : 'p',
        tt: H < 12 ? 'am' : 'pm',
        T: H < 12 ? 'A' : 'P',
        TT: H < 12 ? 'AM' : 'PM',
        Z: utc ? 'UTC' : (String(date).match(timezone) || ['']).pop().replace(timezoneClip, ''),
        o: (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
        S: ['th', 'st', 'nd', 'rd'][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10],
        W: getWeek(date, _)
      };

      return mask.replace(token, function ($0) {
        return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
      });
    };
  }();

  // Some common format strings
  dateFormat.masks = {
    'default': 'ddd mmm dd yyyy HH:MM:ss',
    shortDate: 'm/d/yy',
    mediumDate: 'mmm d, yyyy',
    longDate: 'mmmm d, yyyy',
    fullDate: 'dddd, mmmm d, yyyy',
    shortTime: 'h:MM TT',
    mediumTime: 'h:MM:ss TT',
    longTime: 'h:MM:ss TT Z',
    isoDate: 'yyyy-mm-dd',
    isoTime: 'HH:MM:ss',
    isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
    isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
  };

  // Internationalization strings
  dateFormat.i18n = {
    dayNames: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
    monthNames: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec', 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
  };

  /* END DATE FORMAT */

  function getClosestIncrement(value, basis) {
    return Math.round(value / basis) * basis;
  }

  function roundDate(date, format) {

    switch (format.unit) {

      case 's':
        // Round at n hour

        date.setSeconds(getClosestIncrement(date.getSeconds(), format.increment));
        date.setMilliseconds(0);

        break;

      case 'i':
        // Round at n hour

        date.setMinutes(getClosestIncrement(date.getMinutes(), format.increment));
        date.setSeconds(0);
        date.setMilliseconds(0);

        break;

      case 'h':
        // Round at n hour

        date.setHours(getClosestIncrement(date.getHours(), format.increment));

        date.setMinutes(0);
        date.setSeconds(0);
        date.setMilliseconds(0);

        break;

      case 'd':

        date.setMinutes(0);
        date.setSeconds(0);
        date.setMilliseconds(0);
        date.setHours(0);

        date.setDate(getClosestIncrement(date.getDate(), format.increment));

        break;

      case 'm':

        date.setMinutes(0);
        date.setSeconds(0);
        date.setMilliseconds(0);
        date.setHours(0);
        date.setDate(1);

        date.setMonth(getClosestIncrement(date.getMonth(), format.increment));

        break;

      case 'y':

        date.setMinutes(0);
        date.setSeconds(0);
        date.setMilliseconds(0);
        date.setHours(0);
        date.setDate(1);
        date.setMonth(0);

        //date.setYear( getClosest( date.getDate(), format.increment ) );

        break;

      default:
        {
          throw new Error('Date format not recognized');
        }
    }

    return date;
  }

  function incrementDate(date, format) {

    switch (format.unit) {

      case 's':

        date.setSeconds(date.getSeconds() + format.increment);
        date.setMilliseconds(0);

        break;

      case 'i':

        date.setMinutes(date.getMinutes() + format.increment);
        date.setSeconds(0);
        date.setMilliseconds(0);

        break;

      case 'h':
        // Round at n hour

        date.setHours(date.getHours() + format.increment);
        date.setMinutes(0);
        date.setSeconds(0);
        date.setMilliseconds(0);

        break;

      case 'd':

        date.setDate(date.getDate() + format.increment);
        date.setMinutes(0);
        date.setSeconds(0);
        date.setMilliseconds(0);
        date.setHours(0);

        break;

      case 'm':

        date.setMonth(date.getMonth() + format.increment);
        date.setMinutes(0);
        date.setSeconds(0);
        date.setMilliseconds(0);
        date.setHours(0);
        date.setDate(1);

        break;

      case 'y':

        date.setFullYear(date.getFullYear() + format.increment);

        date.setMinutes(0);
        date.setSeconds(0);
        date.setMilliseconds(0);
        date.setHours(0);
        date.setDate(1);
        date.setMonth(0);

        break;

      default:
        {
          throw new Error('Date format not recognized');
        }
    }

    return date;
  }

  function getGroup(axis, level, number) {

    if (axis.groups[level][number]) {
      axis.groups[level][number].group.setAttribute('display', 'block');
      return axis.groups[level][number];
    }

    var g = {

      group: document.createElementNS(axis.graph.ns, 'g'),
      text: document.createElementNS(axis.graph.ns, 'text')
    };

    var line = document.createElementNS(axis.graph.ns, 'line');

    line.setAttribute('stroke', 'black');
    line.setAttribute('y1', 0);
    switch (level) {

      case 2:

        line.setAttribute('y2', 6);
        g.text.setAttribute('y', 15);

        g.line = line;

        g.group.appendChild(g.line);
        break;

      default:
      case 1:

        line.setAttribute('y2', 20);
        g.text.setAttribute('y', 10);

        g.line1 = line;
        g.line2 = line.cloneNode();

        g.group.appendChild(g.line1);
        g.group.appendChild(g.line2);

        break;
    }

    g.text.setAttribute('text-anchor', 'middle');
    g.text.setAttribute('dominant-baseline', 'middle');

    g.group.appendChild(g.text);

    axis.getWrapper(level).appendChild(g.group);

    return axis.groups[level][number] = g;
  }

  function hideGroups(axis, level, from) {

    for (; from < axis.groups[level].length; from++) {

      hideGroup(axis.groups[level][from]);
    }
  }

  function hideGroup(group) {
    group.group.setAttribute('display', 'none');
  }

  function getDateText(date, format) {

    return dateFormat(date, format);
  }

  function renderGroup(level, group, text, minPx, maxPx, x1, x2) {

    switch (level) {

      case 2:

        if (x1 < minPx || x1 > maxPx) {

          hideGroup(group);
          return;
        }

        group.line.setAttribute('x1', x1);
        group.line.setAttribute('x2', x1);
        group.text.setAttribute('x', x1);
        group.text.textContent = text;

        break;

      default:
      case 1:

        var x1B = Math.max(minPx, Math.min(maxPx, x1)),
            x2B = Math.max(minPx, Math.min(maxPx, x2));

        if (isNaN(x2B) || isNaN(x1B)) {
          return;
        }

        group.line1.setAttribute('x1', x1B);
        group.line2.setAttribute('x1', x2B);

        group.line1.setAttribute('x2', x1B);
        group.line2.setAttribute('x2', x2B);

        group.text.setAttribute('x', (x1B + x2B) / 2);

        while (text.length * 8 > x2B - x1B) {

          text = text.substr(0, text.length - 2) + '.';

          if (text.length == 1) {
            text = '';
            break;
          }
        }

        group.text.textContent = text;
        break;
    }
  }

  var GraphTimeAxis = function (_Axis) {
    _inherits(GraphTimeAxis, _Axis);

    function GraphTimeAxis() {
      _classCallCheck(this, GraphTimeAxis);

      return _possibleConstructorReturn(this, (GraphTimeAxis.__proto__ || Object.getPrototypeOf(GraphTimeAxis)).apply(this, arguments));
    }

    _createClass(GraphTimeAxis, [{
      key: 'init',
      value: function init(graph, options) {

        _get(GraphTimeAxis.prototype.__proto__ || Object.getPrototypeOf(GraphTimeAxis.prototype), 'init', this).call(this, graph, options);

        this.wrapper = {
          1: document.createElementNS(graph.ns, 'g'),
          2: document.createElementNS(graph.ns, 'g')
        };
        this.groups = {
          1: [],
          2: []
        };

        var rect = document.createElementNS(graph.ns, 'rect');
        rect.setAttribute('fill', '#c0c0c0');
        rect.setAttribute('stroke', '#808080');
        rect.setAttribute('height', '20');
        rect.setAttribute('x', '0');
        rect.setAttribute('y', '0');

        this.rect = rect;

        this.wrapper[1].appendChild(this.rect);

        //    this.init( graph, options );

        this.group.appendChild(this.wrapper[1]);
        this.group.appendChild(this.wrapper[2]);

        this.wrapper[1].setAttribute('transform', 'translate( 0, 25 )');
        this.wrapper[2].setAttribute('transform', 'translate( 0, 00 )');
      }
    }, {
      key: 'draw',
      value: function draw() {
        // Redrawing of the axis

        //this.drawInit();

        this.cacheCurrentMax();
        this.cacheCurrentMin();

        if (this.currentAxisMin == undefined || this.currentAxisMax == undefined) {
          this.setMinMaxToFitSeries(true); // We reset the min max as a function of the series
        }

        this.line.setAttribute('x1', this.getMinPx());
        this.line.setAttribute('x2', this.getMaxPx());
        this.line.setAttribute('y1', 0);
        this.line.setAttribute('y2', 0);

        var widthPx = this.maxPx - this.minPx;
        var widthTime = this.getCurrentInterval();

        var timePerPx = widthTime / widthPx;

        var maxVal = this.getCurrentMax();
        var minVal = this.getCurrentMin();

        this.rect.setAttribute('width', widthPx);
        this.rect.setAttribute('x', this.minPx);

        if (!maxVal || !minVal) {
          return 0;
        }

        var currentFormat;

        for (i = 0; i < axisFormat.length; i++) {

          if (axisFormat[i].threshold > timePerPx) {
            currentFormat = axisFormat[i];

            break;
          }
        }

        if (!currentFormat) {
          currentFormat = axisFormat[axisFormat.length - 1];
        }

        var xVal1,
            xVal2,
            level = 0,
            dateFirst,
            currentDate,
            text,
            group,
            i;

        for (level = 1; level <= 2; level++) {

          if (!util.isNumeric(minVal)) {
            hideGroups(this, level, 0);
            break;
          }

          dateFirst = new Date(minVal);

          currentDate = roundDate(dateFirst, currentFormat.increments[level]);

          i = 0;

          do {
            /** @ignore */
            text = getDateText(currentDate, currentFormat.increments[level].format);
            group = getGroup(this, level, i);

            xVal1 = this.getPx(currentDate.getTime());
            currentDate = incrementDate(currentDate, currentFormat.increments[level]);
            xVal2 = this.getPx(currentDate.getTime());

            renderGroup(level, group, text, this.getMinPx(), this.getMaxPx(), xVal1, xVal2);

            i++;
            if (i > 100) {
              break;
            }
          } while (currentDate.getTime() < maxVal);

          hideGroups(this, level, i);
        }
      }
    }, {
      key: 'isX',
      value: function isX() {
        return true;
      }
    }, {
      key: 'getWrapper',
      value: function getWrapper(level) {
        return this.wrapper[level];
      }
    }, {
      key: 'setShift',
      value: function setShift(shift) {
        this.shift = shift;
        this.group.setAttribute('transform', 'translate(0 ' + (this.top ? this.shift : this.graph.getDrawingHeight() - this.shift) + ')');
      }
    }, {
      key: 'getAxisPosition',
      value: function getAxisPosition() {
        return 60;
      }
    }, {
      key: 'setMinMaxFlipped',
      value: function setMinMaxFlipped() {

        var interval = this.maxPx - this.minPx;
        var maxPx = interval * this.options.span[1] + this.minPx;
        var minPx = interval * this.options.span[0] + this.minPx;

        this.minPxFlipped = this.isFlipped() ? maxPx : minPx;
        this.maxPxFlipped = this.isFlipped() ? minPx : maxPx;
      }
    }]);

    return GraphTimeAxis;
  }(_graphAxis2.default);

  exports.default = GraphTimeAxis;
  module.exports = exports['default'];
});

/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(45), __webpack_require__(46), __webpack_require__(140), __webpack_require__(5), __webpack_require__(51)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('../graph.core.js'), require('../util/waveform.js'), require('../mixins/graph.mixin.serie3d.js'), require('../graph.util.js'), require('./graph.serie.line.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphCore, global.waveform, global.graphMixinSerie3d, global.graphUtil, global.graphSerieLine);
    global.graphSerieLine3d = mod.exports;
  }
})(this, function (module, exports, _graphCore, _waveform, _graphMixinSerie3d, _graphUtil, _graphSerieLine) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _graphCore2 = _interopRequireDefault(_graphCore);

  var _waveform2 = _interopRequireDefault(_waveform);

  var _graphMixinSerie3d2 = _interopRequireDefault(_graphMixinSerie3d);

  var util = _interopRequireWildcard(_graphUtil);

  var _graphSerieLine2 = _interopRequireDefault(_graphSerieLine);

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var SerieLine3D = function (_Serie) {
    _inherits(SerieLine3D, _Serie);

    _createClass(SerieLine3D, null, [{
      key: 'defaults',
      value: function defaults() {
        return {
          zpos: 0
        };
      }
    }]);

    function SerieLine3D(graph, name, options) {
      _classCallCheck(this, SerieLine3D);

      return _possibleConstructorReturn(this, (SerieLine3D.__proto__ || Object.getPrototypeOf(SerieLine3D)).apply(this, arguments));
    }

    /**
     * Sets the z-position
     * @memberof SerieLine3D
     * @param {Number} zPos - The position in the z axis
     */


    _createClass(SerieLine3D, [{
      key: 'setZPos',
      value: function setZPos(zPos) {
        this.options.zpos = zPos;
        return this;
      }
    }, {
      key: 'setz',
      value: function setz() {
        return this.setZPos.apply(this, arguments);
      }
    }]);

    return SerieLine3D;
  }(_graphSerieLine2.default);

  util.mix(SerieLine3D, _graphMixinSerie3d2.default);
  exports.default = SerieLine3D;
  module.exports = exports['default'];
});

/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(5), __webpack_require__(74), __webpack_require__(51)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('../graph.util.js'), require('../mixins/graph.mixin.errorbars.js'), require('./graph.serie.line.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphUtil, global.graphMixinErrorbars, global.graphSerieLine);
    global.graphSerieBar = mod.exports;
  }
})(this, function (module, exports, _graphUtil, _graphMixinErrorbars, _graphSerieLine) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var util = _interopRequireWildcard(_graphUtil);

  var _graphMixinErrorbars2 = _interopRequireDefault(_graphMixinErrorbars);

  var _graphSerieLine2 = _interopRequireDefault(_graphSerieLine);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var SerieBar = function (_Serie) {
    _inherits(SerieBar, _Serie);

    function SerieBar(graph, name, options) {
      _classCallCheck(this, SerieBar);

      var _this = _possibleConstructorReturn(this, (SerieBar.__proto__ || Object.getPrototypeOf(SerieBar)).apply(this, arguments));

      _this.groupMain = document.createElementNS(_this.graph.ns, 'g');

      _this.pathDom = document.createElementNS(_this.graph.ns, 'path');
      _this.groupMain.appendChild(_this.pathDom);

      // Creates an empty style variable
      _this.styles = {};

      // Unselected style
      _this.styles.unselected = {
        lineColor: _this.options.lineColor,
        lineStyle: _this.options.lineStyle,
        lineWidth: _this.options.lineWidth,
        fillColor: _this.options.fillColor,
        fillOpacity: _this.options.fillOpacity,
        markers: _this.options.markers
      };

      return _this;
    }

    /**
     *  Sets the data of the bar serie
     *  @param {Object} data
     *  @example serie.setData( { "cat1": val1, "cat2": val2, "cat4": val4 } );
     *  @return {SerieBar} The current serie instance
     */


    _createClass(SerieBar, [{
      key: 'setData',
      value: function setData(data) {

        this.data = data;
        this.minY = Number.MAX_SAFE_INTEGER;
        this.maxY = Number.MIN_SAFE_INTEGER;

        for (var i in this.data) {
          this._checkY(this.data[i]);
        }

        return this;
      }
    }, {
      key: 'setFillColor',
      value: function setFillColor(fillColor, selectionType, applyToSelected) {

        selectionType = selectionType || 'unselected';
        this.styles[selectionType] = this.styles[selectionType] || {};
        this.styles[selectionType].fillColor = fillColor;

        if (applyToSelected) {
          this.setFillColor(fillColor, 'selected');
        }

        this.styleHasChanged(selectionType);

        return this;
      }
    }, {
      key: 'getFillColor',
      value: function getFillColor(selectionType) {
        return this.getStyle(selectionType).fillColor;
      }
    }, {
      key: 'setFillOpacity',
      value: function setFillOpacity(opacity, selectionType, applyToSelected) {

        selectionType = selectionType || 'unselected';
        this.styles[selectionType] = this.styles[selectionType] || {};
        this.styles[selectionType].fillOpacity = opacity;

        if (applyToSelected) {
          this.setLineWidth(opacity, 'selected');
        }

        this.styleHasChanged(selectionType);

        return this;
      }
    }, {
      key: 'getFillOpacity',
      value: function getFillOpacity(selectionType) {

        return this.getStyle(selectionType).fillOpacity || 1;
      }
    }, {
      key: 'applyLineStyles',
      value: function applyLineStyles() {
        this.applyLineStyle(this.pathDom);
      }
    }, {
      key: 'applyLineStyle',
      value: function applyLineStyle(line) {

        line.setAttribute('stroke', this.getLineColor());
        line.setAttribute('stroke-width', this.getLineWidth());
        if (this.getLineDashArray()) {
          line.setAttribute('stroke-dasharray', this.getLineDashArray());
        } else {
          line.removeAttribute('stroke-dasharray');
        }
        line.setAttribute('fill', this.getFillColor());
        line.setAttribute('fill-opacity', this.getFillOpacity() || 1);
      }
    }, {
      key: 'draw',
      value: function draw() {

        var path = '';
        var categoryNumber, position;

        if (this.error) {
          this.errorDrawInit();
        }

        for (var i in this.data) {

          if (!this.categoryIndices[i]) {
            continue;
          }

          path += 'M ' + this.getXAxis().getPos(this.categoryIndices[i]) + ' ' + this.getYAxis().getPos(0) + ' V ' + this.getYAxis().getPos(this.data[i]) + ' h ' + this.getXAxis().getDeltaPx(1 / this.nbCategories) + ' V ' + this.getYAxis().getPos(0);

          if (this.error) {
            this.errorAddPointBarChart(i, this.data[i], this.getXAxis().getPos(this.categoryIndices[i] + 0.5 / this.nbCategories), this.getYAxis().getPos(this.data[i]));
          }
        }

        if (this.error) {
          this.errorDraw();
        }

        this.pathDom.setAttribute('d', path);
        this.applyLineStyles();
      }
    }, {
      key: 'setMarkers',
      value: function setMarkers() {}
    }, {
      key: 'getUsedCategories',
      value: function getUsedCategories() {
        return Object.keys(this.data);
      }
    }]);

    return SerieBar;
  }(_graphSerieLine2.default);

  exports.default = SerieBar;
  module.exports = exports['default'];
});

/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(5), __webpack_require__(57)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('../graph.util.js'), require('./graph.serie.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphUtil, global.graphSerie);
    global.graphSerieBox = mod.exports;
  }
})(this, function (module, exports, _graphUtil, _graphSerie) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _graphSerie2 = _interopRequireDefault(_graphSerie);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var SerieBox = function (_Serie) {
    _inherits(SerieBox, _Serie);

    _createClass(SerieBox, null, [{
      key: 'default',
      value: function _default() {
        return {
          orientation: 'y',
          maxBoxWidth: 20,

          defaultStyle: {

            meanLineColor: 'rgb( 100, 0, 0 )',
            meanLineWidth: 2,

            boxAboveLineWidth: 1,
            boxAboveLineColor: 'rgb( 0, 0, 0 )',
            boxAboveFillColor: 'transparent',
            boxAboveFillOpacity: 1,
            boxBelowLineWidth: 1,
            boxBelowLineColor: 'rgb( 0, 0, 0 )',
            boxBelowFillColor: 'transparent',
            boxBelowFillOpacity: 1,

            barAboveLineColor: 'rgba( 0, 0, 0, 1 )',
            barAboveLineWidth: 1,
            barBelowLineColor: 'rgba( 0, 0, 0, 1 )',
            barBelowLineWidth: 1,

            outlierLineWidth: 1,
            outlierLineColor: 'rgb( 255, 255, 255 )',
            outlierFillColor: 'rgb( 0, 0, 0 )',
            outlierFillOpacity: 1
          }
        };
      }
    }]);

    function SerieBox(graph, name, options) {
      _classCallCheck(this, SerieBox);

      var _this = _possibleConstructorReturn(this, (SerieBox.__proto__ || Object.getPrototypeOf(SerieBox)).apply(this, arguments));

      _this.groupMain = document.createElementNS(_this.graph.ns, 'g');

      _this.pathDom = document.createElementNS(_this.graph.ns, 'path');
      _this.groupMain.appendChild(_this.pathDom);

      // Creates an empty style variable
      _this.styles = {};

      // Unselected style
      _this.styles.unselected = _this.options.defaultStyle;

      return _this;
    }

    /**
     *  Sets the data of the bar serie
     *  @param {Object} data
     *  @example serie.setData( [ { x: 'cat', Q2: valMean, Q1: valBoxMin, Q3: valBoxMax, whiskers: [ val1, val2 ], outliers: [ ...yList ] } ] );
     *  @return {SerieBar} The current serie instance
     */


    _createClass(SerieBox, [{
      key: 'setData',
      value: function setData(data, noRescale) {

        this.data = data;

        if (!Array.isArray(data)) {
          return;
        }

        var axisref = void 0,
            axisval = void 0,
            methodref = void 0,
            methodval = void 0,
            blnX = void 0;

        if (this.options.orientation == 'y') {
          axisref = this.getXAxis();
          axisval = this.getYAxis();
          methodref = this._checkX.bind(this);
          methodval = this._checkY.bind(this);
          blnX = true;

          this.minY = data[0].Q2;
          this.maxY = data[0].Q2;
          this.maxX = data[0].x;
          this.minX = data[0].x;
        } else {
          axisref = this.getYAxis();
          axisval = this.getXAxis();
          methodref = this._checkY.bind(this);
          methodval = this._checkX.bind(this);
          blnX = false;

          this.minX = data[0].Q2;
          this.maxX = data[0].Q2;
          this.maxY = data[0].y;
          this.minY = data[0].y;
        }

        if (noRescale) {
          methodref = function methodref() {};
          methodval = function methodval() {};
        }

        if (!axisref || !axisval) {
          (0, _graphUtil.throwError)('Error in setting data of the box serie. The X and Y axes must be set beforehand');
        }

        for (var i in this.data) {

          if (blnX) {
            methodref(this.data[i].x);
            this.data[i].pos = this.data[i].x;
          } else {
            methodref(this.data[i].y);
            this.data[i].pos = this.data[i].y;
          }

          if (this.data[i].Q3) {

            methodval(this.data[i].Q3);
          }

          if (this.data[i].Q1) {
            methodval(this.data[i].Q1);
          }

          if (this.data[i].whiskers) {

            if (Array.isArray(this.data[i].whiskers)) {

              if (this.data[i].whiskers.length > 0) {
                methodval(this.data[i].whiskers[0]);
              }

              if (this.data[i].whiskers.length > 1) {
                methodval(this.data[i].whiskers[1]);
              }
            } else {
              methodval(this.data[i].whiskers);
              this.data[i].whiskers = [this.data[i].whiskers];
            }
          } else {
            this.data[i].whiskers = [];
          }

          if (Array.isArray(this.data[i].outliers)) {
            this.data[i].outliers.map(function (val) {
              return methodval(val);
            });
          } else {
            this.data[i].outliers = [];
          }
        }

        this.dataHasChanged();
        this.graph.updateDataMinMaxAxes();

        return this;
      }
    }, {
      key: '_style',
      value: function _style(type, styleValue) {
        var selectionType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'unselected';
        var applyToSelected = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

        this.styles[selectionType] = this.styles[selectionType] || {};
        this.styles[selectionType][type] = styleValue;

        if (applyToSelected) {
          this._set(type, styleValue, 'selected');
        }

        this.styleHasChanged(selectionType);
        return this;
      }
    }, {
      key: '_gstyle',
      value: function _gstyle(type, selectionType) {
        return this.getStyle(selectionType)[type];
      }
    }, {
      key: 'getStyle',
      value: function getStyle() {
        var selectionType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'unselected';


        return this.styles[selectionType] || {};
      }
    }, {
      key: 'setMeanLineColor',
      value: function setMeanLineColor() {
        return this._style.apply(this, ['meanLineColor'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'getMeanLineColor',
      value: function getMeanLineColor() {
        return this._gstyle.apply(this, ['meanLineColor'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'setStyle',
      value: function setStyle(style) {
        var selectionType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'unselected';

        //console.log( style, selectionType );
        this.styles[selectionType] = (0, _graphUtil.extend)({}, this.default().defaultStyle, this.styles.unselected, style);
        this.styleHasChanged(selectionType);
      }
    }, {
      key: 'setMeanLineWidth',
      value: function setMeanLineWidth() {
        return this._style.apply(this, ['meanLineWidth'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'getMeanLineWidth',
      value: function getMeanLineWidth() {
        return this._gstyle.apply(this, ['meanLineWidth'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'setBoxAboveLineColor',
      value: function setBoxAboveLineColor() {
        return this._style.apply(this, ['boxAboveLineColor'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'getBoxAboveLineColor',
      value: function getBoxAboveLineColor() {
        return this._gstyle.apply(this, ['boxAboveLineColor'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'setBoxBelowLineColor',
      value: function setBoxBelowLineColor() {
        return this._style.apply(this, ['boxBelowLineColor'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'getBoxBelowLineColor',
      value: function getBoxBelowLineColor() {
        return this._gstyle.apply(this, ['boxBelowLineColor'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'setBoxAboveLineWidth',
      value: function setBoxAboveLineWidth() {
        return this._style.apply(this, ['boxAboveLineWidth'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'getBoxAboveLineWidth',
      value: function getBoxAboveLineWidth() {
        return this._gstyle.apply(this, ['boxAboveLineWidth'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'setBoxBelowLineWidth',
      value: function setBoxBelowLineWidth() {
        return this._style.apply(this, ['boxBelowLineWidth'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'getBoxBelowLineWidth',
      value: function getBoxBelowLineWidth() {
        return this._gstyle.apply(this, ['boxBelowLineWidth'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'setBoxAboveFillColor',
      value: function setBoxAboveFillColor() {
        return this._style.apply(this, ['boxAboveFillColor'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'getBoxAboveFillColor',
      value: function getBoxAboveFillColor() {
        return this._gstyle.apply(this, ['boxAboveFillColor'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'setBoxBelowFillColor',
      value: function setBoxBelowFillColor() {
        return this._style.apply(this, ['boxBelowFillColor'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'getBoxBelowFillColor',
      value: function getBoxBelowFillColor() {
        return this._gstyle.apply(this, ['boxBelowFillColor'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'setBoxAboveFillOpacity',
      value: function setBoxAboveFillOpacity() {
        return this._style.apply(this, ['boxAboveFillOpacity'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'getBoxAboveFillOpacity',
      value: function getBoxAboveFillOpacity() {
        return this._gstyle.apply(this, ['boxAboveFillOpacity'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'setBoxBelowFillOpacity',
      value: function setBoxBelowFillOpacity() {
        return this._style.apply(this, ['boxBelowFillOpacity'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'getBoxBelowFillOpacity',
      value: function getBoxBelowFillOpacity() {
        return this._gstyle.apply(this, ['boxBelowFillOpacity'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'setBarAboveLineColor',
      value: function setBarAboveLineColor() {
        return this._style.apply(this, ['barAboveLineColor'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'getBarAboveLineColor',
      value: function getBarAboveLineColor() {
        return this._gstyle.apply(this, ['barAboveLineColor'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'setBarBelowLineColor',
      value: function setBarBelowLineColor() {
        return this._style.apply(this, ['barBelowLineColor'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'getBarBelowLineColor',
      value: function getBarBelowLineColor() {
        return this._gstyle.apply(this, ['barBelowLineColor'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'setBarAboveLineWidth',
      value: function setBarAboveLineWidth() {
        return this._style.apply(this, ['barAboveLineWidth'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'getBarAboveLineWidth',
      value: function getBarAboveLineWidth() {
        return this._gstyle.apply(this, ['barAboveLineWidth'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'setBarBelowLineWidth',
      value: function setBarBelowLineWidth() {
        return this._style.apply(this, ['barBelowLineWidth'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'getBarBelowLineWidth',
      value: function getBarBelowLineWidth() {
        return this._gstyle.apply(this, ['barBelowLineWidth'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'setOutlierLineColor',
      value: function setOutlierLineColor() {
        return this._style.apply(this, ['outlierLineColor'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'getOutlierLineColor',
      value: function getOutlierLineColor() {
        return this._gstyle.apply(this, ['outlierLineColor'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'setOutlierLineWidth',
      value: function setOutlierLineWidth() {
        return this._style.apply(this, ['outlierLineWidth'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'getOutlierLineWidth',
      value: function getOutlierLineWidth() {
        return this._gstyle.apply(this, ['outlierLineWidth'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'setOutlierFillColor',
      value: function setOutlierFillColor() {
        return this._style.apply(this, ['outlierFillColor'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'getOutlierFillColor',
      value: function getOutlierFillColor() {
        return this._gstyle.apply(this, ['outlierFillColor'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'setOutlierFillOpacity',
      value: function setOutlierFillOpacity() {
        return this._style.apply(this, ['outlierFillOpacity'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'getOutlierFillOpacity',
      value: function getOutlierFillOpacity() {
        return this._gstyle.apply(this, ['outlierFillOpacity'].concat(Array.prototype.slice.call(arguments)));
      }
    }, {
      key: 'applyLineStyles',
      value: function applyLineStyles() {
        this.applyLineStyle(this.pathDom);
      }
    }, {
      key: 'applyLineStyle',
      value: function applyLineStyle(line) {

        line.setAttribute('stroke', this.getLineColor());
        line.setAttribute('stroke-width', this.getLineWidth());
        line.removeAttribute('stroke-dasharray');
        line.setAttribute('fill', this.getFillColor());
        line.setAttribute('fill-opacity', this.getFillOpacity() || 1);
      }
    }, {
      key: 'draw',
      value: function draw() {
        var _this2 = this;

        if (!this.data) {
          return;
        }

        var position = void 0;
        var axis = this.options.orientation == 'y' ? this.getYAxis() : this.getXAxis();
        var axis2 = this.options.orientation == 'y' ? this.getXAxis() : this.getYAxis();
        var boxOtherDimension = void 0; // width or height of the box
        var useCategories = false;
        var mean = void 0,
            boxAbove = void 0,
            boxBelow = void 0,
            barAbove = void 0,
            barBelow = void 0,
            outliers = void 0,
            posAbove = void 0,
            posBelow = void 0;
        var categoryNumber = void 0;

        (0, _graphUtil.emptyDom)(this.groupMain);

        if (axis2.getType() == 'category') {

          boxOtherDimension = axis2.getRelPx(0.8 / this.nbCategories);
          useCategories = true;
        } else {
          // Get all the spacing and determine the smallest one
          boxOtherDimension = this.options.maxBoxWidth;
          console.log(boxOtherDimension);
          for (var i = 0, l = this.data.length; i < l - 1; i++) {

            //     console.log( Math.abs( axis.getPx( this.data[ i + 1 ].pos ) - axis.getPx( this.data[ i ].pos ) ), axis.getPx( this.data[ i + 1 ].pos ), axis.getPx( this.data[ i ].pos ) );
            boxOtherDimension = Math.max(5, Math.min(boxOtherDimension, Math.abs(axis2.getPx(this.data[i + 1].pos) - axis2.getPx(this.data[i].pos))));
          }
        }

        for (var i = 0, l = this.data.length; i < l; i++) {

          if (axis2.getType() == 'category') {

            var cat = this.options.orientation == 'y' ? this.data[i].x : this.data[i].y;

            if (!this.categoryIndices.hasOwnProperty(cat)) {

              if (Array.isArray(this._linkedToScatterSeries)) {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                  for (var _iterator = this._linkedToScatterSeries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var scatter_serie = _step.value;


                    if (scatter_serie.categoryIndices.hasOwnProperty(cat)) {

                      position = [axis2.getPos(scatter_serie.categoryIndices[cat]) + 1.2 * boxOtherDimension / 2];

                      if (this.options.orientation == 'y') {
                        axis = scatter_serie.getYAxis();
                      } else {
                        axis = scatter_serie.getXAxis();
                      }

                      break;
                    }
                  }
                } catch (err) {
                  _didIteratorError = true;
                  _iteratorError = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                      _iterator.return();
                    }
                  } finally {
                    if (_didIteratorError) {
                      throw _iteratorError;
                    }
                  }
                }
              }
            } else {

              position = [axis2.getPos(this.categoryIndices[cat]) + 1.2 * boxOtherDimension / 2];
            }
          } else {

            position = [axis2.getPos(this.options.orientation == 'y' ? this.data[i].x : this.data[i].y), boxOtherDimension];
          }

          mean = axis.getPos(this.data[i].Q2);
          boxAbove = axis.getPos(this.data[i].Q3);
          boxBelow = axis.getPos(this.data[i].Q1);

          this.data[i].whiskers.map(function (val) {

            if (val < _this2.data[i].Q1) {
              barBelow = axis.getPos(val);
            } else {
              barAbove = axis.getPos(val);
            }
          });

          outliers = this.data[i].outliers.map(function (val) {
            return axis.getPos(val);
          });

          var lineMean = document.createElementNS(this.graph.ns, 'line');

          this.applyMeanStyle(lineMean);

          var rectAbove = document.createElementNS(this.graph.ns, 'rect');
          var rectBelow = document.createElementNS(this.graph.ns, 'rect');

          if (this.options.orientation == 'y') {

            rectAbove.setAttribute('width', boxOtherDimension);
            rectAbove.setAttribute('x', position[0] - boxOtherDimension / 2);

            rectBelow.setAttribute('width', boxOtherDimension);
            rectBelow.setAttribute('x', position[0] - boxOtherDimension / 2);

            lineMean.setAttribute('x1', position[0] - boxOtherDimension / 2);
            lineMean.setAttribute('x2', position[0] + boxOtherDimension / 2);
            lineMean.setAttribute('y1', mean);
            lineMean.setAttribute('y2', mean);
          } else {

            rectAbove.setAttribute('height', boxOtherDimension);
            rectAbove.setAttribute('y', position[0] - boxOtherDimension / 2);

            rectBelow.setAttribute('height', boxOtherDimension);
            rectBelow.setAttribute('y', position[0] - boxOtherDimension / 2);

            lineMean.setAttribute('y1', position[0] - boxOtherDimension / 2);
            lineMean.setAttribute('y2', position[0] + boxOtherDimension / 2);
            lineMean.setAttribute('x1', mean);
            lineMean.setAttribute('x2', mean);
          }

          this.boxPos(rectAbove, mean, boxAbove, this.options.orientation == 'x');
          this.boxPos(rectBelow, mean, boxBelow, this.options.orientation == 'x');

          this.applyBoxStyle(rectAbove, rectBelow);

          var whiskerAbove = document.createElementNS(this.graph.ns, 'line');
          var whiskerBelow = document.createElementNS(this.graph.ns, 'line');

          if (this.options.orientation == 'y') {

            if (barAbove !== undefined) {
              whiskerAbove.setAttribute('y1', boxAbove);
              whiskerAbove.setAttribute('y2', barAbove);
              whiskerAbove.setAttribute('x1', position[0]);
              whiskerAbove.setAttribute('x2', position[0]);
            }

            if (barBelow !== undefined) {
              whiskerBelow.setAttribute('y1', boxBelow);
              whiskerBelow.setAttribute('y2', barBelow);
              whiskerBelow.setAttribute('x1', position[0]);
              whiskerBelow.setAttribute('x2', position[0]);
            }
          } else {

            if (barAbove !== undefined) {
              whiskerAbove.setAttribute('x1', boxAbove);
              whiskerAbove.setAttribute('x2', barAbove);
              whiskerAbove.setAttribute('y1', position[0]);
              whiskerAbove.setAttribute('y2', position[0]);
            }

            if (barBelow !== undefined) {
              whiskerBelow.setAttribute('x1', boxBelow);
              whiskerBelow.setAttribute('x2', barBelow);
              whiskerBelow.setAttribute('y1', position[0]);
              whiskerBelow.setAttribute('y2', position[0]);
            }
          }

          outliers.map(function (outliervalue) {

            var outlier = document.createElementNS(_this2.graph.ns, 'circle');

            outlier.setAttribute('r', 2);

            if (_this2.options.orientation == 'y') {

              outlier.setAttribute('cx', position[0]);
              outlier.setAttribute('cy', outliervalue);
            } else {

              outlier.setAttribute('cy', position[0]);
              outlier.setAttribute('cx', outliervalue);
            }

            _this2.setOutlierStyle(outlier);

            _this2.groupMain.appendChild(outlier);
          });

          if (barAbove !== undefined) {
            this.groupMain.appendChild(whiskerAbove);
          }

          if (barBelow !== undefined) {
            this.groupMain.appendChild(whiskerBelow);
          }

          if (boxAbove !== undefined) {
            this.groupMain.appendChild(rectAbove);
          }

          if (boxBelow !== undefined) {
            this.groupMain.appendChild(rectBelow);
          }

          this.groupMain.appendChild(lineMean);

          this.applyWhiskerStyle(whiskerAbove, whiskerBelow);
        }
      }
    }, {
      key: 'applyBoxStyle',
      value: function applyBoxStyle(above, below) {

        above.setAttribute('stroke', this.getBoxAboveLineColor());
        above.setAttribute('stroke-width', this.getBoxAboveLineWidth());

        if (this.getBoxAboveFillColor() !== undefined) {
          above.setAttribute('fill', this.getBoxAboveFillColor());
        }
        if (this.getBoxAboveFillOpacity() !== undefined) {
          above.setAttribute('fill-opacity', this.getBoxAboveFillOpacity());
        }

        below.setAttribute('stroke', this.getBoxBelowLineColor());
        below.setAttribute('stroke-width', this.getBoxBelowLineWidth());

        if (this.getBoxBelowFillColor() !== undefined) {
          below.setAttribute('fill', this.getBoxBelowFillColor());
        }
        if (this.getBoxAboveFillOpacity() !== undefined) {
          below.setAttribute('fill-opacity', this.getBoxBelowFillOpacity());
        }
      }
    }, {
      key: 'applyWhiskerStyle',
      value: function applyWhiskerStyle(above, below) {

        above.setAttribute('stroke', this.getBarAboveLineColor());
        above.setAttribute('stroke-width', this.getBarAboveLineWidth());

        below.setAttribute('stroke', this.getBarBelowLineColor());
        below.setAttribute('stroke-width', this.getBarBelowLineWidth());
      }
    }, {
      key: 'applyMeanStyle',
      value: function applyMeanStyle(line) {

        line.setAttribute('stroke', this.getMeanLineColor());
        line.setAttribute('stroke-width', this.getMeanLineWidth());
      }
    }, {
      key: 'setOutlierStyle',
      value: function setOutlierStyle(outlier) {

        outlier.setAttribute('stroke', this.getOutlierLineColor());
        outlier.setAttribute('stroke-width', this.getOutlierLineWidth());

        if (this.getBoxBelowFillColor() !== undefined) {
          outlier.setAttribute('fill', this.getOutlierFillColor());
        }
        if (this.getBoxAboveFillOpacity() !== undefined) {
          outlier.setAttribute('fill-opacity', this.getOutlierFillOpacity());
        }
      }
    }, {
      key: 'getCategoryIndex',
      value: function getCategoryIndex(name) {

        if (!this.categories) {
          throw new Error('No categories were defined. Probably axis.setSeries was not called');
        }

        for (var i = 0; i < this.categories.length; i++) {

          if (this.categories[i].name == name) {
            return i;
          }
        }

        return false;
      }
    }, {
      key: 'setMarkers',
      value: function setMarkers() {}
    }, {
      key: 'boxPos',
      value: function boxPos(box, mean, extremity, blnX) {

        if (mean > extremity) {

          box.setAttribute(blnX ? 'x' : 'y', extremity);
          box.setAttribute(blnX ? 'width' : 'height', mean - extremity);
        } else {

          box.setAttribute(blnX ? 'x' : 'y', mean);
          box.setAttribute(blnX ? 'width' : 'height', extremity - mean);
        }
      }
    }, {
      key: 'getUsedCategories',
      value: function getUsedCategories() {
        var xymode = this.options.orientation == 'y' ? 'x' : 'y';

        var categories = this.data.map(function (d) {
          return d[xymode];
        });

        if (Array.isArray(this._linkedToScatterSeries)) {
          this._linkedToScatterSeries.map(function (scatter_serie) {

            scatter_serie.getUsedCategories().map(function (scatter_serie_cat) {
              var index = void 0;
              if ((index = categories.indexOf(scatter_serie_cat)) > -1) {
                categories.splice(index, 1);
              }
            });
          });
        }

        return categories;
      }
    }, {
      key: 'linkToScatterSerie',
      value: function linkToScatterSerie() {
        for (var _len = arguments.length, series = Array(_len), _key = 0; _key < _len; _key++) {
          series[_key] = arguments[_key];
        }

        this._linkedToScatterSeries = series;
      }
    }]);

    return SerieBox;
  }(_graphSerie2.default);

  exports.default = SerieBox;
  module.exports = exports['default'];
});

/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(5), __webpack_require__(74), __webpack_require__(51)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('../graph.util.js'), require('../mixins/graph.mixin.errorbars.js'), require('./graph.serie.line.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphUtil, global.graphMixinErrorbars, global.graphSerieLine);
    global.graphSerieLineColored = mod.exports;
  }
})(this, function (module, exports, _graphUtil, _graphMixinErrorbars, _graphSerieLine) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var util = _interopRequireWildcard(_graphUtil);

  var _graphMixinErrorbars2 = _interopRequireDefault(_graphMixinErrorbars);

  var _graphSerieLine2 = _interopRequireDefault(_graphSerieLine);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var SerieLineColor = function (_SerieLine) {
    _inherits(SerieLineColor, _SerieLine);

    function SerieLineColor(graph, name, options) {
      _classCallCheck(this, SerieLineColor);

      var _this = _possibleConstructorReturn(this, (SerieLineColor.__proto__ || Object.getPrototypeOf(SerieLineColor)).apply(this, arguments));

      _this.lines = _this.lines || {};
      return _this;
    }

    _createClass(SerieLineColor, [{
      key: 'setColors',
      value: function setColors(colors) {
        this.colors = colors;
      }
    }, {
      key: '_draw',
      value: function _draw() {

        var self = this,
            data = this._dataToUse,
            toBreak,
            i = 0,
            j,
            k,
            m,
            x,
            y,
            k,
            o,
            lastX = false,
            lastY = false,
            xpx,
            ypx,
            xpx2,
            ypx2,
            xAxis = this.getXAxis(),
            yAxis = this.getYAxis(),
            xMin = xAxis.getCurrentMin(),
            yMin = yAxis.getCurrentMin(),
            xMax = xAxis.getCurrentMax(),
            yMax = yAxis.getCurrentMax();

        // Y crossing
        var yLeftCrossingRatio, yLeftCrossing, yRightCrossingRatio, yRightCrossing, xTopCrossingRatio, xTopCrossing, xBottomCrossingRatio, xBottomCrossing;

        var incrXFlip = 0;
        var incrYFlip = 1;

        var pointOutside = false;
        var lastPointOutside = false;
        var pointOnAxis;

        this.eraseLines();

        if (this.isFlipped()) {
          incrXFlip = 1;
          incrYFlip = 0;
        }

        this.currentLine = '';
        m = this.waveform.getLength();

        for (j = 0; j < m; j += 2) {

          x = this.waveform.getX(j);
          y = this.waveform.getY(j);

          if (x < xMin && lastX < xMin || x > xMax && lastX > xMax || (y < yMin && lastY < yMin || y > yMax && lastY > yMax) && !this.options.lineToZero) {
            lastX = x;
            lastY = y;
            lastPointOutside = true;
            continue;
          }

          this.counter2 = j;

          if (this.markersShown()) {
            this.getMarkerCurrentFamily(this.counter2);
          }

          xpx2 = this.getX(x);
          ypx2 = this.getY(y);

          if (xpx2 == xpx && ypx2 == ypx) {
            continue;
          }

          pointOutside = x < xMin || y < yMin || x > xMax || y > yMax;
          /*
                  if ( this.options.lineToZero ) {
                    pointOutside = ( x < xMin || x > xMax );
                     if ( pointOutside ) {
                      continue;
                    }
                  } else {
                     if ( pointOutside || lastPointOutside ) {
                       if ( ( lastX === false || lastY === false ) && !lastPointOutside ) {
                         xpx = xpx2;
                        ypx = ypx2;
                        lastX = x;
                        lastY = y;
                       } else {
                         pointOnAxis = [];
                        // Y crossing
                        yLeftCrossingRatio = ( x - xMin ) / ( x - lastX );
                        yLeftCrossing = y - yLeftCrossingRatio * ( y - lastY );
                        yRightCrossingRatio = ( x - xMax ) / ( x - lastX );
                        yRightCrossing = y - yRightCrossingRatio * ( y - lastY );
                         // X crossing
                        xTopCrossingRatio = ( y - yMin ) / ( y - lastY );
                        xTopCrossing = x - xTopCrossingRatio * ( x - lastX );
                        xBottomCrossingRatio = ( y - yMax ) / ( y - lastY );
                        xBottomCrossing = x - xBottomCrossingRatio * ( x - lastX );
                         if ( yLeftCrossingRatio < 1 && yLeftCrossingRatio > 0 && yLeftCrossing !== false && yLeftCrossing < yMax && yLeftCrossing > yMin ) {
                          pointOnAxis.push( [ xMin, yLeftCrossing ] );
                        }
                         if ( yRightCrossingRatio < 1 && yRightCrossingRatio > 0 && yRightCrossing !== false && yRightCrossing < yMax && yRightCrossing > yMin ) {
                          pointOnAxis.push( [ xMax, yRightCrossing ] );
                        }
                         if ( xTopCrossingRatio < 1 && xTopCrossingRatio > 0 && xTopCrossing !== false && xTopCrossing < xMax && xTopCrossing > xMin ) {
                          pointOnAxis.push( [ xTopCrossing, yMin ] );
                        }
                         if ( xBottomCrossingRatio < 1 && xBottomCrossingRatio > 0 && xBottomCrossing !== false && xBottomCrossing < xMax && xBottomCrossing > xMin ) {
                          pointOnAxis.push( [ xBottomCrossing, yMax ] );
                        }
                         if ( pointOnAxis.length > 0 ) {
                           if ( !pointOutside ) { // We were outside and now go inside
                             if ( pointOnAxis.length > 1 ) {
                              console.error( "Programmation error. Please e-mail me." );
                              console.log( pointOnAxis, xBottomCrossing, xTopCrossing, yRightCrossing, yLeftCrossing, y, yMin, yMax, lastY );
                            }
                             this._createLine();
                            this._addPoint( this.getX( pointOnAxis[ 0 ][ 0 ] ), this.getY( pointOnAxis[ 0 ][ 1 ] ), pointOnAxis[ 0 ][ 0 ], pointOnAxis[ 0 ][ 1 ], false, false, false );
                            this._addPoint( xpx2, ypx2, lastX, lastY, false, false, true );
                           } else if ( !lastPointOutside ) { // We were inside and now go outside
                             if ( pointOnAxis.length > 1 ) {
                              console.error( "Programmation error. Please e-mail me." );
                              console.log( pointOnAxis, xBottomCrossing, xTopCrossing, yRightCrossing, yLeftCrossing, y, yMin, yMax, lastY );
                            }
                             this._addPoint( this.getX( pointOnAxis[ 0 ][ 0 ] ), this.getY( pointOnAxis[ 0 ][ 1 ] ), pointOnAxis[ 0 ][ 0 ], pointOnAxis[ 0 ][ 1 ], false, false, false );
                           } else {
                             // No crossing: do nothing
                            if ( pointOnAxis.length == 2 ) {
                              this._createLine();
                               this._addPoint( this.getX( pointOnAxis[ 0 ][ 0 ] ), this.getY( pointOnAxis[ 0 ][ 1 ] ), pointOnAxis[ 0 ][ 0 ], pointOnAxis[ 0 ][ 1 ], false, false, false );
                              this._addPoint( this.getX( pointOnAxis[ 1 ][ 0 ] ), this.getY( pointOnAxis[ 1 ][ 1 ] ), pointOnAxis[ 0 ][ 0 ], pointOnAxis[ 0 ][ 1 ], false, false, false );
                            }
                           }
                        } else if ( !pointOutside ) {
                          this._addPoint( xpx2, ypx2, lastX, lastY, j, false, false );
                        }
                      }
                       xpx = xpx2;
                      ypx = ypx2;
                      lastX = x;
                      lastY = y;
                       lastPointOutside = pointOutside;
                       continue;
                    }
                   }*/

          if (isNaN(xpx2) || isNaN(ypx2)) {
            if (this.counter > 0) {

              //      this._createLine();
            }
            continue;
          }

          var color = this.colors[j];

          this._addPoint(xpx2, ypx2, x, y, xpx, ypx, lastX, lastY, j, color, false, true);

          xpx = xpx2;
          ypx = ypx2;

          lastX = x;
          lastY = y;
        }

        this.latchLines();

        if (this._tracker) {

          if (this._trackerDom) {
            this._trackerDom.remove();
          }

          var cloned = this.groupLines.cloneNode(true);
          this.groupMain.appendChild(cloned);

          for (var i = 0, l = cloned.children.length; i < l; i++) {

            cloned.children[i].setAttribute('stroke', 'transparent');
            cloned.children[i].setAttribute('stroke-width', '25px');
            cloned.children[i].setAttribute('pointer-events', 'stroke');
          }

          self._trackerDom = cloned;

          self.groupMain.addEventListener('mousemove', function (e) {
            var coords = self.graph._getXY(e),
                ret = self.handleMouseMove(false, false);
            self._trackingCallback(self, ret, coords.x, coords.y);
          });

          self.groupMain.addEventListener('mouseleave', function (e) {
            self._trackingOutCallback(self);
          });
        }
        return this;
      }
    }, {
      key: '_addPoint',
      value: function _addPoint(xpx, ypx, x, y, xpxbefore, ypxbefore, xbefore, ybefore, j, color, move, allowMarker) {

        if (xpxbefore === undefined || ypxbefore === undefined) {
          return;
        }

        if (isNaN(xpx) || isNaN(ypx)) {
          return;
        }

        if (color._rgb) {
          color = 'rgba(' + color._rgb[0] + ',' + color._rgb[1] + ',' + color._rgb[2] + ',' + (color._rgb[3] || 1) + ')';
        }

        var line = this.lines[color];
        if (!line) {
          line = this.lines[color] = {
            object: document.createElementNS(this.graph.ns, 'path'),
            path: '',
            color: color
          };
          line.object.setAttribute('stroke', color);
          line.color = color;
          //      this.applyLineStyle( line );
          this.groupLines.appendChild(line.object);
        }

        line.path += 'M ' + xpxbefore + ' ' + ypxbefore + ' L ' + xpx + ' ' + ypx;

        if (this.hasErrors()) {
          this.errorAddPoint(j, x, y, xpx, ypx);
        }

        /*if ( this.markersShown() && allowMarker !== false ) {
          drawMarkerXY( this, this.markerFamilies[ this.selectionType ][ this.markerCurrentFamily ], xpx, ypx );
        }*/
      }
    }, {
      key: 'removeExtraLines',
      value: function removeExtraLines() {}
    }, {
      key: 'latchLines',
      value: function latchLines() {

        for (var i in this.lines) {
          this.lines[i].object.setAttribute('d', this.lines[i].path);
        }
      }
    }, {
      key: 'eraseLines',
      value: function eraseLines() {

        for (var i in this.lines) {
          this.lines[i].path = '';
          this.lines[i].object.setAttribute('d', '');
        }
      }
    }, {
      key: 'applyLineStyle',
      value: function applyLineStyle(line) {

        //line.setAttribute( 'stroke', this.getLineColor() );
        line.setAttribute('stroke-width', this.getLineWidth());
        if (this.getLineDashArray()) {
          line.setAttribute('stroke-dasharray', this.getLineDashArray());
        } else {
          line.removeAttribute('stroke-dasharray');
        }
        line.setAttribute('fill', 'none');
        //	line.setAttribute('shape-rendering', 'optimizeSpeed');
      }
    }]);

    return SerieLineColor;
  }(_graphSerieLine2.default);

  exports.default = SerieLineColor;
  module.exports = exports['default'];
});

/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(45), __webpack_require__(46), __webpack_require__(140), __webpack_require__(5), __webpack_require__(142)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('../graph.core.js'), require('../util/waveform.js'), require('../mixins/graph.mixin.serie3d.js'), require('../graph.util.js'), require('./graph.serie.zone.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphCore, global.waveform, global.graphMixinSerie3d, global.graphUtil, global.graphSerieZone);
    global.graphSerieZone3d = mod.exports;
  }
})(this, function (module, exports, _graphCore, _waveform, _graphMixinSerie3d, _graphUtil, _graphSerieZone) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _graphCore2 = _interopRequireDefault(_graphCore);

  var _waveform2 = _interopRequireDefault(_waveform);

  var _graphMixinSerie3d2 = _interopRequireDefault(_graphMixinSerie3d);

  var util = _interopRequireWildcard(_graphUtil);

  var _graphSerieZone2 = _interopRequireDefault(_graphSerieZone);

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var SerieZone3D = function (_Serie) {
    _inherits(SerieZone3D, _Serie);

    _createClass(SerieZone3D, null, [{
      key: 'default',
      value: function _default() {
        return {
          zpos: 0
        };
      }
    }]);

    function SerieZone3D(graph, name, options) {
      _classCallCheck(this, SerieZone3D);

      return _possibleConstructorReturn(this, (SerieZone3D.__proto__ || Object.getPrototypeOf(SerieZone3D)).apply(this, arguments));
    }

    /**
     * Sets the z-position
     * @memberof SerieZone3D
     * @param {Number} zPos - The position in the z axis
     */


    _createClass(SerieZone3D, [{
      key: 'setZPos',
      value: function setZPos(zPos) {
        this.options.zpos = zPos;
        return this;
      }
    }, {
      key: 'setz',
      value: function setz() {
        return this.setZPos.apply(this, arguments);
      }
    }]);

    return SerieZone3D;
  }(_graphSerieZone2.default);

  util.mix(SerieZone3D, _graphMixinSerie3d2.default);
  exports.default = SerieZone3D;
  module.exports = exports['default'];
});

/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(5), __webpack_require__(57)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('../graph.util.js'), require('./graph.serie.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphUtil, global.graphSerie);
    global.graphSerieDensitymap = mod.exports;
  }
})(this, function (module, exports, _graphUtil, _graphSerie) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var util = _interopRequireWildcard(_graphUtil);

  var _graphSerie2 = _interopRequireDefault(_graphSerie);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var SerieDensityMap = function (_Serie) {
    _inherits(SerieDensityMap, _Serie);

    function SerieDensityMap(graph, name, options) {
      _classCallCheck(this, SerieDensityMap);

      var _this = _possibleConstructorReturn(this, (SerieDensityMap.__proto__ || Object.getPrototypeOf(SerieDensityMap)).apply(this, arguments));

      util.mapEventEmission(_this.options, _this); // Register events

      _this.groupMain = document.createElementNS(_this.graph.ns, 'g');

      _this.rects = [];
      _this.paths = [];

      _this.recalculateBinsOnDraw = false;
      return _this;
    }
    /**
     * Sets the data of the serie. Careful, only one format allowed for now.
     * @memberof SerieDensityMap
     * @param {Array} data - A vector containing 2-elements arrays
     * @return {SerieDensityMap} The current instance
     * @example serie.setData( [ [ x1, y1 ], [ x2, y2 ], ..., [ xn, yn ] ] );
     */


    _createClass(SerieDensityMap, [{
      key: 'setData',
      value: function setData(data) {

        this.minX = this.maxX = this.minY = this.maxY = 0;
        var i = 0,
            l = data.length;
        this.data = data;

        this.minX = Number.POSITIVE_INFINITY;
        this.minY = Number.POSITIVE_INFINITY;
        this.maxX = Number.NEGATIVE_INFINITY;
        this.maxY = Number.NEGATIVE_INFINITY;

        for (i = 0; i < l; i++) {
          this._checkX(data[i][0]);
          this._checkY(data[i][1]);
        }

        this.dataHasChanged();
        this.graph.updateDataMinMaxAxes();

        return this;
      }
    }, {
      key: 'calculateDensity',
      value: function calculateDensity(fromX, deltaX, numX, fromY, deltaY, numY) {

        var densitymap = [],
            i,
            l = this.data.length,
            indexX,
            indexY;

        var binMin = Number.POSITIVE_INFINITY;
        var binMax = Number.NEGATIVE_INFINITY;

        for (i = 0; i < l; i++) {
          indexX = ~~((this.data[i][0] - fromX) / deltaX);
          indexY = ~~((this.data[i][1] - fromY) / deltaY);

          if (indexX > numX || indexY > numY || indexX < 0 || indexY < 0) {
            continue;
          }

          densitymap[indexX] = densitymap[indexX] || [];
          densitymap[indexX][indexY] = densitymap[indexX][indexY] + 1 || 1;

          binMin = densitymap[indexX][indexY] < binMin ? densitymap[indexX][indexY] : binMin;
          binMax = densitymap[indexX][indexY] > binMax ? densitymap[indexX][indexY] : binMax;
          //binMax = Math.max( binMax, densitymap[ indexX ][ indexY ] );
        }

        this.maxIndexX = numX;
        this.maxIndexY = numY;

        this.binMin = binMin;
        this.binMax = binMax;

        this.deltaX = deltaX;
        this.deltaY = deltaY;

        this.fromX = fromX;
        this.fromY = fromY;

        this.numX = numX;
        this.numY = numY;

        this.densitymap = densitymap;
        return densitymap;
      }
    }, {
      key: 'setDensityMap',
      value: function setDensityMap(densitymap, fromX, deltaX, fromY, deltaY) {

        var i, j, indexX, indexY;

        var binMin = Number.POSITIVE_INFINITY;
        var binMax = Number.NEGATIVE_INFINITY;

        for (i = 0; i < densitymap.length; i++) {

          for (j = 0; j < densitymap[i].length; j++) {
            binMin = densitymap[i][j] < binMin ? densitymap[i][j] : binMin;
            binMax = densitymap[i][j] > binMax ? densitymap[i][j] : binMax;
          }
          //binMax = Math.max( binMax, densitymap[ indexX ][ indexY ] );
        }

        this.maxIndexX = densitymap.length;
        this.maxIndexY = densitymap[0].length;
        console.log(densitymap);
        this.binMin = binMin;
        this.binMax = binMax;

        this.deltaX = deltaX;
        this.deltaY = deltaY;

        this.fromX = fromX;
        this.fromY = fromY;

        this.numX = this.maxIndexX;
        this.numY = this.maxIndexY;

        this.densitymap = densitymap;
        return densitymap;
      }
    }, {
      key: 'calculateDensityWeighted',
      value: function calculateDensityWeighted(fromX, deltaX, numX, fromY, deltaY, numY) {

        var densitymap = [],
            i,
            l = this.data.length,
            indexX,
            indexY;

        var binMin = Number.POSITIVE_INFINITY;
        var binMax = Number.NEGATIVE_INFINITY;

        var compX, compY;
        var exactX, exactY;
        var indexXLow, indexXHigh, indexYLow, indexYHigh;

        for (i = 0; i < l; i++) {
          exactX = (this.data[i][0] - fromX) / deltaX - 0.5;
          exactY = (this.data[i][1] - fromY) / deltaY - 0.5;

          indexX = Math.floor(exactX);
          indexY = Math.floor(exactY);

          indexXLow = indexX; //Math.floor( exactX );
          indexYLow = indexY; //Math.floor( exactY );

          indexXHigh = indexX + 1; //Math.ceil( exactX );
          indexYHigh = indexY + 1; //Math.ceil( exactY );

          compX = 1 - (exactX - indexX);
          compY = 1 - (exactY - indexY);

          //console.log( exactY, indexY );
          //console.log( compY, indexYLow, indexYHigh );
          if (indexX > numX || indexY > numY || indexX < 0 || indexY < 0) {
            continue;
          }

          densitymap[indexXLow] = densitymap[indexXLow] || [];
          densitymap[indexXHigh] = densitymap[indexXHigh] || [];

          densitymap[indexXLow][indexYLow] = densitymap[indexXLow][indexYLow] || 0;
          densitymap[indexXHigh][indexYLow] = densitymap[indexXHigh][indexYLow] || 0;
          densitymap[indexXLow][indexYHigh] = densitymap[indexXLow][indexYHigh] || 0;
          densitymap[indexXHigh][indexYHigh] = densitymap[indexXHigh][indexYHigh] || 0;

          densitymap[indexXLow][indexYLow] += compX * compY;
          densitymap[indexXHigh][indexYLow] += (1 - compX) * compY;
          densitymap[indexXLow][indexYHigh] += compX * (1 - compY);
          densitymap[indexXHigh][indexYHigh] += (1 - compX) * (1 - compY);

          // A loop would be nicer, but would it be faster ?
          binMin = densitymap[indexXLow][indexYLow] < binMin ? densitymap[indexXLow][indexYLow] : binMin;
          binMax = densitymap[indexXLow][indexYLow] > binMax ? densitymap[indexXLow][indexYLow] : binMax;
          binMin = densitymap[indexXHigh][indexYLow] < binMin ? densitymap[indexXHigh][indexYLow] : binMin;
          binMax = densitymap[indexXHigh][indexYLow] > binMax ? densitymap[indexXHigh][indexYLow] : binMax;
          binMin = densitymap[indexXLow][indexYHigh] < binMin ? densitymap[indexXLow][indexYHigh] : binMin;
          binMax = densitymap[indexXLow][indexYHigh] > binMax ? densitymap[indexXLow][indexYHigh] : binMax;
          binMin = densitymap[indexXHigh][indexYHigh] < binMin ? densitymap[indexXHigh][indexYHigh] : binMin;
          binMax = densitymap[indexXHigh][indexYHigh] > binMax ? densitymap[indexXHigh][indexYHigh] : binMax;

          //binMax = Math.max( binMax, densitymap[ indexX ][ indexY ] );
        }

        this.maxIndexX = numX;
        this.maxIndexY = numY;

        this.binMin = binMin;
        this.binMax = binMax;

        this.deltaX = deltaX;
        this.deltaY = deltaY;

        this.fromX = fromX;
        this.fromY = fromY;

        this.numX = numX;
        this.numY = numY;

        this.densitymap = densitymap;
        return densitymap;
      }
    }, {
      key: 'autoBins',
      value: function autoBins(numX, numY) {

        this.numX = numX || 400;
        this.numY = numY || this.numX;

        this.calculateDensity(this.minX, (this.maxX - this.minX) / numX, numX, this.minY, (this.maxY - this.minY) / numY, numY);

        this.recalculateBinsOnDraw = false;

        return this;
      }
    }, {
      key: 'setPxPerBin',
      value: function setPxPerBin(pxPerBinX, pxPerBinY, weightedDensityMap) {

        if (pxPerBinX) {
          this.calculationDensityMap({
            from: 'min',
            to: 'max',
            pxPerBin: pxPerBinX,
            weighted: weightedDensityMap
          });
        }

        if (pxPerBinY) {
          this.calculationDensityMap(false, {
            from: 'min',
            to: 'max',
            pxPerBin: pxPerBinY,
            weighted: weightedDensityMap
          });
        }

        return this;
      }
    }, {
      key: 'setBinsFromTo',
      value: function setBinsFromTo(mode, from, to, num) {

        this.densityMapCalculation = this.densityMapCalculation || {};

        this.densityMapCalculation[mode] = {
          from: from,
          to: to,
          numBins: num
        };
        this.calculationDensityMap();
        return this;
      }
    }, {
      key: 'calculationDensityMap',
      value: function calculationDensityMap(x, y) {

        this.method = this.calculateDensityAdvanced;
        this.densityMapCalculation = this.densityMapCalculation || {};

        if (x) {
          this.densityMapCalculation.x = x;
        }

        if (y) {
          this.densityMapCalculation.y = y;
        }
      }
    }, {
      key: 'calculateDensityAdvanced',
      value: function calculateDensityAdvanced() {

        var results = {
          x: {
            from: 0,
            num: 0,
            delta: 0,
            weighing: false
          },

          y: {
            from: 0,
            num: 0,
            delta: 0,
            weighing: false
          }
        };

        var widthValues = {
          x: this.graph.drawingSpaceWidth,
          y: this.graph.drawingSpaceHeight
        };
        var axisGetter = {
          x: this.getXAxis,
          y: this.getYAxis
        };

        var weighing = false;

        for (var i in this.densityMapCalculation) {

          if (this.densityMapCalculation[i].weighted) {
            weighing = true;
            results[i].weighing = true;
          }

          if (this.densityMapCalculation[i].pxPerBin) {

            // In value

            var from = this.densityMapCalculation[i].from == 'min' ? axisGetter[i].call(this).getCurrentMin() : this.densityMapCalculation[i].from;
            var to = this.densityMapCalculation[i].to == 'max' ? axisGetter[i].call(this).getCurrentMax() : this.densityMapCalculation[i].to;

            // In px
            var dimension = Math.abs(axisGetter[i].call(this).getRelPx(to - from));
            results[i].num = Math.ceil(widthValues[i] / this.densityMapCalculation[i].pxPerBin);

            //console.log( from, from - axisGetter[ i ].call( this ).getRelVal( ( results[i ].num * this.densityMapCalculation[ i ].pxPerBin - dimension ) / 2 ), ( results[i ].num * this.densityMapCalculation[ i ].pxPerBin - dimension ) / 2 );
            results[i].from = from - Math.abs(axisGetter[i].call(this).getRelVal((results[i].num * this.densityMapCalculation[i].pxPerBin - dimension) / 2));
            results[i].delta = Math.abs(axisGetter[i].call(this).getRelVal(this.densityMapCalculation[i].pxPerBin));
          } else {

            results[i].num = this.densityMapCalculation[i].numBins || 400;
            results[i].from = this.densityMapCalculation[i].from == 'min' ? axisGetter[i].call(this).getCurrentMin() : this.densityMapCalculation[i].from;
            results[i].delta = this.densityMapCalculation[i].to ? ((this.densityMapCalculation[i].to == 'max' ? axisGetter[i].call(this).getCurrentMax() : this.densityMapCalculation[i].to) - results[i].from) / results[i].num : this.densityMapCalculate[i].delta;
          }

          //      console.log( axisGetter[ i ].call( this ).getCurrentMin(), axisGetter[ i ].call( this ).getCurrentMax(), )
        }
        //console.log( this.getYAxis().getCurrentMin(), this.getYAxis().getCurrentMax(), this.graph.drawingSpaceHeight );

        //console.log( this.densityMapCalculation );

        (weighing ? this.calculateDensityWeighted : this.calculateDensity).call(this, results.x.from, results.x.delta, results.x.num, results.y.from, results.y.delta, results.y.num);
      }
    }, {
      key: 'setColorMapBinBoundaries',
      value: function setColorMapBinBoundaries(min, max, _internal) {
        this.colorMapMin = min;
        this.colorMapMax = max;

        if (!_internal) {
          // If the method is called externally, the bins must be fixed and not automatically scaled when the draw method is invoked.
          this.callbackColorMapMinMax = 'manual';
        }

        return this;
      }
    }, {
      key: 'autoColorMapBinBoundaries',
      value: function autoColorMapBinBoundaries() {
        this.colorMapMin = this.binMin;
        this.colorMapMax = this.binMax;
        return this;
      }
    }, {
      key: 'onRedrawColorMapBinBoundaries',
      value: function onRedrawColorMapBinBoundaries(callback) {
        this.callbackColorMapMinMax = callback;
        return this;
      }
    }, {
      key: 'colorMapHSL',
      value: function colorMapHSL(colorStops, numColors, method) {

        method = method || 'linear';

        var methods = {
          'exp': function exp(value) {
            return (Math.exp(value / numColors * 1) - Math.exp(0)) / (Math.exp(1) - Math.exp(0));
          },
          'log': function log(value) {
            return (Math.log(value + 1) - Math.log(1)) / (Math.log(numColors + 1) - Math.log(1));
          },
          'linear': function linear(value) {
            return (value - 0) / (numColors - 0);
          }
        };

        var k = 0,
            colorMap = [],
            opacities = [];

        var color = {
          h: null,
          s: null,
          l: null,
          a: null
        };

        var ratio, first;

        var slices = colorStops.length - 1;

        for (var i = 0; i <= numColors; i++) {

          ratio = methods[method](i);

          first = Math.floor(ratio * slices);

          if (first == colorStops.length - 1) {
            // Handle 1
            first = slices - 1;
          }

          ratio = (ratio - first / slices) / (1 / slices);

          for (var j in color) {
            color[j] = (colorStops[first + 1][j] - colorStops[first][j]) * ratio + colorStops[first][j];
          }

          colorMap[k] = 'hsl(' + color.h + ', ' + Math.round(color.s * 100) + '%, ' + Math.round(color.l * 100) + '%)'; //this.HSVtoRGB( color.h, color.s, color.v );
          opacities[k] = color.a;
          k++;
        }

        this.opacities = opacities;
        this.colorMap = colorMap;
        this.colorMapNum = numColors;

        return this;
      }
    }, {
      key: 'autoColorMapHSL',
      value: function autoColorMapHSL(colorStops) {
        var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'linear';

        this.colorMapHSL(colorStops, 100, method);
        return this;
      }
    }, {
      key: 'getColorIndex',
      value: function getColorIndex(binValue) {

        return Math.max(0, Math.min(this.colorMapNum, Math.floor((binValue - this.colorMapMin) / (this.colorMapMax - this.colorMapMin) * this.colorMapNum)));
      }
    }, {
      key: 'draw',
      value: function draw() {

        var colorIndex;

        if (this.method) {
          this.method();
        }

        if (!this.callbackColorMapMinMax || this.colorMapMin == undefined || this.colorMapMax == undefined || this.callbackColorMapMinMax == 'auto') {

          this.autoColorMapBinBoundaries();
        } else if (typeof this.callbackColorMapMinMax == 'function') {

          var val = this.callbackColorMapMinMax(this.binMin, this.binMax);
          this.setColorMapBinBoundaries(val[0], val[1], true);
        }

        var deltaXPx = this.getXAxis().getRelPx(this.deltaX),
            deltaYPx = this.getYAxis().getRelPx(this.deltaY);

        for (var i = 0; i < this.paths.length; i++) {
          this.paths[i] = '';
        }

        console.log(this.maxIndexX, this.maxIndexY);

        for (var i = 0; i < this.maxIndexX; i++) {

          for (var j = 0; j < this.maxIndexY; j++) {

            if (this.densitymap[i] == undefined || this.densitymap[i][j] == undefined) {
              continue;
            }

            colorIndex = this.getColorIndex(this.densitymap[i][j]);
            if (!this.paths[colorIndex]) {
              this.paths[colorIndex] = '';
            }

            this.paths[colorIndex] += ' M ' + this.getXAxis().getPx(i * this.deltaX + this.fromX) + ' ' + this.getYAxis().getPx(j * this.deltaY + this.fromY) + ' h ' + deltaXPx + ' v ' + deltaYPx + ' h -' + deltaXPx + ' z';
          }
        }
        /*
            this.maxIndexX = indexX;
            this.maxIndexY = indexY;*/

        this.drawRects();
      }
    }, {
      key: 'drawRects',
      value: function drawRects() {

        for (var i = 0; i < this.paths.length; i++) {

          if (!this.rects[i]) {
            this.rects[i] = document.createElementNS(this.graph.ns, 'path');
            this.rects[i].setAttribute('shape-rendering', 'crispEdges');
          }

          if (this.paths[i] !== undefined) {
            this.rects[i].setAttribute('d', this.paths[i]);
            this.rects[i].setAttribute('fill', this.colorMap[i]);
            this.rects[i].setAttribute('fill-opacity', this.opacities[i]);
          }
          this.groupMain.appendChild(this.rects[i]);
        }
      }
    }, {
      key: 'setOptions',
      value: function setOptions(options) {
        this.options = util.extend(true, {}, this.defaults(), options || {});
        // Unselected style

        return this;
      }
    }]);

    return SerieDensityMap;
  }(_graphSerie2.default);

  exports.default = SerieDensityMap;
  module.exports = exports['default'];
});

/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(5), __webpack_require__(51)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('../graph.util.js'), require('./graph.serie.line.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphUtil, global.graphSerieLine);
    global.graphSerieContour = mod.exports;
  }
})(this, function (module, exports, _graphUtil, _graphSerieLine) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var util = _interopRequireWildcard(_graphUtil);

  var _graphSerieLine2 = _interopRequireDefault(_graphSerieLine);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var SerieContour = function (_SerieLine) {
    _inherits(SerieContour, _SerieLine);

    function SerieContour(graph, name, options) {
      _classCallCheck(this, SerieContour);

      var _this = _possibleConstructorReturn(this, (SerieContour.__proto__ || Object.getPrototypeOf(SerieContour)).apply(this, arguments));

      _this.negativeDelta = 0;
      _this.positiveDelta = 0;

      _this.negativeThreshold = 0;
      _this.positiveThreshold = 0;

      _this.groupMain.setAttribute('clip-path', 'url(#_clipplot' + graph._creation + ')');
      return _this;
    }

    /**
     * Sets the contour lines
     * @memberof SerieContour.prototype
     * @param {Object} data - The object data
     * @param {Number} data.minX - The minimum x value
     * @param {Number} data.maxX - The maximum x value
     * @param {Number} data.minY - The minimum y value
     * @param {Number} data.maxY - The maximum y value
     * @param {Object[]} data.segments - The segments making up the contour lines
     * @param {Number[]} data.segments.lines - An array of alternating (x1,y1,x2,y2) quadruplet
     * @param {Number} data.segments.zValue - The corresponding z-value of this array
     * @return {Serie} The current serie
     */


    _createClass(SerieContour, [{
      key: 'setData',
      value: function setData(data, arg, type) {

        var z = 0;
        var x,
            dx,
            arg = arg || '2D',
            type = type || 'float',
            i,
            l = data.length,
            j,
            k,
            arr,
            datas = [];

        if (!(data instanceof Array)) {

          if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) == 'object') {
            // Def v2
            this.minX = data.minX;
            this.minY = data.minY;
            this.maxX = data.maxX;
            this.maxY = data.maxY;

            data = data.segments;
            l = data.length;
          }
        }

        for (i = 0; i < l; i++) {
          k = data[i].lines.length;
          arr = this._addData(type, k);

          for (j = 0; j < k; j += 2) {

            arr[j] = data[i].lines[j];
            this._checkX(arr[j]);
            arr[j + 1] = data[i].lines[j + 1];
            this._checkY(arr[j + 1]);
          }

          datas.push({
            lines: arr,
            zValue: data[i].zValue
          });
        }
        this.data = datas;
        this.graph.updateDataMinMaxAxes();

        this.dataHasChanged(true);

        return this;
      }
    }, {
      key: 'draw',
      value: function draw(force) {

        if (force || this.hasDataChanged()) {

          this.currentLine = 0;
          var x,
              y,
              xpx,
              ypx,
              xpx2,
              ypx2,
              i = 0,
              l = this.data.length,
              j = 0,
              k,
              m,
              currentLine,
              domLine,
              arr;
          this.minZ = Infinity;
          this.maxZ = -Infinity;

          var next = this.groupLines.nextSibling;
          this.groupMain.removeChild(this.groupLines);
          this.zValues = {};

          var incrXFlip = 0;
          var incrYFlip = 1;
          if (this.getFlip()) {
            incrXFlip = 0;
            incrYFlip = 1;
          }

          var minY = this.getYAxis().getCurrentMin();
          var minX = this.getXAxis().getCurrentMin();

          var maxX = this.getXAxis().getCurrentMax();
          var maxY = this.getYAxis().getCurrentMax();

          this.counter = 0;
          this.currentLineId = 0;

          for (; i < l; i++) {
            this.currentLine = '';
            j = 0;
            k = 0;

            for (arr = this.data[i].lines, m = arr.length; j < m; j += 4) {

              var lastxpx, lastypx;

              if (arr[j + incrXFlip] < minX && arr[j + 2 + incrXFlip] < minX || arr[j + incrYFlip] < minY && arr[j + 2 + incrYFlip] < minY || arr[j + incrYFlip] > maxY && arr[j + 2 + incrYFlip] > maxY || arr[j + incrXFlip] > maxX && arr[j + 2 + incrXFlip] > maxX) {
                continue;
              }

              xpx2 = this.getX(arr[j + incrXFlip]);
              ypx2 = this.getY(arr[j + incrYFlip]);

              xpx = this.getX(arr[j + 2 + incrXFlip]);
              ypx = this.getY(arr[j + 2 + incrYFlip]);

              if (xpx == xpx2 && ypx == ypx2) {
                continue;
              }

              /*	if( j > 0 && ( lastxpx !== undefined && lastypx !== undefined && Math.abs( xpx2 - lastxpx ) <= 30 && Math.abs( ypx2 - lastypx ) <= 30 ) ) {
              currentLine += "L";
              } else {
              currentLine += "M";
              }
              */

              this.currentLine += 'M ';
              this.currentLine += xpx2;
              this.currentLine += ' ';
              this.currentLine += ypx2;

              this.currentLine += 'L ';
              this.currentLine += xpx;
              this.currentLine += ' ';
              this.currentLine += ypx;

              this.counter++;

              lastxpx = xpx;
              lastypx = ypx;

              k++;
            }

            this.currentLine += ' z';

            domLine = this._createLine();
            domLine.setAttribute('data-zvalue', this.data[i].zValue);

            this.zValues[this.data[i].zValue] = {
              dom: domLine
            };

            this.minZ = Math.min(this.minZ, this.data[i].zValue);
            this.maxZ = Math.max(this.maxZ, this.data[i].zValue);
          }

          i++;

          for (i = this.currentLine + 1; i < this.lines.length; i++) {
            this.groupLines.removeChild(this.lines[i]);
            this.lines.splice(i, 1);
          }

          i = 0;

          for (; i < l; i++) {
            this.setColorTo(this.lines[i], this.data[i].zValue, this.minZ, this.maxZ);
          }

          this.onMouseWheel(0, {
            shiftKey: false
          });
          this.groupMain.insertBefore(this.groupLines, next);
        } else if (this.hasStyleChanged(this.selectionType)) {

          for (; i < l; i++) {
            this.setColorTo(this.lines[i], this.data[i].zValue, this.minZ, this.maxZ);
          }
        }
      }
    }, {
      key: 'onMouseWheel',
      value: function onMouseWheel(delta, e, fixed, positive) {

        delta /= 250;

        if (fixed !== undefined) {

          if (!positive) {
            this.negativeThreshold = -fixed * this.minZ;
            this.negativeDelta = -Math.pow(Math.abs(this.negativeThreshold / -this.minZ), 1 / 3);
          }

          if (positive) {
            this.positiveThreshold = fixed * this.maxZ;
            this.positiveDelta = Math.pow(this.positiveThreshold / this.maxZ, 1 / 3);
          }
        } else {

          if (!e.shiftKey || !this.options.hasNegative) {

            this.positiveDelta = Math.min(1, Math.max(0, this.positiveDelta + Math.min(0.1, Math.max(-0.1, delta))));
            this.positiveThreshold = this.maxZ * Math.pow(this.positiveDelta, 3);
          } else {

            this.negativeDelta = Math.min(0, Math.max(-1, this.negativeDelta + Math.min(0.1, Math.max(-0.1, delta))));
            this.negativeThreshold = -this.minZ * Math.pow(this.negativeDelta, 3);
          }
        }

        if (isNaN(this.positiveDelta)) {
          this.positiveDelta = 0;
        }

        if (isNaN(this.negativeDelta)) {
          this.negativeDelta = 0;
        }

        for (var i in this.zValues) {

          this.zValues[i].dom.setAttribute('display', i >= 0 && i >= this.positiveThreshold || i <= 0 && i <= this.negativeThreshold ? 'block' : 'none');
        }

        if (this._shapeZoom) {

          if (!this.options.hasNegative) {
            this._shapeZoom.hideHandleNeg();
          } else {

            this._shapeZoom.setHandleNeg(-Math.pow(this.negativeDelta, 3), this.minZ);
            this._shapeZoom.showHandleNeg();
          }

          this._shapeZoom.setHandlePos(Math.pow(this.positiveDelta, 3), this.maxZ);
        }
      }
    }, {
      key: 'handleMouseMove',
      value: function handleMouseMove(xValue, doMarker, yValue) {

        var valX = xValue || this.getXAxis().getMouseVal(),
            valY = yValue || this.getYAxis().getMouseVal();

        return {
          trueX: valX,
          interpolatedY: valY,
          xClosest: valX,
          yClosest: valY
        };
      }
    }, {
      key: 'setDynamicColor',
      value: function setDynamicColor(colors) {
        this.lineColors = colors;

        this.styleHasChanged();
      }
    }, {
      key: 'setNegative',
      value: function setNegative(bln) {
        this.options.hasNegative = bln;

        if (bln) {
          this.negativeThreshold = 0;
        }
      }
    }, {
      key: 'setColorTo',
      value: function setColorTo(line, zValue, min, max) {

        if (!this.lineColors) {
          return;
        }

        var hsl = {
          h: 0,
          s: 0,
          l: 0
        };

        for (var i in hsl) {

          if (zValue > 0) {
            hsl[i] = this.lineColors.fromPositive[i] + (this.lineColors.toPositive[i] - this.lineColors.fromPositive[i]) * (zValue / max);
          } else {
            hsl[i] = this.lineColors.fromNegative[i] + (this.lineColors.toNegative[i] - this.lineColors.fromNegative[i]) * (zValue / min);
          }
        }

        hsl.h /= 360;

        var rgb = util.hslToRgb(hsl.h, hsl.s, hsl.l);

        line.setAttribute('stroke', 'rgb(' + rgb.join() + ')');
      }
    }, {
      key: 'getSymbolForLegend',
      value: function getSymbolForLegend() {

        if (!this.lineForLegend) {

          var line = document.createElementNS(this.graph.ns, 'ellipse');

          line.setAttribute('cx', 7);
          line.setAttribute('cy', 0);
          line.setAttribute('rx', 8);
          line.setAttribute('ry', 3);

          line.setAttribute('cursor', 'pointer');
          this.lineForLegend = line;
        }

        this.applyLineStyle(this.lineForLegend, this.maxZ);

        return this.lineForLegend;
      }
    }, {
      key: 'applyLineStyle',
      value: function applyLineStyle(line, overwriteValue) {
        line.setAttribute('stroke', this.getLineColor());
        line.setAttribute('stroke-width', this.getLineWidth() + (this.isSelected() ? 2 : 0));
        if (this.getLineDashArray()) {
          line.setAttribute('stroke-dasharray', this.getLineDashArray());
        }
        line.setAttribute('fill', 'none');

        this.setColorTo(line, overwriteValue !== undefined ? overwriteValue : line.getAttribute('data-zvalue'), this.minZ, this.maxZ);
        //  line.setAttribute('shape-rendering', 'optimizeSpeed');

        this.hasStyleChanged(false);
      }
    }, {
      key: 'setShapeZoom',
      value: function setShapeZoom(shape) {
        this._shapeZoom = shape;
      }
    }]);

    return SerieContour;
  }(_graphSerieLine2.default);

  exports.default = SerieContour;
  module.exports = exports['default'];
});

/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(28)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('./graph.shape.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphShape);
    global.graphShapeAreaundercurve = mod.exports;
  }
})(this, function (module, exports, _graphShape) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _graphShape2 = _interopRequireDefault(_graphShape);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var ShapeSurfaceUnderCurve = function (_Shape) {
    _inherits(ShapeSurfaceUnderCurve, _Shape);

    function ShapeSurfaceUnderCurve() {
      _classCallCheck(this, ShapeSurfaceUnderCurve);

      return _possibleConstructorReturn(this, (ShapeSurfaceUnderCurve.__proto__ || Object.getPrototypeOf(ShapeSurfaceUnderCurve)).apply(this, arguments));
    }

    _createClass(ShapeSurfaceUnderCurve, [{
      key: 'createDom',
      value: function createDom() {
        this._dom = document.createElementNS(this.graph.ns, 'path');
      }
    }, {
      key: 'createHandles',
      value: function createHandles() {

        this._createHandles(2, 'line', {
          'stroke-width': '3',
          'stroke': 'transparent',
          'pointer-events': 'stroke',
          'cursor': 'ew-resize'
        });
      }
    }, {
      key: 'handleMouseMoveImpl',
      value: function handleMouseMoveImpl(e, deltaX, deltaY) {

        if (this.isLocked()) {
          return;
        }

        if (this.moving) {

          this.getPosition(0).deltaPosition('x', deltaX, this.getXAxis());
          this.getPosition(1).deltaPosition('x', deltaX, this.getXAxis());
        } else if (this.serie && this.handleSelected) {

          this.resizingPosition = this.handleSelected == 1 ? this.getPosition(0) : this.getPosition(1);

          var value = this.serie.searchClosestValue(this.getXAxis().getVal(this.graph._getXY(e).x - this.graph.getPaddingLeft()));

          if (!value) {
            return;
          }

          if (this.resizingPosition.x != value.xMin) {
            this.preventUnselect = true;
          }

          this.resizingPosition.x = value.xMin;
        } else if (this.handleSelected) {

          this.resizingPosition = this.handleSelected == 1 ? this.getPosition(0) : this.getPosition(1);
          this.resizingPosition.deltaPosition('x', deltaX, this.getXAxis());
        }

        this.applyPosition();
      }
    }, {
      key: 'applyPosition',
      value: function applyPosition() {

        if (!this.serie) {
          return;
        }

        var posXY = this.computePosition(0),
            posXY2 = this.computePosition(1),
            w = Math.abs(posXY.x - posXY2.x),
            x = Math.min(posXY.x, posXY2.x);

        //  this.reversed = x == posXY2.x;

        if (w < 2 || x + w < 0 || x > this.graph.getDrawingWidth()) {
          this.setDom('d', '');
          return false;
        }

        var v1 = this.serie.searchClosestValue(this.getPosition(0).x),
            v2 = this.serie.searchClosestValue(this.getPosition(1).x),
            v3,
            i,
            j,
            init,
            max,
            k,
            x,
            y,
            firstX,
            firstY,
            currentLine,
            maxY = 0,
            minY = Number.MAX_VALUE;

        if (!v1 || !v2) {
          return false;
        }

        if (v1.xBeforeIndex > v2.xBeforeIndex) {
          v3 = v1;
          v1 = v2;
          v2 = v3;

          //this.handleSelected = ( this.handleSelected == 1 ) ? 2 : 1;
        }

        this.counter = 0;

        for (i = v1.dataIndex; i <= v2.dataIndex; i++) {
          this.currentLine = '';
          init = i == v1.dataIndex ? v1.xBeforeIndexArr : 0;
          max = i == v2.dataIndex ? v2.xBeforeIndexArr : this.serie.data[i].length;
          k = 0;

          if (init == max) {
            max++;
          }

          for (j = init; j <= max; j += 2) {

            x = this.serie.getX(this.serie.data[i][j + 0]);
            y = this.serie.getY(this.serie.data[i][j + 1]);

            maxY = Math.max(this.serie.data[i][j + 1], maxY);
            minY = Math.min(this.serie.data[i][j + 1], minY);

            if (j == init) {
              this.firstX = x;
              this.firstY = y;
            }

            if (k > 0) {
              this.currentLine += ' L ' + x + ' ' + y + ' ';
            } else {
              this.currentLine += ' M ' + x + ' ' + y + ' ';
            }

            //this.serie._addPoint( x, y, false, this.currentLine );
            k++;
          }

          this.lastX = x;
          this.lastY = y;

          if (!this.firstX || !this.firstY || !this.lastX || !this.lastY) {
            return;
          }

          this.currentLine += ' V ' + this.getYAxis().getPx(0) + ' H ' + this.firstX + ' z';
          this.setDom('d', this.currentLine);
        }

        this.maxY = this.serie.getY(maxY);
        this.setHandles();

        this.changed();

        return true;
      }
    }, {
      key: 'setHandles',
      value: function setHandles() {

        if (!this.firstX) {
          return;
        }

        var posXY = this.computePosition(0),
            posXY2 = this.computePosition(1);

        if (posXY.x < posXY2.x) {

          this.handles[1].setAttribute('x1', this.firstX);
          this.handles[1].setAttribute('x2', this.firstX);

          this.handles[2].setAttribute('x1', this.lastX);
          this.handles[2].setAttribute('x2', this.lastX);
        } else {

          this.handles[1].setAttribute('x1', this.lastX);
          this.handles[1].setAttribute('x2', this.lastX);

          this.handles[2].setAttribute('x1', this.firstX);
          this.handles[2].setAttribute('x2', this.firstX);
        }
        this.handles[1].setAttribute('y1', this.getYAxis().getMaxPx());
        this.handles[1].setAttribute('y2', this.serie.getY(0));

        this.handles[2].setAttribute('y1', this.getYAxis().getMaxPx());
        this.handles[2].setAttribute('y2', this.serie.getY(0));
      }
    }]);

    return ShapeSurfaceUnderCurve;
  }(_graphShape2.default);

  exports.default = ShapeSurfaceUnderCurve;
  module.exports = exports['default'];
});

/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(102)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('./graph.shape.line.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphShapeLine);
    global.graphShapeArrow = mod.exports;
  }
})(this, function (module, exports, _graphShapeLine) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _graphShapeLine2 = _interopRequireDefault(_graphShapeLine);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var ShapeArrow = function (_ShapeLine) {
    _inherits(ShapeArrow, _ShapeLine);

    function ShapeArrow(graph) {
      _classCallCheck(this, ShapeArrow);

      return _possibleConstructorReturn(this, (ShapeArrow.__proto__ || Object.getPrototypeOf(ShapeArrow)).call(this, graph));
    }

    _createClass(ShapeArrow, [{
      key: 'createDom',
      value: function createDom() {

        this._dom = document.createElementNS(this.graph.ns, 'line');
        this._dom.setAttribute('marker-end', 'url(#arrow' + this.graph._creation + ')');

        this.createHandles(this.nbHandles, 'rect', {
          transform: 'translate(-3 -3)',
          width: 6,
          height: 6,
          stroke: 'black',
          fill: 'white',
          cursor: 'nwse-resize'
        });

        this.setStrokeColor('black');
        this.setStrokeWidth(1);
      }
    }]);

    return ShapeArrow;
  }(_graphShapeLine2.default);

  exports.default = ShapeArrow;
  module.exports = exports['default'];
});

/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(28)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('./graph.shape.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphShape);
    global.graphShapeLabel = mod.exports;
  }
})(this, function (module, exports, _graphShape) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _graphShape2 = _interopRequireDefault(_graphShape);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var ShapeLabel = function (_GraphShape) {
    _inherits(ShapeLabel, _GraphShape);

    function ShapeLabel(graph, options) {
      _classCallCheck(this, ShapeLabel);

      return _possibleConstructorReturn(this, (ShapeLabel.__proto__ || Object.getPrototypeOf(ShapeLabel)).call(this, graph, options));
    }

    _createClass(ShapeLabel, [{
      key: 'createDom',
      value: function createDom() {
        return false;
      }
    }, {
      key: 'applyPosition',
      value: function applyPosition() {
        return true;
      }
    }]);

    return ShapeLabel;
  }(_graphShape2.default);

  exports.default = ShapeLabel;
  module.exports = exports['default'];
});

/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(28)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('./graph.shape.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphShape);
    global.graphShapePolyline = mod.exports;
  }
})(this, function (module, exports, _graphShape) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _graphShape2 = _interopRequireDefault(_graphShape);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var ShapePolyline = function (_Shape) {
    _inherits(ShapePolyline, _Shape);

    function ShapePolyline(graph, options) {
      _classCallCheck(this, ShapePolyline);

      return _possibleConstructorReturn(this, (ShapePolyline.__proto__ || Object.getPrototypeOf(ShapePolyline)).call(this, graph, options));
    }

    /**
     * Creates the DOM
     * @private
     * @return {Shape} The current shape
     */


    _createClass(ShapePolyline, [{
      key: 'createDom',
      value: function createDom() {

        this._dom = document.createElementNS(this.graph.ns, 'path');

        if (!this.getStrokeColor()) {
          this.setStrokeColor('black');
        }

        if (this.getStrokeWidth() == undefined) {
          this.setStrokeWidth(1);
        }
      }
    }, {
      key: 'createHandles',
      value: function createHandles() {}
    }, {
      key: 'setPointsPx',
      value: function setPointsPx(points) {
        this.setProp('pxPoints', points);
        return this;
      }
    }, {
      key: 'applyPosition',
      value: function applyPosition() {

        var pxPoints = void 0;
        var pos = this.computePosition(0);

        if (pxPoints = this.getProp('pxPoints')) {

          pxPoints = ' M ' + pos.x + ' ' + pos.y + ' ' + pxPoints;
          this.setDom('d', pxPoints);
        } else if (this.points) {

          var xAxis, yAxis;

          if (this.serie) {

            xAxis = this.serie.getXAxis();
            yAxis = this.serie.getYAxis();
          } else if (this.xAxis && this.yAxis) {

            xAxis = this.xAxis;
            yAxis = this.yAxis;
          }

          this.setDom('d', 'M ' + this.points.map(function (p) {
            return xAxis.getPx(p[0]) + ', ' + yAxis.getPx(p[1]);
          }).join(' L '));
        }

        this.changed();
        return true;
      }
    }]);

    return ShapePolyline;
  }(_graphShape2.default);

  exports.default = ShapePolyline;
  module.exports = exports['default'];
});

/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(55), __webpack_require__(28)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('../graph.position.js'), require('./graph.shape.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphPosition, global.graphShape);
    global.graphShapeNmrintegral = mod.exports;
  }
})(this, function (module, exports, _graphPosition, _graphShape) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _graphPosition2 = _interopRequireDefault(_graphPosition);

  var _graphShape2 = _interopRequireDefault(_graphShape);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var ShapeNMRIntegral = function (_Shape) {
    _inherits(ShapeNMRIntegral, _Shape);

    function ShapeNMRIntegral(graph, options) {
      _classCallCheck(this, ShapeNMRIntegral);

      var _this = _possibleConstructorReturn(this, (ShapeNMRIntegral.__proto__ || Object.getPrototypeOf(ShapeNMRIntegral)).call(this, graph, options));

      _this.nbHandles = 2;
      return _this;
    }

    _createClass(ShapeNMRIntegral, [{
      key: 'createDom',
      value: function createDom() {
        this._dom = document.createElementNS(this.graph.ns, 'path');
        this._domShadow = document.createElementNS(this.graph.ns, 'path');
        this._domShadow.jsGraphIsShape = this;
        this._dom.setAttribute('pointer-events', 'stroke');
        this._domShadow.setAttribute('pointer-events', 'stroke');
        this._domShadow.setAttribute('stroke-width', '12');
        this._domShadow.setAttribute('fill', 'transparent');
        this._domShadow.setAttribute('stroke', 'transparent');
        this.group.appendChild(this._domShadow);
      }
    }, {
      key: 'initImpl',
      value: function initImpl() {
        this.setFillColor('transparent');
        this.setStrokeColor('black');
      }
    }, {
      key: 'createHandles',
      value: function createHandles() {

        this._createHandles(2, 'rect', {
          transform: 'translate(-3 -3)',
          width: 6,
          height: 6,
          stroke: 'black',
          fill: 'white'
        });

        this.handles[1].setAttribute('fill', 'red');
      }
    }, {
      key: 'xor',
      value: function xor(a, b) {
        return a && !b || !a && b;
      }
    }, {
      key: 'applyPosition',
      value: function applyPosition() {

        var x = void 0,
            y = void 0,
            xVal = void 0,
            yVal = void 0,
            axis = this.getAxis(),
            points = [];

        var currentLine = '',
            baseLine = this.getProp('baseLine', 0) || 300,
            ratio = void 0;

        if (!this.serie) {
          throw 'No serie exists for this shape';
        }
        /*
            this.sortPositions( ( a, b ) => {
              return a.x - b.x;
            } );
             */
        var pos1 = this.getPosition(0);
        var pos2 = this.getPosition(1);

        if (pos1.x < this.serie.getXAxis().getCurrentMin() && pos2.x < this.serie.getXAxis().getCurrentMin() || pos1.x > this.serie.getXAxis().getCurrentMax() && pos2.x > this.serie.getXAxis().getCurrentMax()) {
          this.setDom('d', '');
          this._domShadow.setAttribute('d', '');

          this.hideLabel(0);
          return false;
        }

        this.showLabel(0);

        var sum = 0;

        var j = void 0;
        var waveform = this.serie.getWaveform();

        if (!waveform) {
          return;
        }

        var index1 = waveform.getIndexFromX(pos1[axis], true, Math.floor),
            index2 = waveform.getIndexFromX(pos2[axis], true, Math.ceil),
            index3 = void 0,
            flipped = false;

        if (index1 == index2) {
          // At least one px please !
          if (waveform.getReductionType() == 'aggregate') {
            index2 += 4; // Aggregated state
          } else {
            index2++; // Non aggregated state
          }
        }

        if (index2 < index1) {
          index3 = index1;
          index1 = index2;
          index2 = index3;
          flipped = true;
        }

        var firstX = void 0,
            firstY = void 0,
            firstXVal = void 0,
            firstYVal = void 0,
            lastX = void 0,
            lastXVal = void 0,
            lastY = void 0,
            lastYVal = void 0;
        var data = waveform.getDataInUse();

        var condition = void 0,
            incrementation = void 0;

        var normalSums = true;
        if (waveform.getReductionType() == 'aggregate') {
          normalSums = false;
        }

        if (waveform.getXMonotoneousAscending() && // Ascending
        1 == 1 || !waveform.getXMonotoneousAscending() && // Ascending
        1 == 2) {

          j = index2;
          condition = true;
          incrementation = -1;
        } else {

          j = index1;
          condition = false;
          incrementation = 1;
        }

        for (; condition ? j >= index1 : j <= index2; j += incrementation) {

          xVal = waveform.getX(j, true);
          yVal = waveform.getY(j, true);

          x = this.serie.getX(xVal);
          y = this.serie.getY(yVal);

          /*
                if ( ! normalSums && j % 4 == 0 && j >= index1 && data.sums ) { // Sums are located every 4 element
                   sum += data.sums[ j ];// * ( waveform.getX( j, true ) - waveform.getX( j - 3, true ) ); // y * (out-in)
                 } else if( normalSums ) {
          */
          sum += waveform.getY(j, true); // * ( waveform.getX( j, true ) - waveform.getX( j - 1, true ) ); // y * (out-in)
          //}

          if (!firstX) {

            firstX = x;
            firstY = y;
            firstXVal = waveform.getX(j);
            firstYVal = waveform.getY(j);
          }

          if (lastX == undefined) {

            lastX = x;
            lastY = y;
            lastXVal = waveform.getX(j);
            lastYVal = waveform.getY(j);
            continue;
          }

          if (x == lastX && y == lastY) {
            //continue;
          }

          lastX = x;
          lastY = y;
          //console.log( data, data[ j ] );

          points.push([x, y, sum]);
          lastXVal = xVal;
        }

        lastXVal = false;
        lastYVal = false;
        lastX = false;
        lastY = false;

        if (sum == 0) {
          sum = 1;
        }

        this._sumVal = waveform.integrate(pos1.x, pos2.x);

        if (!this.ratio) {
          // 150px / unit
          ratio = 200 / sum;
        } else {
          // Already existing
          ratio = this.ratio * (this.sumVal / sum);
        }
        var py = void 0;

        if (points.length == 0) {
          return;
        }

        for (var i = 0, l = points.length; i < l; i++) {

          py = baseLine - points[i][2] * ratio;

          if (i > 0 && (points[i - 1][2] > sum / 2 && points[i][2] <= sum / 2 || points[i - 1][2] < sum / 2 && points[i][2] >= sum / 2)) {

            var pos = baseLine - (points[i - 1][2] + points[i][2]) / 2 * ratio;

            this.setPosition({
              x: points[i][0] + 'px',
              y: pos + 'px'

            }, 3);

            this.setLabelPosition(this.getPosition(3), 0);
          }

          currentLine += ' L ' + points[i][0] + ', ' + py + ' ';

          this.lastPointX = points[i][0];
          this.lastPointY = py;
        }

        this.points = points;
        this._sum = sum;

        if (this.serie.isFlipped()) {
          currentLine = ' M ' + baseLine + ', ' + firstX + ' ' + currentLine;
        } else {
          currentLine = ' M ' + firstX + ', ' + baseLine + ' ' + currentLine;
        }

        this.firstPointX = firstX;
        this.firstPointY = baseLine;

        this.setDom('d', currentLine);
        this._domShadow.setAttribute('d', currentLine);

        this.firstX = firstX;
        this.firstY = firstY;
        /*
              if ( this._selected ) {
                this.select();
              }
               this.setHandles();*/

        this.serie.ratioLabel && this.updateIntegralValue(this.serie.ratioLabel) || this.updateLabels();

        this.changed();
        this.handleCondition = !this.xor(incrementation == -1, flipped);
        this.setHandles();

        this.updateIntegralValue();

        return true;
      }
    }, {
      key: 'updateIntegralValue',
      value: function updateIntegralValue() {
        var ratioLabel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.serie.ratioLabel;
        var forceValue = arguments[1];

        console.log(ratioLabel);
        if (ratioLabel) {
          this.serie.ratioLabel = ratioLabel;
        }

        if (!isNaN(forceValue) && !isNaN(this.sumVal) && this.sumVal) {
          this.serie.ratioLabel = forceValue / this.sumVal;
        }

        this.setLabelText(ratioLabel ? (Math.round(100 * this.sumVal * ratioLabel) / 100).toPrecision(3) : 'N/A', 0);
        this.updateLabels();
        return this.serie.ratioLabel;
      }
    }, {
      key: 'getAxis',
      value: function getAxis() {
        return this._data.axis || 'x';
      }
    }, {
      key: 'selectStyle',
      value: function selectStyle() {
        this.setDom('stroke-width', '2px');
      }
    }, {
      key: 'selectHandles',
      value: function selectHandles() {}
    }, {
      key: 'setHandles',
      value: function setHandles() {

        if (this.points == undefined) {
          return;
        }

        if (!this.isSelected()) {
          return;
        }

        this.addHandles();

        if (this.handleCondition) {

          this.handles[1].setAttribute('x', this.firstPointX);
          this.handles[1].setAttribute('y', this.firstPointY);
          this.handles[2].setAttribute('x', this.lastPointX);
          this.handles[2].setAttribute('y', this.lastPointY);
        } else {

          this.handles[2].setAttribute('x', this.firstPointX);
          this.handles[2].setAttribute('y', this.firstPointY);
          this.handles[1].setAttribute('x', this.lastPointX);
          this.handles[1].setAttribute('y', this.lastPointY);
        }
      }
    }, {
      key: 'handleMouseMoveImpl',
      value: function handleMouseMoveImpl(e, deltaX, deltaY, deltaXPx, deltaYPx) {

        if (this.isLocked()) {
          return;
        }

        var pos = this.getPosition(0);
        var pos2 = this.getPosition(1);

        var posToChange;

        if (this.handleSelected == 1) {

          posToChange = pos;
        } else if (this.handleSelected == 2) {

          posToChange = pos2;
        }

        if (posToChange) {

          if (!this._data.vertical) {
            posToChange.deltaPosition('x', deltaX, this.getXAxis());
          }
        }

        if (this.moving) {

          // If the pos2 is defined by a delta, no need to move them
          if (pos.x) {
            pos.deltaPosition('x', deltaX, this.getXAxis());
          }

          // If the pos2 is defined by a delta, no need to move them
          if (pos2.x) {
            pos2.deltaPosition('x', deltaX, this.getXAxis());
          }
        }

        if (this.rectEvent) {
          this.setEventReceptacle();
        }

        this.redraw();
        this.changed();

        return true;
      }
    }, {
      key: 'ratio',
      set: function set(r) {
        this._ratio = r;
      },
      get: function get() {
        return this._ratio;
      }
    }, {
      key: 'sum',
      get: function get() {
        return this._sum;
      }
    }, {
      key: 'sumVal',
      get: function get() {
        return this._sumVal;
      }
    }]);

    return ShapeNMRIntegral;
  }(_graphShape2.default);

  exports.default = ShapeNMRIntegral;
  module.exports = exports['default'];
});

/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(143)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('./graph.shape.rect.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphShapeRect);
    global.graphShapePeakintegration2d = mod.exports;
  }
})(this, function (module, exports, _graphShapeRect) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _graphShapeRect2 = _interopRequireDefault(_graphShapeRect);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var ShapePeakIntegration2D = function (_ShapeRect) {
    _inherits(ShapePeakIntegration2D, _ShapeRect);

    function ShapePeakIntegration2D(graph, options) {
      _classCallCheck(this, ShapePeakIntegration2D);

      var _this = _possibleConstructorReturn(this, (ShapePeakIntegration2D.__proto__ || Object.getPrototypeOf(ShapePeakIntegration2D)).call(this, graph, options));

      _this.nbHandles = 4;
      return _this;
    }

    _createClass(ShapePeakIntegration2D, [{
      key: 'createDom',
      value: function createDom() {

        this._dom = document.createElementNS(this.graph.ns, 'rect');
        this._dom.element = this;

        this.createHandles(this.nbHandles, 'rect', {
          transform: 'translate(-3 -3)',
          width: 6,
          height: 6,
          stroke: 'black',
          fill: 'white',
          cursor: 'nwse-resize'
        });
      }
    }, {
      key: 'redrawImpl',
      value: function redrawImpl() {

        this.setPosition();
        this.setHandles();
        this.setBindableToDom(this._dom);
      }
    }]);

    return ShapePeakIntegration2D;
  }(_graphShapeRect2.default);

  exports.default = ShapePeakIntegration2D;
  module.exports = exports['default'];
});

/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(28)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('./graph.shape.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphShape);
    global.graphShapeCross = mod.exports;
  }
})(this, function (module, exports, _graphShape) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _graphShape2 = _interopRequireDefault(_graphShape);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var ShapeCross = function (_Shape) {
    _inherits(ShapeCross, _Shape);

    function ShapeCross(graph, options) {
      _classCallCheck(this, ShapeCross);

      var _this = _possibleConstructorReturn(this, (ShapeCross.__proto__ || Object.getPrototypeOf(ShapeCross)).call(this, graph, options));

      _this.nbHandles = 1;
      return _this;
    }

    /**
     * Width of the cross, also available from the constructor
     * @type {Number} width
     */


    _createClass(ShapeCross, [{
      key: 'createDom',
      value: function createDom() {

        this._dom = document.createElementNS(this.graph.ns, 'path');
        this._dom.setAttribute('d', 'M -' + this.width / 2 + ' 0 h ' + this.width + ' m -' + this.width / 2 + ' -' + this.width / 2 + ' v ' + this.width);
      }
    }, {
      key: 'createHandles',
      value: function createHandles() {

        this._createHandles(this.nbHandles, 'rect', {
          transform: 'translate(-3 -3)',
          width: 6,
          height: 6,
          stroke: 'black',
          fill: 'white',
          cursor: 'nwse-resize'
        });
      }
    }, {
      key: 'applyPosition',
      value: function applyPosition() {

        var position = this.calculatePosition(0);
        if (!position || !position.x || !position.y) {
          return;
        }

        this.setDom('transform', 'translate( ' + position.x + ', ' + position.y + ')');

        this.currentPos1x = position.x;
        this.currentPos1y = position.y;

        return true;
      }
    }, {
      key: 'redrawImpl',
      value: function redrawImpl() {

        this.setHandles();
      }
    }, {
      key: 'handleCreateImpl',
      value: function handleCreateImpl() {}
    }, {
      key: 'handleMouseDownImpl',
      value: function handleMouseDownImpl(e) {

        this.moving = true;

        return true;
      }
    }, {
      key: 'handleMouseUpImpl',
      value: function handleMouseUpImpl() {

        this.triggerChange();
        return true;
      }
    }, {
      key: 'handleMouseMoveImpl',
      value: function handleMouseMoveImpl(e, deltaX, deltaY, deltaXPx, deltaYPx) {

        if (this.isLocked()) {
          return;
        }

        var pos = this.getFromData('pos');

        if (this.moving) {

          pos.x = this.graph.deltaPosition(pos.x, deltaX, this.getXAxis());
          pos.y = this.graph.deltaPosition(pos.y, deltaY, this.getYAxis());
        }

        this.redrawImpl();

        return true;
      }
    }, {
      key: 'setHandles',
      value: function setHandles() {

        if (!this.areHandlesInDom()) {
          return;
        }

        if (isNaN(this.currentPos1x)) {
          return;
        }

        this.handles[1].setAttribute('x', this.currentPos1x);
        this.handles[1].setAttribute('y', this.currentPos1y);
      }
    }, {
      key: 'selectStyle',
      value: function selectStyle() {
        this.setDom('stroke', 'red');
        this.setDom('stroke-width', '2');
      }
    }, {
      key: 'width',
      get: function get() {
        return this.options.width || 10;
      },
      set: function set(l) {
        this.options.width = l;
      }
    }]);

    return ShapeCross;
  }(_graphShape2.default);

  exports.default = ShapeCross;
  module.exports = exports['default'];
});

/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(102)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('./graph.shape.line.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphShapeLine);
    global.graphShapePeakboundariescenter = mod.exports;
  }
})(this, function (module, exports, _graphShapeLine) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _graphShapeLine2 = _interopRequireDefault(_graphShapeLine);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var ShapePeakBoundaries = function (_ShapeLine) {
    _inherits(ShapePeakBoundaries, _ShapeLine);

    function ShapePeakBoundaries(graph) {
      _classCallCheck(this, ShapePeakBoundaries);

      var _this = _possibleConstructorReturn(this, (ShapePeakBoundaries.__proto__ || Object.getPrototypeOf(ShapePeakBoundaries)).call(this, graph));

      _this.lineHeight = 6;
      return _this;
    }

    _createClass(ShapePeakBoundaries, [{
      key: 'createDom',
      value: function createDom() {

        this._dom = document.createElementNS(this.graph.ns, 'line');
        this.line1 = document.createElementNS(this.graph.ns, 'line');
        this.line2 = document.createElementNS(this.graph.ns, 'line');
        this.line3 = document.createElementNS(this.graph.ns, 'line');

        this.rectBoundary = document.createElementNS(this.graph.ns, 'path');

        this.rectBoundary.setAttribute('fill', 'transparent');
        this.rectBoundary.setAttribute('stroke', 'none');
        this.rectBoundary.setAttribute('pointer-events', 'fill');

        this.rectBoundary.jsGraphIsShape = true;

        this.group.appendChild(this.rectBoundary);
        this.group.appendChild(this.line1);
        this.group.appendChild(this.line2);
        this.group.appendChild(this.line3);
        this._dom.element = this;
      }
    }, {
      key: 'createHandles',
      value: function createHandles() {
        this._createHandles(3, 'rect', {
          transform: 'translate(-3 -3)',
          width: 6,
          height: 6,
          stroke: 'black',
          fill: 'white',
          cursor: 'nwse-resize'
        });
      }
    }, {
      key: 'redrawImpl',
      value: function redrawImpl() {

        this.line1.setAttribute('stroke', this.getStrokeColor());
        this.line2.setAttribute('stroke', this.getStrokeColor());
        this.line3.setAttribute('stroke', this.getStrokeColor());

        this.line1.setAttribute('stroke-width', this.getStrokeWidth());
        this.line2.setAttribute('stroke-width', this.getStrokeWidth());
        this.line3.setAttribute('stroke-width', this.getStrokeWidth());

        this.setHandles();
        this.redrawLines();
      }
    }, {
      key: 'redrawLines',
      value: function redrawLines() {

        var posLeft = this.computePosition(0);
        var posRight = this.computePosition(1);
        var posCenter = this.computePosition(2);

        if (posLeft.x && posRight.x && posCenter.x && this.posYPx) {

          var height = this.lineHeight;
          this.rectBoundary.setAttribute('d', 'M ' + posLeft.x + ' ' + (this.posYPx - height) + ' v ' + 2 * height + ' H ' + posRight.x + ' v ' + -2 * height + 'z');
          this.line1.setAttribute('x1', posLeft.x);
          this.line1.setAttribute('x2', posLeft.x);

          this.line2.setAttribute('x1', posRight.x);
          this.line2.setAttribute('x2', posRight.x);

          this.line3.setAttribute('x1', posCenter.x);
          this.line3.setAttribute('x2', posCenter.x);

          this._dom.setAttribute('x1', posLeft.x);
          this._dom.setAttribute('x2', posRight.x);

          this.redrawY(height);
        }

        return this;
      }
    }, {
      key: 'redrawY',
      value: function redrawY() {

        if (!this.posYPx) {
          return this;
        }

        var height = this.lineHeight;

        this.line1.setAttribute('y1', this.posYPx - height);
        this.line1.setAttribute('y2', this.posYPx + height);

        this.line2.setAttribute('y1', this.posYPx - height);
        this.line2.setAttribute('y2', this.posYPx + height);

        this.line3.setAttribute('y1', this.posYPx - height);
        this.line3.setAttribute('y2', this.posYPx + height);

        this._dom.setAttribute('y1', this.posYPx);
        this._dom.setAttribute('y2', this.posYPx);

        return this;
      }
    }, {
      key: 'setHandles',
      value: function setHandles() {

        if (!this.posYPx) {
          return;
        }

        var posLeft = this.computePosition(0);
        var posRight = this.computePosition(1);
        var posCenter = this.computePosition(2);

        if (posLeft.x && posRight.x && posCenter.x) {

          this.handles[1].setAttribute('x', posLeft.x);
          this.handles[1].setAttribute('y', this.posYPx);

          this.handles[2].setAttribute('x', posRight.x);
          this.handles[2].setAttribute('y', this.posYPx);

          this.handles[3].setAttribute('x', posCenter.x);
          this.handles[3].setAttribute('y', this.posYPx);
        }
      }
    }, {
      key: 'setY',
      value: function setY(y) {
        this.posYPx = y;
        return this;
      }
    }, {
      key: 'setLineHeight',
      value: function setLineHeight(height) {
        this.lineHeihgt = height;
      }
    }, {
      key: 'handleMouseMoveImpl',
      value: function handleMouseMoveImpl(e, deltaX, deltaY) {

        if (this.isLocked()) {
          return;
        }

        var posLeft = this.getPosition(0);
        var posRight = this.getPosition(1);
        var posCenter = this.getPosition(2);

        switch (this.handleSelected) {

          case 1:
            // left
            posLeft.deltaPosition('x', deltaX, this.getXAxis());

            if (Math.abs(posCenter.x - posRight.x) > Math.abs(posRight.x - posLeft.x) || Math.abs(posCenter.x - posLeft.x) > Math.abs(posRight.x - posLeft.x)) {
              posCenter.x = posLeft.x + (posRight.x - posLeft.x) * 0.1;
            }
            break;

          case 2:
            // left

            posRight.deltaPosition('x', deltaX, this.getXAxis());

            if (Math.abs(posCenter.x - posRight.x) > Math.abs(posRight.x - posLeft.x) || Math.abs(posCenter.x - posLeft.x) > Math.abs(posRight.x - posLeft.x)) {
              posCenter.x = posRight.x + (posLeft.x - posRight.x) * 0.1;
            }

            break;

          case 3:
            // left

            posCenter.deltaPosition('x', deltaX, this.getXAxis());

            if (Math.abs(posCenter.x - posRight.x) > Math.abs(posRight.x - posLeft.x) || Math.abs(posCenter.x - posLeft.x) > Math.abs(posRight.x - posLeft.x)) {
              return;
            }

            break;

        }

        this.setLabelPosition({
          y: this.getLabelPosition(0).y,
          x: posCenter.x
        });

        this.updateLabels();
        this.redrawLines();
        this.setHandles();
      }
    }, {
      key: 'applyPosition',
      value: function applyPosition() {

        this.redrawLines();
        return true;
      }
    }]);

    return ShapePeakBoundaries;
  }(_graphShapeLine2.default);

  exports.default = ShapePeakBoundaries;
  module.exports = exports['default'];
});

/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(5), __webpack_require__(28)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('../graph.util.js'), require('./graph.shape.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphUtil, global.graphShape);
    global.graphShapeHtml = mod.exports;
  }
})(this, function (module, exports, _graphUtil, _graphShape) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _graphShape2 = _interopRequireDefault(_graphShape);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var ShapeHTML = function (_GraphShape) {
    _inherits(ShapeHTML, _GraphShape);

    function ShapeHTML(graph, options) {
      _classCallCheck(this, ShapeHTML);

      return _possibleConstructorReturn(this, (ShapeHTML.__proto__ || Object.getPrototypeOf(ShapeHTML)).call(this, graph, options));
    }

    /**
     * Creates the DOM
     * @private
     * @return {Shape} The current shape
     */


    _createClass(ShapeHTML, [{
      key: 'createDom',
      value: function createDom() {

        this._dom = document.createElement('div');
        //  this._dom.setAttribute( "requiredExtensions", "http://www.w3.org/1999/xhtml" );

        this._dom.setAttribute('style', 'position: absolute');
        var div = document.createElement('div');
        this._dom.appendChild(div);
        this.div = div;
      }
    }, {
      key: 'createHandles',
      value: function createHandles() {}
    }, {
      key: 'setHeight',
      value: function setHeight(height) {
        this.setProp('height', height);
      }
    }, {
      key: 'setWidth',
      value: function setWidth(width) {
        this.setProp('width', width);
      }
    }, {
      key: 'setContent',
      value: function setContent(content) {
        this.setProp('content', content);
      }
    }, {
      key: 'setRenderer',
      value: function setRenderer(method) {
        this._renderer = method;
      }
    }, {
      key: 'redraw',
      value: function redraw() {

        if (this._renderer) {
          this._renderer(this.div);
        } else {
          this.div.innerHTML = this.getProp('content');
        }
        _get(ShapeHTML.prototype.__proto__ || Object.getPrototypeOf(ShapeHTML.prototype), 'redraw', this).apply(this, arguments);
      }
    }, {
      key: 'applyPosition',
      value: function applyPosition() {

        var position = this.calculatePosition(0);

        if (!position || !(0, _graphUtil.isNumeric)(position.x) || !(0, _graphUtil.isNumeric)(position.y)) {
          return;
        }
        this._dom.style.left = position.x + 'px';
        this._dom.style.top = position.y + 'px';

        this.currentPosX = position.x;
        this.currentPosY = position.y;

        return true;
      }
    }, {
      key: 'handleMouseMoveImpl',
      value: function handleMouseMoveImpl(e, deltaX, deltaY, deltaXPx, deltaYPx) {

        return true;
      }
    }, {
      key: 'setHandles',
      value: function setHandles() {}
    }, {
      key: 'isHTML',
      value: function isHTML() {
        return true;
      }
    }]);

    return ShapeHTML;
  }(_graphShape2.default);

  exports.default = ShapeHTML;
  module.exports = exports['default'];
});

/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(29)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('./graph.plugin.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphPlugin);
    global.graphPluginDrag = mod.exports;
  }
})(this, function (module, exports, _graphPlugin) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _graphPlugin2 = _interopRequireDefault(_graphPlugin);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var PluginDrag = function (_Plugin) {
    _inherits(PluginDrag, _Plugin);

    function PluginDrag() {
      _classCallCheck(this, PluginDrag);

      return _possibleConstructorReturn(this, (PluginDrag.__proto__ || Object.getPrototypeOf(PluginDrag)).apply(this, arguments));
    }

    _createClass(PluginDrag, [{
      key: 'init',
      value: function init(graph) {

        this.graph = graph;
        this.time = null;
        this.totaltime = 2000;
      }
    }, {
      key: 'onMouseDown',
      value: function onMouseDown(graph, x, y, e, target) {
        this._draggingX = x;
        this._draggingY = y;

        this._lastDraggingX = this._draggingX;
        this._lastDraggingY = this._draggingY;

        this.stopAnimation = true;

        this.moved = false;

        return true;
      }
    }, {
      key: 'onMouseMove',
      value: function onMouseMove(graph, x, y, e, target) {

        var deltaX = x - this._draggingX;
        var deltaY = y - this._draggingY;

        if (this.options.dragX) {
          graph._applyToAxes(function (axis) {
            axis.setCurrentMin(axis.getVal(axis.getMinPx() - deltaX));
            axis.setCurrentMax(axis.getVal(axis.getMaxPx() - deltaX));
          }, false, true, false);
        }

        if (this.options.dragY) {

          graph._applyToAxes(function (axis) {
            axis.setCurrentMin(axis.getVal(axis.getMinPx() - deltaY));
            axis.setCurrentMax(axis.getVal(axis.getMaxPx() - deltaY));
          }, false, false, true);
        }

        this._lastDraggingX = this._draggingX;
        this._lastDraggingY = this._draggingY;

        this._draggingX = x;
        this._draggingY = y;

        this.moved = true;

        this.time = Date.now();

        this.emit('dragging');

        graph.draw(true);
      }
    }, {
      key: 'onMouseUp',
      value: function onMouseUp(graph, x, y, e, target) {

        var dt = Date.now() - this.time;

        if (x == this._lastDraggingX || y == this._lastDraggingY) {

          if (this.moved) {
            this.emit('dragged');
          }

          return;
        }

        this.speedX = (x - this._lastDraggingX) / dt;
        this.speedY = (y - this._lastDraggingY) / dt;

        if (isNaN(this.speedX) || isNaN(this.speedY)) {
          this.emit('dragged');
          return;
        }

        graph._applyToAxes(function (axis) {
          axis._pluginDragMin = axis.getCurrentMin();
          axis._pluginDragMax = axis.getCurrentMax();
        }, false, true, true);

        this.stopAnimation = false;
        this.accelerationX = -this.speedX / this.totaltime;
        this.accelerationY = -this.speedY / this.totaltime;

        if (this.options.persistanceX || this.options.persistanceY) {

          this._persistanceMove(graph);
        } else {

          this.emit('dragged');
        }
      }
    }, {
      key: '_persistanceMove',
      value: function _persistanceMove(graph) {

        var self = this;

        if (self.stopAnimation) {
          self.emit('dragged');
          return;
        }

        window.requestAnimationFrame(function () {

          var dt = Date.now() - self.time;
          var dx = (0.5 * self.accelerationX * dt + self.speedX) * dt;
          var dy = (0.5 * self.accelerationY * dt + self.speedY) * dt;

          if (self.options.persistanceX) {

            graph._applyToAxes(function (axis) {

              axis.setCurrentMin(-axis.getRelVal(dx) + axis._pluginDragMin);
              axis.setCurrentMax(-axis.getRelVal(dx) + axis._pluginDragMax);

              axis.cacheCurrentMin();
              axis.cacheCurrentMax();
              axis.cacheInterval();
            }, false, true, false);
          }

          if (self.options.persistanceY) {

            graph._applyToAxes(function (axis) {

              axis.setCurrentMin(-axis.getRelVal(dy) + axis._pluginDragMin);
              axis.setCurrentMax(-axis.getRelVal(dy) + axis._pluginDragMax);

              axis.cacheCurrentMin();
              axis.cacheCurrentMax();
              axis.cacheInterval();
            }, false, false, true);
          }

          graph.draw();

          if (dt < self.totaltime) {
            self.emit('dragging');
            self._persistanceMove(graph);
          } else {
            self.emit('dragged');
          }
        });
      }
    }], [{
      key: 'default',
      value: function _default() {
        return {

          dragX: true,
          dragY: true,
          persistanceX: false,
          persistanceY: false

        };
      }
    }]);

    return PluginDrag;
  }(_graphPlugin2.default);

  exports.default = PluginDrag;
  module.exports = exports['default'];
});

/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(5), __webpack_require__(29)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('../graph.util.js'), require('./graph.plugin.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphUtil, global.graphPlugin);
    global.graphPluginShape = mod.exports;
  }
})(this, function (module, exports, _graphUtil, _graphPlugin) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var util = _interopRequireWildcard(_graphUtil);

  var _graphPlugin2 = _interopRequireDefault(_graphPlugin);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var PluginShape = function (_Plugin) {
    _inherits(PluginShape, _Plugin);

    function PluginShape() {
      _classCallCheck(this, PluginShape);

      return _possibleConstructorReturn(this, (PluginShape.__proto__ || Object.getPrototypeOf(PluginShape)).apply(this, arguments));
    }

    _createClass(PluginShape, [{
      key: 'init',
      value: function init(graph, options) {

        _get(PluginShape.prototype.__proto__ || Object.getPrototypeOf(PluginShape.prototype), 'init', this).call(this, graph, options);
        this.shapeType = options.type;
      }
    }, {
      key: 'setShape',
      value: function setShape(shapeType) {
        this.shapeInfo.shapeType = shapeType;
      }
    }, {
      key: 'onMouseDown',
      value: function onMouseDown(graph, x, y, e, target) {
        var _this2 = this;

        if (!this.shapeType && !this.options.url) {
          return;
        }

        var self = this,
            selfPlugin = this;

        var xVal, yVal;

        this.count = this.count || 0;

        x -= graph.getPaddingLeft();
        y -= graph.getPaddingTop();

        xVal = graph.getXAxis().getVal(x);
        yVal = graph.getYAxis().getVal(y);

        var shapeInfo = {

          position: [{
            x: xVal,
            y: yVal
          }, {
            x: xVal,
            y: yVal
          }],

          onChange: function onChange(newData) {
            graph.triggerEvent('onAnnotationChange', newData);
          },

          locked: false,
          selectable: true,
          resizable: true,
          movable: true
        };

        var shapeProperties = this.options.properties;

        util.extend(true, shapeInfo, this.options);

        this.emit('beforeNewShape', e, shapeInfo);

        if (this.graph.prevent(false)) {
          return;
        }

        var shape = graph.newShape(shapeInfo.type, shapeInfo, false, shapeProperties);

        this.emit('createdShape', e, shape);

        if (shape) {
          self.currentShape = shape;
          self.currentShapeEvent = e;
        }

        graph.once('mouseUp', function () {
          console.log(_this2.currentShape);
          if (!_this2.currentShape) {
            // The mouse has moved
            self.emit('newShape', e, shape);
          }
        });
      }
    }, {
      key: 'onMouseMove',
      value: function onMouseMove(graph, x, y, e) {

        if (this.currentShape) {
          console.log('mv');
          this.count++;

          var shape = this.currentShape;

          this.currentShape = false;

          if (graph.selectedSerie && !shape.serie) {
            shape.setSerie(graph.selectedSerie);
          }

          shape.resizing = true;

          if (shape.options && shape.options.onCreate) {
            shape.options.onCreate.call(shape);
          }

          shape.draw();
          graph.selectShape(shape);
          shape.handleMouseDown(this.currentShapeEvent, true);
          shape.handleSelected = this.options.handleSelected || 1;
          shape.handleMouseMove(e, true);
        }
      }
    }, {
      key: 'onMouseUp',
      value: function onMouseUp() {

        if (this.currentShape) {
          // No need to kill it as it hasn't been actually put in the dom right now

          // Norman 30 July 2017: Yes but it's added in the jsGraph stack. We need to remove it. See #176
          // From now on killing the shape will result in removing it from the stack as well.
          this.currentShape.kill();
          this.currentShape = false;
        }
      }
    }], [{
      key: 'default',
      value: function _default() {
        return {};
      }
    }]);

    return PluginShape;
  }(_graphPlugin2.default);

  exports.default = PluginShape;
  module.exports = exports['default'];
});

/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(5), __webpack_require__(29)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('../graph.util.js'), require('./graph.plugin.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphUtil, global.graphPlugin);
    global.graphPluginSelectScatter = mod.exports;
  }
})(this, function (module, exports, _graphUtil, _graphPlugin) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var util = _interopRequireWildcard(_graphUtil);

  var _graphPlugin2 = _interopRequireDefault(_graphPlugin);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var PluginSelectScatter = function (_Plugin) {
    _inherits(PluginSelectScatter, _Plugin);

    function PluginSelectScatter() {
      _classCallCheck(this, PluginSelectScatter);

      return _possibleConstructorReturn(this, (PluginSelectScatter.__proto__ || Object.getPrototypeOf(PluginSelectScatter)).apply(this, arguments));
    }

    _createClass(PluginSelectScatter, [{
      key: 'init',
      value: function init(graph, options) {

        this._path = document.createElementNS(graph.ns, 'path');

        util.setAttributeTo(this._path, {
          'display': 'none',
          'fill': 'rgba(0,0,0,0.1)',
          'stroke': 'rgba(0,0,0,1)',
          'shape-rendering': 'crispEdges',
          'x': 0,
          'y': 0,
          'height': 0,
          'width': 0,
          'd': ''
        });

        this.graph = graph;

        graph.dom.appendChild(this._path);
      }
    }, {
      key: 'setSerie',
      value: function setSerie(serie) {
        this.serie = serie;
      }
    }, {
      key: 'onMouseDown',
      value: function onMouseDown(graph, x, y, e, mute) {

        if (!this.serie) {
          return;
        }

        this.path = 'M ' + x + ' ' + y + ' ';
        this.currentX = x;
        this.currentY = y;

        this.xs = [this.serie.getXAxis().getVal(x - graph.getPaddingLeft())];
        this.ys = [this.serie.getYAxis().getVal(y - graph.getPaddingTop())];
        this._path.setAttribute('d', '');
        this._path.setAttribute('display', 'block');
      }
    }, {
      key: 'onMouseMove',
      value: function onMouseMove(graph, x, y, e, mute) {

        if (Math.pow(x - this.currentX, 2) + Math.pow(y - this.currentY, 2) > 25) {

          this.path += ' L ' + x + ' ' + y + ' ';
          this.currentX = x;
          this.currentY = y;

          this.xs.push(this.serie.getXAxis().getVal(x - graph.getPaddingLeft()));
          this.ys.push(this.serie.getYAxis().getVal(y - graph.getPaddingTop()));

          this._path.setAttribute('d', this.path + ' z');

          this.findPoints();
        }
      }
    }, {
      key: 'findPoints',
      value: function findPoints() {

        var data = this.serie.waveform;
        var selected = [];
        var counter = 0,
            j2;
        for (var i = 0, l = data.getLength(); i < l; i += 1) {

          counter = 0;
          for (var j = 0, k = this.xs.length; j < k; j += 1) {

            if (j == k - 1) {
              j2 = 0;
            } else {
              j2 = j + 1;
            }

            if (this.ys[j] < data.getY(i) && this.ys[j2] > data.getY(i) || this.ys[j] > data.getY(i) && this.ys[j2] < data.getY(i)) {

              if (data.getX(i) > (data.getY(i) - this.ys[j]) / (this.ys[j2] - this.ys[j]) * (this.xs[j2] - this.xs[j]) + this.xs[j]) {
                counter++;
              }
            }
          }

          if (counter % 2 == 1) {
            selected.push(i);
            this.serie.selectPoint(i, true, 'selected');
          } else {
            this.serie.unselectPoint(i);
          }
        }

        this.selected = selected;
        this.emit('selectionProcess', selected);
      }
    }, {
      key: 'onMouseUp',
      value: function onMouseUp(graph, x, y, e) {
        this._path.setAttribute('display', 'none');
        this.emit('selectionEnd', this.selected);
      }
    }], [{
      key: 'default',
      value: function _default() {
        return {};
      }
    }]);

    return PluginSelectScatter;
  }(_graphPlugin2.default);

  exports.default = PluginSelectScatter;
  module.exports = exports['default'];
});

/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(5), __webpack_require__(29)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('../graph.util.js'), require('./graph.plugin.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphUtil, global.graphPlugin);
    global.graphPluginZoom = mod.exports;
  }
})(this, function (module, exports, _graphUtil, _graphPlugin) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var util = _interopRequireWildcard(_graphUtil);

  var _graphPlugin2 = _interopRequireDefault(_graphPlugin);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var PluginZoom = function (_Plugin) {
    _inherits(PluginZoom, _Plugin);

    function PluginZoom() {
      _classCallCheck(this, PluginZoom);

      return _possibleConstructorReturn(this, (PluginZoom.__proto__ || Object.getPrototypeOf(PluginZoom)).apply(this, arguments));
    }

    _createClass(PluginZoom, [{
      key: 'init',
      value: function init(graph, options) {

        this._zoomingGroup = document.createElementNS(graph.ns, 'g');
        this._zoomingSquare = document.createElementNS(graph.ns, 'rect');
        this._zoomingSquare.setAttribute('display', 'none');

        util.setAttributeTo(this._zoomingSquare, {
          'display': 'none',
          'fill': 'rgba(171,12,12,0.2)',
          'stroke': 'rgba(171,12,12,1)',
          'shape-rendering': 'crispEdges',
          'x': 0,
          'y': 0,
          'height': 0,
          'width': 0,
          'pointer-events': 'none'
        });

        this.graph = graph;
        graph.groupEvent.appendChild(this._zoomingGroup);
        this._zoomingGroup.appendChild(this._zoomingSquare);
      }
    }, {
      key: 'onMouseDown',
      value: function onMouseDown(graph, x, y, e, mute) {

        var zoomMode = this.options.zoomMode;

        if (!zoomMode) {
          return;
        }

        this._zoomingMode = zoomMode;

        if (x === undefined) {
          this._backedUpZoomMode = this._zoomingMode;
          this._zoomingMode = 'y';
          x = 0;
        }

        if (y === undefined) {
          this._backedUpZoomMode = this._zoomingMode;
          this._zoomingMode = 'x';
          y = 0;
        }

        this._zoomingXStart = x;
        this._zoomingYStart = y;
        this.x1 = x - graph.getPaddingLeft();
        this.y1 = y - graph.getPaddingTop();

        this._zoomingSquare.setAttribute('width', 0);
        this._zoomingSquare.setAttribute('height', 0);
        this._zoomingSquare.setAttribute('display', 'block');

        switch (this._zoomingMode) {

          case 'x':
            this._zoomingSquare.setAttribute('y', graph.options.paddingTop);
            this._zoomingSquare.setAttribute('height', graph.getDrawingHeight() - graph.shift.bottom);
            break;

          case 'y':
            this._zoomingSquare.setAttribute('x', graph.options.paddingLeft /* + this.shift[1]*/);
            this._zoomingSquare.setAttribute('width', graph.getDrawingWidth() /* - this.shift[1] - this.shift[2]*/);
            break;

          case 'forceY2':

            this.y2 = graph.getYAxis().getPx(this.options.forcedY) + graph.options.paddingTop;

            break;

        }

        if (this.options.onZoomStart && !mute) {
          this.options.onZoomStart(graph, x, y, e, mute);
        }
      }
    }, {
      key: 'onMouseMove',
      value: function onMouseMove(graph, x, y, e, mute) {

        //	this._zoomingSquare.setAttribute('display', 'none');

        //	this._zoomingSquare.setAttribute('transform', 'translate(' + Math.random() + ', ' + Math.random() + ') scale(10, 10)');
        switch (this._zoomingMode) {

          case 'xy':
            this._zoomingSquare.setAttribute('x', Math.min(this._zoomingXStart, x));
            this._zoomingSquare.setAttribute('y', Math.min(this._zoomingYStart, y));
            this._zoomingSquare.setAttribute('width', Math.abs(this._zoomingXStart - x));
            this._zoomingSquare.setAttribute('height', Math.abs(this._zoomingYStart - y));

            break;

          case 'forceY2':
            this._zoomingSquare.setAttribute('y', Math.min(this._zoomingYStart, this.y2));
            this._zoomingSquare.setAttribute('height', Math.abs(this._zoomingYStart - this.y2));
            this._zoomingSquare.setAttribute('x', Math.min(this._zoomingXStart, x));
            this._zoomingSquare.setAttribute('width', Math.abs(this._zoomingXStart - x));

            break;

          case 'x':
            this._zoomingSquare.setAttribute('x', Math.min(this._zoomingXStart, x));
            this._zoomingSquare.setAttribute('width', Math.abs(this._zoomingXStart - x));

            break;

          case 'y':
            this._zoomingSquare.setAttribute('y', Math.min(this._zoomingYStart, y));
            this._zoomingSquare.setAttribute('height', Math.abs(this._zoomingYStart - y));
            break;

        }

        if (this.options.onZoomMove && !mute) {

          this.options.onZoomMove(graph, x, y, e, mute);
        }
        //		this._zoomingSquare.setAttribute('display', 'block');
      }
    }, {
      key: 'onMouseUp',
      value: function onMouseUp(graph, x, y, e, mute) {
        var self = this;
        this.removeZone();

        var _x = x - graph.options.paddingLeft;
        var _y = y - graph.options.paddingTop;

        this.emit('beforeZoom', {
          graph: graph,
          x: x,
          y: y,
          e: e,
          mute: mute
        });

        if (graph.prevent(false)) {

          // This doesn't work !
          //graph.prevent( true ); // Cancel future click event
          return;
        }

        if (x - this._zoomingXStart == 0 && this._zoomingMode != 'y' || y - this._zoomingYStart == 0 && this._zoomingMode != 'x') {
          return;
        }

        if (this.options.transition || this.options.smooth) {

          var modeX = false,
              modeY = false;

          if (this._zoomingMode == 'x' || this._zoomingMode == 'xy' || this._zoomingMode == 'forceY2') {

            this.fullX = false;
            this.toAxes(function (axis) {

              axis._pluginZoomMin = axis.getCurrentMin();
              axis._pluginZoomMax = axis.getCurrentMax();

              axis._pluginZoomMinFinal = Math.min(axis.getVal(_x), axis.getVal(self.x1));
              axis._pluginZoomMaxFinal = Math.max(axis.getVal(_x), axis.getVal(self.x1));
            }, false, true, false);

            modeX = true;
          }

          if (this._zoomingMode == 'y' || this._zoomingMode == 'xy') {

            this.fullY = false;
            this.toAxes(function (axis) {

              axis._pluginZoomMin = axis.getCurrentMin();
              axis._pluginZoomMax = axis.getCurrentMax();

              axis._pluginZoomMinFinal = Math.min(axis.getVal(_y), axis.getVal(self.y1));
              axis._pluginZoomMaxFinal = Math.max(axis.getVal(_y), axis.getVal(self.y1));
            }, false, false, true);

            modeY = true;
          }

          if (this._zoomingMode == 'forceY2') {

            this.fullY = false;
            this.toAxes(function (axis) {

              axis._pluginZoomMin = axis.getCurrentMin();
              axis._pluginZoomMax = axis.getCurrentMax();

              axis._pluginZoomMinFinal = Math.min(axis.getVal(self.y2), axis.getVal(self.y1));
              axis._pluginZoomMaxFinal = Math.max(axis.getVal(self.y2), axis.getVal(self.y1));
            }, false, false, true);

            modeY = true;
          }

          this.transition(modeX, modeY, 'zoomEnd');
        } else {

          switch (this._zoomingMode) {
            case 'x':
              this.fullX = false;
              this.toAxes('_doZoom', [_x, this.x1], true, false);
              break;
            case 'y':
              this.fullY = false;
              this.toAxes('_doZoom', [_y, this.y1], false, true);
              break;
            case 'xy':
              this.fullX = false;
              this.fullY = false;
              this.toAxes('_doZoom', [_x, this.x1], true, false);
              this.toAxes('_doZoom', [_y, this.y1], false, true);
              break;

            case 'forceY2':

              this.fullX = false;
              this.fullY = false;

              this.toAxes('_doZoom', [_x, this.x1], true, false);
              this.toAxes('_doZoom', [this.y1, this.y2], false, true);

              break;
          }

          //  graph.prevent( true ); // WHat are you doing ??
          graph.draw();

          if (this._backedUpZoomMode) {
            this._zoomingMode = this._backedUpZoomMode;
          }

          this.emit('zoomed');

          graph.pluginYieldActiveState();
        }
      }
    }, {
      key: 'removeZone',
      value: function removeZone() {

        this._zoomingSquare.setAttribute('display', 'none');
      }
    }, {
      key: 'onMouseWheel',
      value: function onMouseWheel(delta, e, coordX, coordY, options) {

        if (!options) {
          options = {};
        }

        if (!options.baseline) {
          options.baseline = 0;
        }

        var baseline = options.baseline;

        if (options.baseline == 'mousePosition') {
          baseline = this.graph.getYAxis().getVal(coordY);
          console.log(baseline);
        }

        /*var serie;
        if ( ( serie = this.graph.getSelectedSerie() ) ) {
           if ( serie.getYAxis().handleMouseWheel( delta, e ) ) {
            return;
          }
        }*/

        var doX = options.direction == 'x';
        var doY = !(options.direction !== 'y');

        this.toAxes('handleMouseWheel', [delta, e, baseline], doX, doY);

        this.graph.drawSeries();
      }
    }, {
      key: 'onDblClick',
      value: function onDblClick(x, y, e, pref, mute) {

        var graph = this.graph;
        this.emit('beforeDblClick', {
          graph: graph,
          x: x,
          y: y,
          pref: pref,
          e: e,
          mute: mute
        });

        if (graph.prevent(false)) {
          return;
        }

        if (this.options.transition || this.options.smooth) {

          var modeX = false,
              modeY = false;

          if (pref.mode == 'xtotal' || pref.mode == 'total') {

            this.toAxes(function (axis) {
              axis._pluginZoomMin = axis.getCurrentMin();
              axis._pluginZoomMax = axis.getCurrentMax();

              axis._pluginZoomMinFinal = axis.getMinValue() - axis.options.axisDataSpacing.min * axis.getInterval();
              axis._pluginZoomMaxFinal = axis.getMaxValue() + axis.options.axisDataSpacing.max * axis.getInterval();
            }, false, true, false);

            modeX = true;
          }

          if (pref.mode == 'ytotal' || pref.mode == 'total') {

            this.toAxes(function (axis) {

              axis._pluginZoomMin = axis.getCurrentMin();
              axis._pluginZoomMax = axis.getCurrentMax();

              axis._pluginZoomMinFinal = axis.getMinValue() - axis.options.axisDataSpacing.min * axis.getInterval();
              axis._pluginZoomMaxFinal = axis.getMaxValue() + axis.options.axisDataSpacing.max * axis.getInterval();
            }, false, false, true);

            modeY = true;
          }

          var _x2 = void 0,
              _y2 = void 0;

          if (pref.mode == 'gradualX' || pref.mode == 'gradualY' || pref.mode == 'gradual' || pref.mode == 'gradualXY') {

            _x2 = false, _y2 = false;

            if (pref.mode == 'gradualX' || pref.mode == 'gradual' || pref.mode == 'gradualXY') {
              _x2 = true;
              modeX = true;
            }

            if (pref.mode == 'gradualY' || pref.mode == 'gradual' || pref.mode == 'gradualXY') {
              _y2 = true;
              modeY = true;
            }

            this.toAxes(function (axis) {

              axis._pluginZoomMin = axis.getCurrentMin();
              axis._pluginZoomMax = axis.getCurrentMax();

              axis._pluginZoomMinFinal = axis.getCurrentMin() - (axis.getCurrentMax() - axis.getCurrentMin());
              axis._pluginZoomMaxFinal = axis.getCurrentMax() + (axis.getCurrentMax() - axis.getCurrentMin());
            }, false, _x2, _y2);
          }

          this.transition(modeX, modeY, 'dblClick');
          return;
        }

        var xAxis = this.graph.getXAxis(),
            yAxis = this.graph.getYAxis();

        if (pref.mode == 'xtotal') {

          this.toAxes('setMinMaxToFitSeries', null, true, false);
          this.fullX = true;
          this.fullY = false;
        } else if (pref.mode == 'ytotal') {

          this.toAxes('setMinMaxToFitSeries', null, false, true);
          this.fullX = false;
          this.fullY = true;
        } else if (pref.mode == 'total') {

          this.toAxes('setMinMaxToFitSeries', null, true, true);

          this.fullX = true;
          this.fullY = true;
          // Nothing to do here
          /*        this.graph._applyToAxes( function( axis ) {
               axis.emit( 'zoom', axis.currentAxisMin, axis.currentAxisMax, axis );
             }, null, true, true );
          */
        } else {

          x -= this.graph.options.paddingLeft;
          y -= this.graph.options.paddingTop;

          var xMin = xAxis.getCurrentMin(),
              xMax = xAxis.getCurrentMax(),
              xActual = xAxis.getVal(x),
              diffX = xMax - xMin,
              yMin = yAxis.getCurrentMin(),
              yMax = yAxis.getCurrentMax(),
              yActual = yAxis.getVal(y),
              diffY = yMax - yMin;

          if (pref.mode == 'gradualXY' || pref.mode == 'gradualX') {

            var ratio = (xActual - xMin) / (xMax - xMin);
            xMin = Math.max(xAxis.getMinValue() - xAxis.getInterval() * xAxis.options.axisDataSpacing.min, xMin - diffX * ratio);
            xMax = Math.min(xAxis.getMaxValue() + xAxis.getInterval() * xAxis.options.axisDataSpacing.max, xMax + diffX * (1 - ratio));
            xAxis.setCurrentMin(xMin);
            xAxis.setCurrentMax(xMax);

            if (xAxis.options.onZoom) {
              xAxis.options.onZoom(xMin, xMax);
            }

            xAxis.cacheCurrentMin();
            xAxis.cacheCurrentMax();
            xAxis.cacheInterval();
          }

          if (pref.mode == 'gradualXY' || pref.mode == 'gradualY') {

            var ratio = (yActual - yMin) / (yMax - yMin);
            yMin = Math.max(yAxis.getMinValue() - yAxis.getInterval() * yAxis.options.axisDataSpacing.min, yMin - diffY * ratio);
            yMax = Math.min(yAxis.getMaxValue() + yAxis.getInterval() * yAxis.options.axisDataSpacing.max, yMax + diffY * (1 - ratio));
            yAxis.setCurrentMin(yMin);
            yAxis.setCurrentMax(yMax);

            if (yAxis.options.onZoom) {
              yAxis.options.onZoom(yMin, yMax);
            }

            yAxis.cacheCurrentMin();
            yAxis.cacheCurrentMax();
            yAxis.cacheInterval();
          }
        }

        graph.pluginYieldActiveState();

        this.graph.draw();
        /*
            this.emit( "dblClick", {
              graph: graph,
              x: x,
              y: y,
              pref: pref,
              e: e,
              mute: mute
            } );
             if ( this.options.onDblClick && !mute ) {
              this.options.onDblClick( graph, x, y, e, mute );
            }*/
      }
    }, {
      key: 'transition',
      value: function transition(modeX, modeY, eventName) {

        var self = this,
            maxTime = 500;

        if (!self.gradualUnzoomStart) {
          self.gradualUnzoomStart = Date.now();
        }

        window.requestAnimationFrame(function () {

          var dt = Date.now() - self.gradualUnzoomStart;

          if (dt > maxTime) {
            dt = maxTime;
          }
          var progress = Math.sin(dt / maxTime * Math.PI / 2);

          self.toAxes(function (axis) {

            axis.setCurrentMin(axis._pluginZoomMin + (axis._pluginZoomMinFinal - axis._pluginZoomMin) * progress);
            axis.setCurrentMax(axis._pluginZoomMax + (axis._pluginZoomMaxFinal - axis._pluginZoomMax) * progress);

            axis.cacheCurrentMin();
            axis.cacheCurrentMax();
            axis.cacheInterval();
          }, false, modeX, modeY);

          self.graph.draw();

          if (dt < maxTime) {

            self.transition(modeX, modeY, eventName);
            self.emit('zooming');
          } else {

            self.emit('zoomed');
            self.graph.pluginYieldActiveState();

            if (eventName) {
              self.emit(eventName);
            }
            self.gradualUnzoomStart = 0;
          }
        });
      }
    }, {
      key: 'isFullX',
      value: function isFullX() {
        return this.fullX;
      }
    }, {
      key: 'isFullY',
      value: function isFullY() {
        return this.fullY;
      }
    }, {
      key: 'toAxes',
      value: function toAxes(func, params, tb, lr) {

        var axes = this.options.axes;

        if (!axes || axes == 'serieSelected' && !this.graph.getSelectedSerie()) {
          axes = 'all';
        }

        switch (axes) {

          case 'all':
            this.graph._applyToAxes.apply(this.graph, arguments);
            break;

          case 'serieSelected':

            var serie = this.graph.getSelectedSerie();
            if (serie) {

              if (tb) {

                if (typeof func == 'string') {
                  serie.getXAxis()[func].apply(serie.getXAxis(), params);
                } else {
                  func.apply(serie.getXAxis(), params);
                }
              }

              if (lr) {

                if (typeof func == 'string') {
                  serie.getYAxis()[func].apply(serie.getYAxis(), params);
                } else {
                  func.apply(serie.getYAxis(), params);
                }
              }
            }

            break;

          default:

            if (!Array.isArray(axes)) {
              axes = [axes];
            }

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = axes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var axis = _step.value;


                if (axis.isX() && tb) {
                  // Not the best check

                  if (typeof func == 'string') {
                    axis[func].apply(axis, params);
                  } else {
                    func.apply(axis, params);
                  }
                } else if (axis.isY() && lr) {
                  // Not the best check

                  if (typeof func == 'string') {
                    axis[func].apply(axis, params);
                  } else {
                    func.apply(axis, params);
                  }
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            break;
        }
      }
    }], [{
      key: 'default',
      value: function _default() {

        return {
          'axes': 'all'
        };
      }
    }]);

    return PluginZoom;
  }(_graphPlugin2.default);

  exports.default = PluginZoom;
  module.exports = exports['default'];
});

/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(45), __webpack_require__(372), __webpack_require__(5), __webpack_require__(29)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('../graph.core.js'), require('../graph.lru.js'), require('../graph.util.js'), require('./graph.plugin.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphCore, global.graphLru, global.graphUtil, global.graphPlugin);
    global.graphPluginTimeseriemanager = mod.exports;
  }
})(this, function (module, exports, _graphCore, _graphLru, _graphUtil, _graphPlugin) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _graphCore2 = _interopRequireDefault(_graphCore);

  var _graphLru2 = _interopRequireDefault(_graphLru);

  var util = _interopRequireWildcard(_graphUtil);

  var _graphPlugin2 = _interopRequireDefault(_graphPlugin);

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var PluginTimeSerieManager = function (_Plugin) {
    _inherits(PluginTimeSerieManager, _Plugin);

    function PluginTimeSerieManager() {
      _classCallCheck(this, PluginTimeSerieManager);

      var _this = _possibleConstructorReturn(this, (PluginTimeSerieManager.__proto__ || Object.getPrototypeOf(PluginTimeSerieManager)).apply(this, arguments));

      _this.series = [];
      _this.plugins = [];
      _this.currentSlots = {};

      _this.requestLevels = new Map();
      _this.update = function (noRecalculate, force) {

        _this.series.forEach(function (serie) {

          this.updateSerie(serie, noRecalculate);
        });

        if (!noRecalculate) {
          _this.recalculateSeries(force);
        }
      };

      return _this;
    }

    _createClass(PluginTimeSerieManager, [{
      key: 'init',
      value: function init(graph, options) {
        this.graph = graph;
        _graphLru2.default.create(this.options.LRUName, 200);
        this.requestsRunning = 0;
      }
    }, {
      key: 'setURL',
      value: function setURL(url) {
        this.options.url = url;
        return this;
      }
    }, {
      key: 'setAvailableIntervals',
      value: function setAvailableIntervals() {
        this.options.intervals = arguments;
      }
    }, {
      key: 'newSerie',
      value: function newSerie(serieName, serieOptions, serieType, dbElements, noZoneSerie) {
        var s = this.graph.newSerie(serieName, serieOptions, serieType);

        this.currentSlots[serieName] = {
          min: 0,
          max: 0,
          interval: 0
        };

        s.on('hide', function () {

          if (s._zoneSerie) {

            s._zoneSerie.hide();
          }
        });

        s.on('show', function () {

          if (s._zoneSerie) {
            s._zoneSerie.show();
          }
        });

        s.setInfo('timeSerieManagerDBElements', dbElements);

        if (!noZoneSerie) {
          s._zoneSerie = this.graph.newSerie(serieName + '_zone', {}, _graphCore2.default.SERIE_ZONE);
        }

        this.series.push(s);
        return s;
      }
    }, {
      key: 'registerPlugin',
      value: function registerPlugin(plugin, event) {

        var index;
        if ((index = this.plugins.indexOf(plugin)) > -1) {

          for (var i = 1; i < arguments.length; i++) {
            plugin.removeListener(arguments[i], this.update);
          }
        }

        for (var i = 1; i < arguments.length; i++) {
          plugin.on(arguments[i], this.update);
        }
      }
    }, {
      key: 'updateSerie',
      value: function updateSerie(serie, noRecalculate) {

        var self = this;
        var from = serie.getXAxis().getCurrentMin();
        var to = serie.getXAxis().getCurrentMax();
        var priority = 1;

        var optimalInterval = this.getOptimalInterval(to - from);
        var optimalIntervalIndex = this.options.intervals.indexOf(optimalInterval);
        var interval;

        this.cleanRegister(optimalIntervalIndex);

        for (var i = optimalIntervalIndex; i <= optimalIntervalIndex + 1; i++) {

          interval = this.options.intervals[i];
          var startSlotId = self.computeSlotID(from, interval);
          var endSlotId = self.computeSlotID(to, interval);

          var intervalMultipliers = [[2, 5, 6], [1, 2, 4], [0, 1, 3]];

          intervalMultipliers.forEach(function (multiplier) {

            var firstSlotId = startSlotId - multiplier[0] * (endSlotId - startSlotId);
            var lastSlotId = endSlotId + multiplier[0] * (endSlotId - startSlotId);

            var slotId = firstSlotId;

            while (slotId <= lastSlotId) {

              if (self.computeTimeMin(slotId, interval) > Date.now()) {
                break;
              }

              self.register(serie, slotId, interval, interval == optimalInterval ? multiplier[1] : multiplier[2], true, noRecalculate);
              slotId++;
            }
          });
        }

        this.processRequests();
      }
    }, {
      key: 'cleanRegister',
      value: function cleanRegister(interval) {

        if (!this.requestLevels) {
          return;
        }

        this.requestLevels.forEach(function (levelArray) {

          levelArray.forEach(function (levelElement, levelIndex) {

            if (levelElement[4] < interval) {
              levelArray.splice(levelIndex, 1);
            }
          });
        });
      }
    }, {
      key: 'register',
      value: function register(serie, slotId, interval, priority, noProcess, noRecalculate) {

        var id = this.computeUniqueID(serie, slotId, interval);

        var data = _graphLru2.default.get(this.options.LRUName, id);

        if (!data || this.computeTimeMax(slotId, interval) > Date.now() && data.timeout < Date.now() - (noRecalculate ? 5000 : 100000) && priority == 1) {

          this.request(serie, slotId, interval, priority, id, noProcess);
        }
      }
    }, {
      key: 'request',
      value: function request(serie, slotId, interval, priority, slotName, noProcess) {

        for (var i in this.requestLevels) {

          if (i == priority) {
            continue;
          }

          if (this.requestLevels[i][slotName]) {

            if (this.requestLevels[i][slotName][0] !== 1) {
              // If the request is not pending

              delete this.requestLevels[i][slotName];
            } else {
              this.requestLevels[i][slotName][5] = priority;
            }
          }
        }

        if (this.requestLevels[priority] && this.requestLevels[priority][slotName]) {
          return;
        }

        this.requestLevels[priority] = this.requestLevels[priority] || {};
        this.requestLevels[priority][slotName] = [0, slotName, serie.getName(), slotId, interval, priority, serie.getInfo('timeSerieManagerDBElements')];

        if (!noProcess) {
          this.processRequests();
        }
      }
    }, {
      key: 'processRequests',
      value: function processRequests() {

        if (this.requestsRunning >= this.options.maxParallelRequests) {
          return;
        }

        var self = this,
            currentLevelChecking = 1,
            requestToMake;

        while (true) {

          for (var i in this.requestLevels[currentLevelChecking]) {

            if (this.requestLevels[currentLevelChecking][i][0] == 1) {
              // Running request
              continue;
            }

            requestToMake = this.requestLevels[currentLevelChecking][i];
            break;
          }

          if (requestToMake) {
            break;
          }

          currentLevelChecking++;

          if (currentLevelChecking > 10) {
            return;
          }
        }

        this.requestsRunning++;

        if (!requestToMake) {
          return;
        }

        requestToMake[0] = 1;

        util.ajaxGet({

          url: this.getURL(requestToMake),
          method: 'GET',
          json: true

        }).done(function (data) {

          if (data.status == 1) {
            // Success

            self.requestsRunning--;

            delete self.requestLevels[currentLevelChecking][i];

            _graphLru2.default.store(self.options.LRUName, requestToMake[1], data.data); // Element 1 is the unique ID
            self.processRequests();

            if (requestToMake[5] == 1 && Object.keys(self.requestLevels[1]).length == 0) {

              self.recalculateSeries(true);
            }
          }
        });
      }
    }, {
      key: 'computeTimeMax',
      value: function computeTimeMax(slotId, interval) {
        return (slotId + 1) * (interval * this.options.nbPoints);
      }
    }, {
      key: 'computeTimeMin',
      value: function computeTimeMin(slotId, interval) {
        return slotId * (interval * this.options.nbPoints);
      }
    }, {
      key: 'getURL',
      value: function getURL(requestElements) {

        var url = this.options.url.replace('<measurementid>', requestElements[2]).replace('<from>', this.computeTimeMin(requestElements[3], requestElements[4])).replace('<to>', this.computeTimeMax(requestElements[3], requestElements[4])).replace('<interval>', requestElements[4]);

        var dbElements = requestElements[6] || {};

        for (var i in dbElements) {
          url = url.replace('<' + i + '>', dbElements[i]);
        }

        return url;
      }
    }, {
      key: 'getOptimalInterval',
      value: function getOptimalInterval(totalspan) {

        var optimalInterval = (this.options.optimalPxPerPoint || 1) * totalspan / this.graph.getDrawingWidth(),
            diff = Infinity,
            optimalIntervalAmongAvailable;

        this.options.intervals.forEach(function (interval) {

          var newDiff = Math.min(diff, Math.abs(interval - optimalInterval));
          if (diff !== newDiff) {

            optimalIntervalAmongAvailable = interval;
            diff = newDiff;
          }
        });

        return optimalIntervalAmongAvailable || 1000;
      }
    }, {
      key: 'computeUniqueID',
      value: function computeUniqueID(serie, slotId, interval) {
        var extra = '';
        var info = serie.getInfo('timeSerieManagerDBElements');
        for (var i in info) {
          extra += ';' + i + ':' + info[i];
        }

        return serie.getName() + ';' + slotId + ';' + interval + extra;
      }
    }, {
      key: 'computeSlotID',
      value: function computeSlotID(time, interval) {
        return Math.floor(time / (interval * this.options.nbPoints));
      }
    }, {
      key: 'computeSlotTime',
      value: function computeSlotTime(slotId, interval) {
        return slotId * (interval * this.options.nbPoints);
      }
    }, {
      key: 'getZoneSerie',
      value: function getZoneSerie(serie) {
        return serie._zoneSerie;
      }
    }, {
      key: 'updateZoneSerie',
      value: function updateZoneSerie(serieName) {

        var serie = this.graph.getSerie(serieName);

        if (!serie) {
          return;
        }

        if (!serie._zoneSerie) {
          return;
        }

        serie._zoneSerie.setXAxis(serie.getXAxis());
        serie._zoneSerie.setYAxis(serie.getYAxis());
        serie._zoneSerie.setFillColor(serie.getLineColor());
        serie._zoneSerie.setLineColor(serie.getLineColor());
        serie._zoneSerie.setFillOpacity(0.2);
        serie._zoneSerie.setLineOpacity(0.3);
      }
    }, {
      key: 'recalculateSeries',
      value: function recalculateSeries(force) {

        var self = this;

        if (this.locked) {
          return;
        }

        this.changed = false;

        this.series.map(function (serie) {
          self.recalculateSerie(serie, force);
        });

        /*if ( this.changed ) {
            self.graph._applyToAxes( "scaleToFitAxis", [ this.graph.getXAxis(), false, undefined, undefined, false, true ], false, true );
          }
        */
        this.changed = false;
        //self.graph.autoscaleAxes();

        self.graph.draw();
      }
    }, {
      key: 'recalculateSerie',
      value: function recalculateSerie(serie, force) {

        var from = serie.getXAxis().getCurrentMin(),
            to = serie.getXAxis().getCurrentMax(),
            interval = this.getOptimalInterval(to - from);

        var startSlotId = this.computeSlotID(from, interval);
        var endSlotId = this.computeSlotID(to, interval);

        var data = [];
        var dataMinMax = [];

        if (!force && interval == this.currentSlots[serie.getName()].interval && this.currentSlots[serie.getName()].min <= startSlotId && this.currentSlots[serie.getName()].max >= endSlotId) {
          return;
        }

        startSlotId -= 2;
        endSlotId += 2;

        this.currentSlots[serie.getName()].min = startSlotId;
        this.currentSlots[serie.getName()].max = endSlotId;
        this.currentSlots[serie.getName()].interval = interval;

        var slotId = startSlotId;

        while (slotId <= endSlotId) {

          var lruData = _graphLru2.default.get(this.options.LRUName, this.computeUniqueID(serie, slotId, interval));
          if (lruData) {

            data = data.concat(lruData.data.mean);
            dataMinMax = dataMinMax.concat(lruData.data.minmax);
          } else {

            this.recalculateSerieUpwards(serie, slotId, interval, data, dataMinMax);
          }

          slotId++;
        }

        this.changed = true;

        serie.setData(data);

        if (serie._zoneSerie) {
          serie._zoneSerie.setData(dataMinMax);
        }
      }
    }, {
      key: 'setIntervalCheck',
      value: function setIntervalCheck(interval) {
        var _this2 = this;

        if (this.interval) {
          clearInterval(this.interval);
        }

        this.update(true, true);
        this.interval = setInterval(function () {
          _this2.update(true, false);
        }, interval);
      }
    }, {
      key: 'recalculateSerieUpwards',
      value: function recalculateSerieUpwards(serie, downSlotId, downInterval, data, dataMinMax) {

        var intervals = this.options.intervals.slice(0);
        intervals.sort();

        var nextInterval = intervals[intervals.indexOf(downInterval) + 1] || -1;
        if (nextInterval < 0) {
          return [];
        }

        var newSlotTime = this.computeSlotTime(downSlotId, downInterval);
        var newSlotTimeEnd = this.computeSlotTime(downSlotId + 1, downInterval);
        var newSlotId = this.computeSlotID(newSlotTime, nextInterval),
            start = false;

        var lruData = _graphLru2.default.get(this.options.LRUName, this.computeUniqueID(serie, newSlotId, nextInterval));
        if (lruData) {

          for (var i = 0, l = lruData.data.mean.length; i < l; i += 2) {

            if (lruData.data.mean[i] < newSlotTime) {
              continue;
            } else if (start === false) {
              start = i;
            }

            if (lruData.data.mean[i] >= newSlotTimeEnd) {

              data = data.concat(lruData.data.mean.slice(start, i));
              dataMinMax = data.concat(lruData.data.minmax.slice(start, i));

              return;
            }
          }
        }

        return this.recalculateSerieUpwards(serie, newSlotId, nextInterval, data, dataMinMax);
      }
    }, {
      key: 'lockRedraw',
      value: function lockRedraw() {
        this.locked = true;
      }
    }, {
      key: 'unlockRedraw',
      value: function unlockRedraw() {
        this.locked = false;
      }
    }, {
      key: 'isRedrawLocked',
      value: function isRedrawLocked() {
        return !!this.locked;
      }
    }], [{
      key: 'default',
      value: function _default() {

        return {

          LRUName: 'PluginTimeSerieManager',
          intervals: [1000, 15000, 60000, 900000, 3600000, 8640000],
          maxParallelRequests: 3,
          optimalPxPerPoint: 2,
          nbPoints: 1000,
          url: ''
        };
      }
    }]);

    return PluginTimeSerieManager;
  }(_graphPlugin2.default);

  exports.default = PluginTimeSerieManager;
  module.exports = exports['default'];
});

/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(exports);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports);
    global.graphLru = mod.exports;
  }
})(this, function (exports) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.create = create;
  exports.get = get;
  exports.store = store;
  exports.empty = empty;
  exports.exist = exist;
  var memory = {},
      memoryHead = {},
      memoryCount = {},
      memoryLimit = {};

  function emptyMemory(store) {
    memory[store] = {};
    memoryCount[store] = 0;
  }

  function createStoreMemory(store, limit) {
    limit = limit || 50;
    if (!memory[store]) {
      memory[store] = {};
      memoryCount[store] = 0;
    }

    memoryLimit[store] = limit;
  }

  function getFromMemory(store, index) {
    var obj, head;

    if (memory[store] && memory[store][index]) {

      head = memoryHead[store];

      obj = memory[store][index];
      obj.prev = head;
      obj.next = head.next;
      head.next.prev = obj;
      head.next = obj;

      memoryHead[store] = obj;
      return obj.data;
    }
  }

  function storeInMemory(store, index, data) {

    var toStore, toDelete, head;
    if (memory[store] && memoryCount[store] !== undefined && memoryLimit[store]) {
      head = memoryHead[store];

      if (memory[store][index]) {

        getFromMemory(store, index);
        memory[store][index].data.data = data;
        memory[store][index].data.timeout = Date.now();
      } else {

        toStore = {
          data: {
            data: data,
            timeout: Date.now()
          }
        };

        if (typeof head == 'undefined') {
          toStore.prev = toStore;
          toStore.next = toStore;
        } else {
          toStore.prev = head.prev;
          toStore.next = head.next;
          head.next.prev = toStore;
          head.next = toStore;
        }

        memoryHead[store] = toStore;
        memory[store][index] = toStore;
        memoryCount[store]++;
      }

      // Remove oldest one
      if (memoryCount[store] > memoryLimit[store] && head) {
        toDelete = head.next;
        head.next.next.prev = head;
        head.next = head.next.next;
        toDelete.next.next = undefined;
        toDelete.next.prev = undefined;
        memoryCount[store]--;
      }

      return data;
    }
  }

  function create(store, limitMemory) {
    createStoreMemory(store, limitMemory);
  }

  function get(store, index) {
    var result;
    if ((result = getFromMemory(store, index)) != undefined) {
      return result;
    }
  }

  function store(store, index, value) {
    storeInMemory(store, index, value);
    return value;
  }

  function empty(store) {
    emptyMemory(store);
  }

  function exist(store) {
    return memory[store];
  }

  exports.default = get;
});

/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(29)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('./graph.plugin.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphPlugin);
    global.graphPluginSerielinedifference = mod.exports;
  }
})(this, function (module, exports, _graphPlugin) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _graphPlugin2 = _interopRequireDefault(_graphPlugin);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var PluginSerieLineDifference = function (_Plugin) {
    _inherits(PluginSerieLineDifference, _Plugin);

    function PluginSerieLineDifference() {
      _classCallCheck(this, PluginSerieLineDifference);

      return _possibleConstructorReturn(this, (PluginSerieLineDifference.__proto__ || Object.getPrototypeOf(PluginSerieLineDifference)).apply(this, arguments));
    }

    _createClass(PluginSerieLineDifference, [{
      key: 'init',
      value: function init(graph, options) {
        this.graph = graph;

        this.pathsPositive = [];
        this.pathsNegative = [];

        this.positivePolyline = this.graph.newShape('polyline').draw();

        this.positivePolyline.setFillColor(this.options.positiveStyle.fillColor).setFillOpacity(this.options.positiveStyle.fillOpacity).setStrokeWidth(this.options.positiveStyle.strokeWidth).applyStyle();

        this.negativePolyline = this.graph.newShape('polyline').draw();

        this.negativePolyline.setFillColor(this.options.negativeStyle.fillColor).setFillOpacity(this.options.negativeStyle.fillOpacity).setStrokeWidth(this.options.negativeStyle.strokeWidth).applyStyle();
      }
    }, {
      key: 'setSeries',
      value: function setSeries(serieTop, serieBottom) {
        this.serie1 = serieTop;
        this.serie2 = serieBottom;
      }
    }, {
      key: 'setBoundaries',
      value: function setBoundaries(from, to) {
        this.options.from = from;
        this.options.to = to;
      }
    }, {
      key: 'getFrom',
      value: function getFrom() {
        return this.options.from;
      }
    }, {
      key: 'getTo',
      value: function getTo() {
        return this.options.to;
      }
    }, {
      key: 'draw',
      value: function draw() {

        var self = this;
        var s1 = this.serie1.searchClosestValue(this.getFrom());
        var i1, j1, i2, j2, y, y2, crossing;

        var top = [];
        var bottom = [];

        var bottomBroken;

        if (!s1) {
          i1 = 0;
          j1 = 0;
        } else {

          i1 = s1.dataIndex;
          j1 = s1.xAfterIndex * 2;
        }

        y = this.interpolate(this.serie1, this.getFrom());
        top.push(this.getFrom()); // x
        top.push(y); // y

        y = this.interpolate(this.serie2, this.getFrom());
        bottom.push(this.getFrom()); // x
        bottom.push(y); // y

        var s2;

        var order;

        function nextSet() {

          if (order === true) {
            self.pathsPositive.push([top, bottom]);
          } else if (order === false) {
            self.pathsNegative.push([top, bottom]);
          }

          top = [];
          bottom = [];
          order = undefined;
        }
        var ended;
        for (; i1 < this.serie1.data.length; i1++) {

          for (; j1 < this.serie1.data[i1].length; j1 += 2) {

            if (this.serie1.data[i1][j1] > this.getTo()) {
              // FINISHED !

              y = this.interpolate(this.serie1, this.getTo());
              y2 = this.interpolate(this.serie2, this.getTo());

              crossing = this.computeCrossing(top[top.length - 2], top[top.length - 1], this.getTo(), y, bottom[bottom.length - 2], bottom[bottom.length - 1], this.getTo(), y2);

              if (crossing) {

                top.push(crossing.x);
                top.push(crossing.y);
                bottom.push(crossing.x);
                bottom.push(crossing.y);
                nextSet();
                top.push(crossing.x);
                top.push(crossing.y);
                bottom.push(crossing.x);
                bottom.push(crossing.y);

                order = this.serie1.data[i1][j1 + 1] > this.serie2.data[i2][j2 + 1];
              }

              top.push(this.getTo()); // x
              top.push(y); // y

              bottom.push(this.getTo()); // x
              bottom.push(y2); // y

              ended = true;
              break;
            }

            if (!s2) {
              s2 = this.serie2.searchClosestValue(this.serie1.data[i1][j1]); // Finds the first point

              if (s2) {
                i2 = s2.dataIndex;
                j2 = s2.xBeforeIndex * 2;

                // TODO: Add here first points

                y = this.interpolate(this.serie2, this.serie1.data[i1][j1]);

                top.push(this.serie1.data[i1][j1]); // x
                top.push(this.serie1.data[i1][j1 + 1]); // y

                bottom.push(this.serie1.data[i1][j1]); // x
                bottom.push(y); // y

                order = this.serie1.data[i1][j1 + 1] > y;
              } else {
                continue;
              }
            }

            bottomBroken = false;

            crossing = this.computeCrossing(top[top.length - 2], top[top.length - 1], this.serie1.data[i1][j1], this.serie1.data[i1][j1 + 1], bottom[bottom.length - 2], bottom[bottom.length - 1], this.serie2.data[i2][j2], this.serie2.data[i2][j2 + 1]);

            if (crossing) {

              top.push(crossing.x);
              top.push(crossing.y);
              bottom.push(crossing.x);
              bottom.push(crossing.y);
              nextSet();
              top.push(crossing.x);
              top.push(crossing.y);
              bottom.push(crossing.x);
              bottom.push(crossing.y);

              order = this.serie1.data[i1][j1 + 1] > this.serie2.data[i2][j2 + 1];
            }

            while (this.serie2.data[i2][j2] < this.serie1.data[i1][j1]) {

              bottom.push(this.serie2.data[i2][j2]);
              bottom.push(this.serie2.data[i2][j2 + 1]);

              j2 += 2;
              if (j2 == this.serie2.data[i2].length) {
                bottomBroken = this.serie2.data[i2][j2 - 2];
                i2++;
                j2 = 0;
                break;
              }

              crossing = this.computeCrossing(top[top.length - 2], top[top.length - 1], this.serie1.data[i1][j1], this.serie1.data[i1][j1 + 1], bottom[bottom.length - 2], bottom[bottom.length - 1], this.serie2.data[i2][j2], this.serie2.data[i2][j2 + 1]);

              if (crossing) {

                top.push(crossing.x);
                top.push(crossing.y);
                bottom.push(crossing.x);
                bottom.push(crossing.y);
                nextSet();
                top.push(crossing.x);
                top.push(crossing.y);
                bottom.push(crossing.x);
                bottom.push(crossing.y);

                order = this.serie1.data[i1][j1 + 1] > this.serie2.data[i2][j2 + 1];
              }
            }

            if (bottomBroken === false) {
              top.push(this.serie1.data[i1][j1]);
              top.push(this.serie1.data[i1][j1 + 1]);
            } else {

              top.push(bottomBroken);
              top.push(this.interpolate(this.serie1, bottomBroken));

              s2 = false;
              j1 -= 2;
              nextSet();
            }
          }

          if (ended) {
            nextSet();
            break;
          }
          // End of X

          y = this.interpolate(this.serie2, top[top.length - 2]);
          if (y) {
            bottom.push(top[top.length - 2]);
            bottom.push(y);
          }

          nextSet();

          j1 = 0;
          s2 = false;
        }

        var d = this.pathsPositive.reduce(makePaths, '');
        this.positivePolyline.setPointsPx(d).redraw();

        var d = this.pathsNegative.reduce(makePaths, '');
        this.negativePolyline.setPointsPx(d).redraw();

        //pathsBottom.map( function( map ) { makePaths( map, self.options.negativeStyle ); } );

        function makePaths(d, path) {

          for (var i = 0; i < path[0].length; i += 2) {
            if (i == 0) {
              d += 'M ';
            }
            d += ' ' + Math.round(self.serie1.getXAxis().getPx(path[0][i])) + ', ' + Math.round(self.serie1.getYAxis().getPx(path[0][i + 1]));
            if (i < path[0].length - 2) {
              d += ' L ';
            }
          }

          for (var i = path[1].length - 2; i >= 0; i -= 2) {
            d += ' L ' + Math.round(self.serie2.getXAxis().getPx(path[1][i])) + ', ' + Math.round(self.serie2.getYAxis().getPx(path[1][i + 1]));
            if (i == 0) {
              d += ' z ';
            }
          }
          return d;
        }
      }
    }, {
      key: 'interpolate',
      value: function interpolate(serie, valX) {

        var value = serie.searchClosestValue(valX);

        if (!value) {
          return false;
        }

        if (value.xMax == undefined) {
          return value.yMin;
        }

        if (value.xMin == undefined) {
          return value.yMax;
        }

        var ratio = (valX - value.xMin) / (value.xMax - value.xMin);
        return (1 - ratio) * value.yMin + ratio * value.yMax;
      }
    }, {
      key: 'computeCrossing',
      value: function computeCrossing(x11, y11, x12, y12, x21, y21, x22, y22) {
        var a1 = (y12 - y11) / (x12 - x11);
        var a2 = (y22 - y21) / (x22 - x21);

        var b1 = y12 - a1 * x12;
        var b2 = y22 - a2 * x22;

        if (x11 == x12 || x21 == x22) {

          return false;
        }

        if (a1 == a2) {
          return {
            x: x11,
            y1: y11,
            y2: y11
          };
        }

        var x = (b1 - b2) / (a2 - a1);

        if (x > x12 || x < x11 || x < x21 || x > x22) {
          return false;
        }

        return {
          x: x,
          y: a1 * x + b1
        };
      }
    }, {
      key: 'getPositivePolyline',
      value: function getPositivePolyline() {
        return this.positivePolyline;
      }
    }, {
      key: 'getNegativePolyline',
      value: function getNegativePolyline() {
        return this.negativePolyline;
      }
    }], [{
      key: 'default',
      value: function _default() {
        return {

          positiveStyle: {

            fillColor: 'green',
            fillOpacity: 0.2,
            strokeWidth: 0
          },

          negativeStyle: {
            fillColor: 'red',
            fillOpacity: 0.2,
            strokeWidth: 0
          },

          from: 0,
          to: 0
        };
      }
    }]);

    return PluginSerieLineDifference;
  }(_graphPlugin2.default);

  exports.default = PluginSerieLineDifference;
  module.exports = exports['default'];
});

/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(45), __webpack_require__(101), __webpack_require__(139), __webpack_require__(5), __webpack_require__(51), __webpack_require__(141), __webpack_require__(73), __webpack_require__(29)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('../graph.core.js'), require('../graph.axis.x.js'), require('../graph.axis.y.js'), require('../graph.util.js'), require('../series/graph.serie.line.js'), require('../series/graph.serie.scatter.js'), require('../graph.axis.js'), require('./graph.plugin.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphCore, global.graphAxisX, global.graphAxisY, global.graphUtil, global.graphSerieLine, global.graphSerieScatter, global.graphAxis, global.graphPlugin);
    global.graphPluginAxissplitting = mod.exports;
  }
})(this, function (module, exports, _graphCore, _graphAxisX, _graphAxisY, _graphUtil, _graphSerieLine, _graphSerieScatter, _graphAxis, _graphPlugin) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _graphCore2 = _interopRequireDefault(_graphCore);

  var _graphAxisX2 = _interopRequireDefault(_graphAxisX);

  var _graphAxisY2 = _interopRequireDefault(_graphAxisY);

  var util = _interopRequireWildcard(_graphUtil);

  var _graphSerieLine2 = _interopRequireDefault(_graphSerieLine);

  var _graphSerieScatter2 = _interopRequireDefault(_graphSerieScatter);

  var _graphAxis2 = _interopRequireDefault(_graphAxis);

  var _graphPlugin2 = _interopRequireDefault(_graphPlugin);

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    } else {
      return Array.from(arr);
    }
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var SerieLineExtended = function (_SerieLine) {
    _inherits(SerieLineExtended, _SerieLine);

    function SerieLineExtended() {
      _classCallCheck(this, SerieLineExtended);

      var _this = _possibleConstructorReturn(this, (SerieLineExtended.__proto__ || Object.getPrototypeOf(SerieLineExtended)).apply(this, arguments));

      _this.subSeries = [];
      return _this;
    }

    _createClass(SerieLineExtended, [{
      key: 'draw',
      value: function draw() {
        this.eraseMarkers();
        return this;
      }
    }, {
      key: 'getSymbolForLegend',
      value: function getSymbolForLegend() {
        if (!this.subSeries[0]) {
          return false;
        }

        return this.subSeries[0].getSymbolForLegend();
      }
    }, {
      key: 'getMarkerForLegend',
      value: function getMarkerForLegend() {
        if (!this.subSeries[0]) {
          return false;
        }

        return this.subSeries[0].getMarkerForLegend();
      }
    }]);

    return SerieLineExtended;
  }(_graphSerieLine2.default);

  var SerieScatterExtended = function (_SerieScatter) {
    _inherits(SerieScatterExtended, _SerieScatter);

    function SerieScatterExtended() {
      _classCallCheck(this, SerieScatterExtended);

      var _this2 = _possibleConstructorReturn(this, (SerieScatterExtended.__proto__ || Object.getPrototypeOf(SerieScatterExtended)).apply(this, arguments));

      _this2.subSeries = [];
      return _this2;
    }

    _createClass(SerieScatterExtended, [{
      key: 'draw',
      value: function draw() {
        return this;
      }
    }, {
      key: 'getSymbolForLegend',
      value: function getSymbolForLegend() {
        if (!this.subSeries[0]) {
          return false;
        }

        return this.subSeries[0].getSymbolForLegend();
      }
    }, {
      key: 'getMarkerForLegend',
      value: function getMarkerForLegend() {
        if (!this.subSeries[0]) {
          return false;
        }

        return this.subSeries[0].getMarkerForLegend();
      }
    }]);

    return SerieScatterExtended;
  }(_graphSerieScatter2.default);

  var excludingMethods = ['constructor', 'init', 'draw', 'setLineColor', 'setLineWidth', 'setLineStyle', 'getLineColor', 'getLineWidth', 'getLineStyle', 'setMarkers', 'showMarkers', 'hideMarkers', 'getMarkerDom', 'getMarkerDomIndependant', 'getMarkerPath', 'eraseMarkers', '_recalculateMarkerPoints'];
  var addMethods = [];

  Object.getOwnPropertyNames(_graphSerieLine2.default.prototype).concat(addMethods).map(function (i) {

    if (excludingMethods.indexOf(i) > -1) {
      return;
    }

    SerieLineExtended.prototype[i] = function (j) {

      return function () {

        var args = arguments;
        this.subSeries.map(function (subSerie) {
          console.log(j);
          subSerie[j].apply(subSerie, _toConsumableArray(args));
        });
      };
    }(i);
  });

  /**
   * Axis splitting plugin
   * @augments Plugin
   */

  var PluginAxisSplitting = function (_Plugin) {
    _inherits(PluginAxisSplitting, _Plugin);

    function PluginAxisSplitting(options) {
      _classCallCheck(this, PluginAxisSplitting);

      var _this3 = _possibleConstructorReturn(this, (PluginAxisSplitting.__proto__ || Object.getPrototypeOf(PluginAxisSplitting)).apply(this, arguments));

      _this3.series = new Map();
      return _this3;
    }

    _createClass(PluginAxisSplitting, [{
      key: 'init',
      value: function init(graph) {
        this.graph = graph;
      }
    }, {
      key: 'newXAxis',
      value: function newXAxis(options) {
        return this.newBottomAxis(options);
      }
    }, {
      key: 'newYAxis',
      value: function newYAxis(options) {
        return this.newLeftAxis(options);
      }
    }, {
      key: 'newTopAxis',
      value: function newTopAxis(options) {
        options = this.getOptions(options);
        return new SplitXAxis(this.graph, 'top', options);
      }
    }, {
      key: 'newBottomAxis',
      value: function newBottomAxis(options) {
        options = this.getOptions(options);
        return new SplitXAxis(this.graph, 'bottom', options);
      }
    }, {
      key: 'newLeftAxis',
      value: function newLeftAxis(options) {
        options = this.getOptions(options);
        return new SplitYAxis(this.graph, 'left', options);
      }
    }, {
      key: 'newRightAxis',
      value: function newRightAxis(options) {
        options = this.getOptions(options);
        return new SplitYAxis(this.graph, 'right', options);
      }
    }, {
      key: 'getOptions',
      value: function getOptions(options) {
        var defaults = {
          marginMin: this.options.axes.margins.low,
          marginMax: this.options.axes.margins.high
        };
        return util.extend(true, defaults, options);
      }
    }, {
      key: 'preDraw',
      value: function preDraw() {
        var _this4 = this;

        var xAxis, yAxis;

        //    for ( let { serie } of this.series.values() ) {
        this.series.forEach(function (_ref) {
          var serie = _ref.serie;


          xAxis = serie.getXAxis();
          yAxis = serie.getYAxis();

          var splits = 1;

          if (xAxis.splitNumber) {
            splits *= xAxis.splitNumber;
          }

          if (yAxis.splitNumber) {
            splits *= yAxis.splitNumber;
          }

          while (serie.subSeries.length < splits) {

            var name = serie.getName() + '_' + serie.subSeries.length;

            var s = _this4.graph.newSerie(name, {}, serie.getType() || _graphCore2.default.SERIE_LINE);

            s.excludedFromLegend = true;
            s.styles = serie.styles;
            s.waveform = serie.waveform; // Copy data

            if (serie.getType() == _graphCore2.default.SERIE_LINE) {
              s.markerPoints = serie.markerPoints;
              s.markerFamilies = serie.markerFamilies;
            }

            serie.subSeries.push(s);
            serie.postInit();
          }

          while (serie.subSeries.length > splits) {

            var subserie = _this4.graph.getSerie(serie.getName() + '_' + (serie.subSeries.length - 1));

            if (subserie && subserie.kill) {
              subserie.kill();
            }
            serie.subSeries.pop();
          }

          if (!serie.getXAxis().splitNumber && serie.getXAxis().splitAxis) {
            serie.getXAxis().splitAxis();
          }

          if (!serie.getYAxis().splitNumber && serie.getYAxis().splitAxis) {
            serie.getYAxis().splitAxis();
          }

          // Re-assign axes to the sub series
          serie.subSeries.map(function (sserie, index) {

            var xSubAxis, ySubAxis;

            //sserie.groupMarkers = firstSubSerie.groupMarkers;

            if (serie.getXAxis().getSubAxis) {
              var subAxisIndex = index % (xAxis.splitNumber || 1);
              xSubAxis = serie.getXAxis().getSubAxis(subAxisIndex);
            } else {
              xSubAxis = serie.getXAxis();
            }

            sserie.setXAxis(xSubAxis);

            if (serie.getYAxis().getSubAxis) {

              var _subAxisIndex = Math.floor(index / (xAxis.splitNumber || 1));
              ySubAxis = serie.getYAxis().getSubAxis(_subAxisIndex);
            } else {
              ySubAxis = serie.getYAxis();
            }

            sserie.setYAxis(ySubAxis);

            sserie.draw(true);
          });
          //}
        });
      }
    }, {
      key: 'newSerie',
      value: function newSerie(name) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var type = arguments[2];


        switch (type) {

          case 'line':
            return this.newLineSerie(name, options);
            break;

          case 'scatter':
            return this.newScatterSerie(name, options);
            break;
        }

        throw 'Cannot create a split serie of type ' + type;
      }
    }, {
      key: 'newLineSerie',
      value: function newLineSerie(name, options) {
        var serieObj = {
          type: 'lineSerie',
          serie: new SerieLineExtended(this.graph, name, options, 'line')
        };
        this.series.set(name, serieObj);
        this.graph.series.push(serieObj.serie);
        return serieObj.serie;
      }
    }, {
      key: 'newScatterSerie',
      value: function newScatterSerie(name, options) {
        var serieObj = {
          type: 'scatterSerie',
          serie: new SerieScatterExtended(this.graph, name, options, 'scatter')
        };
        this.series.set(name, serieObj);
        this.graph.series.push(serieObj.serie);
        return serieObj.serie;
      }
    }], [{
      key: 'default',
      value: function _default() {

        return {
          axes: {
            margins: {
              high: 5,
              low: 5
            }
          }
        };
      }
    }]);

    return PluginAxisSplitting;
  }(_graphPlugin2.default);

  var defaultAxisConstructorOptions = {
    splitMarks: true
  };

  var SplitAxis = function SplitAxis(mixin) {

    var delegateMethods = ['turnGridsOff', 'turnGridsOn', 'gridsOff', 'gridsOn', 'setEngineering', 'setScientificScaleExponent', 'setScientific', 'setLabelColor', 'setSecondaryGridDasharray', 'setPrimaryGridDasharray', 'setSecondaryGridsOpacity', 'setPrimaryGridOpacity', 'setSecondaryGridWidth', 'setPrimaryGridWidth', 'setSecondaryGridColor', 'setPrimaryGridColor', 'setTicksLabelColor', 'setSecondaryTicksColor', 'setPrimaryTicksColor', 'setAxisColor', 'secondaryGridOn', 'secondaryGridOff', 'primaryGridOff', 'primaryGridOn', 'setSecondaryGrid', 'setPrimaryGrid', 'setGrids', 'setTickPosition', 'setExponentialFactor', 'setExponentialLabelFactor', 'setGridLinesStyle', 'forcePrimaryTickUnitMin', 'forcePrimaryTickUnitMax', 'forcePrimaryTickUnit', 'flip', 'show', 'hide', 'setDisplay'];

    /**
     * Split axis
     * @mixes AxisX
     * @mixes AxisY
     * @name SplitAxis
     * @static
     */
    var cl = function (_mixin) {
      _inherits(SplitAxis, _mixin);

      function SplitAxis(graph, position) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        _classCallCheck(this, SplitAxis);

        var _this5 = _possibleConstructorReturn(this, (SplitAxis.__proto__ || Object.getPrototypeOf(SplitAxis)).call(this, graph, position, options));

        _this5.axes = [];
        _this5.position = position;
        _this5.constructorOptions = util.extend(true, {}, defaultAxisConstructorOptions, options);

        _this5._splitVal = [];
        return _this5;
      }

      /**
       *  Calls a callback onto each chunk axes. The callback receives two parameters: 1) the ```axis``` itself and 2) the ```index``` of the axis in the stack
       *  @param {Function} callback - The callback to be applied to each axes
       *  @return {SplitAxis} The current axis instance
       */


      _createClass(SplitAxis, [{
        key: 'all',
        value: function all(callback) {

          if (!(typeof callback == 'function')) {
            return;
          }

          this.axes.map(callback);
          return this;
        }
      }, {
        key: 'splitAxis',
        value: function splitAxis() {
          for (var _len = arguments.length, splits = Array(_len), _key = 0; _key < _len; _key++) {
            splits[_key] = arguments[_key];
          }

          splits.push(1);
          var splitNumber = splits.length;

          while (this.axes.length > splitNumber) {
            this.axes.pop().kill(true, true);
          }

          while (this.axes.length < splitNumber) {
            var axis = new (this.getConstructor())(this.graph, this.position, this.constructorOptions);
            this.axes.push(axis);
            axis.zoomLock = true;
            axis.init(this.graph, this.constructorOptions);
          }

          var from = 0;
          var i = 0;
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = this.axes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _axis = _step.value;


              _axis.options.marginMin = 10;
              _axis.options.marginMax = 10;

              if (i == 0) {
                _axis.options.marginMin = 0;
              }

              if (i == this.axes.length - 1) {
                _axis.options.marginMax = 0;
              }

              _axis.setSpan(from, from = splits[i]);
              _axis.setMinMaxFlipped();
              i++;
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          this._splits = splits;
          return this;
        }
      }, {
        key: 'fixGridIntervalBasedOnAxis',
        value: function fixGridIntervalBasedOnAxis(axisIndex) {

          this.fixGridFor = axisIndex;
          this.graph._axisHasChanged();
          return this;
        }
      }, {
        key: 'splitSpread',
        value: function splitSpread(bln) {
          this.autoSpread = !!bln;
          return this;
        }
      }, {
        key: 'hasAxis',
        value: function hasAxis(axis) {
          return this.axes.indexOf(axis) > -1;
        }
      }, {
        key: '_splitSpread',
        value: function _splitSpread() {

          var splits = [],
              total = 0,
              currentSplit = 0;
          //console.log( this._splitVal );
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = this._splitVal[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var split = _step2.value;

              total += split[1] - split[0];
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = this._splitVal[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _split = _step3.value;


              splits.push(currentSplit += (_split[1] - _split[0]) / total);
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }

          splits.pop();
          this.splitAxis.apply(this, splits);
        }
      }, {
        key: 'setChunkBoundaries',
        value: function setChunkBoundaries(values) {

          var index = 0,
              baseWidth = void 0,
              baseWidthIndex = void 0;

          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = this.axes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var axis = _step4.value;
              // List all axes

              // Two elements in the array => becomes the new reference
              if (Array.isArray(values[index]) && values[index].length > 1 && !baseWidth) {
                baseWidth = values[index][1] - values[index][0];
                baseWidthIndex = index;
              }

              if (values[index].length == 1 || !Array.isArray(values[index])) {
                axis._mean = values[index];

                if (Array.isArray(axis._mean)) {
                  axis._mean = axis._mean[0];
                }
              } else {

                axis.forceMin(values[index][0]).forceMax(values[index][1]);
              }

              index++;
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4.return) {
                _iterator4.return();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }

          this._baseWidthVal = baseWidth;
          this._baseWidthIndex = baseWidthIndex;

          this._splitVal = values;

          this.graph._axisHasChanged();

          return this;
        }
      }, {
        key: 'setMinMaxToFitSeries',
        value: function setMinMaxToFitSeries() {

          if (!this._splitVal || this._splitVal.length < 1) {
            _get(SplitAxis.prototype.__proto__ || Object.getPrototypeOf(SplitAxis.prototype), 'setMinMaxToFitSeries', this).apply(this, arguments);
            this._splitVal[0] = this._splitVal[0] || [];
            this._splitVal[this._splitVal.length - 1] = this._splitVal[this._splitVal.length - 1] || [];

            this._splitVal[0][0] = this.getCurrentMin();
            this._splitVal[this._splitVal.length - 1][1] = this.getCurrentMax();
            this.setChunkBoundaries(this._splitVal);
          }
        }
      }, {
        key: 'draw',
        value: function draw() {
          var _this6 = this;

          if (this.autoSpread) {
            this._splitSpread();
          }

          var max = 0;
          var unit = void 0;
          var subAxis = void 0;
          var spanReference = void 0;

          if (this._baseWidthIndex >= 0 && (subAxis = this.getSubAxis(this._baseWidthIndex))) {
            spanReference = subAxis.getSpan();
          }

          subAxis = undefined;

          if (this.fixGridFor >= 0 && (subAxis = this.getSubAxis(this.fixGridFor))) {

            if (subAxis._mean !== undefined) {
              var width = (subAxis.getSpan()[1] - subAxis.getSpan()[0]) / (spanReference[1] - spanReference[0]) * this._baseWidthVal;
              subAxis.forceMin(subAxis._mean - width / 2);
              subAxis.forceMax(subAxis._mean + width / 2);
            }

            max = subAxis.draw();
            unit = subAxis.getPrimaryTickUnit();
          }

          this.axes.map(function (axis) {

            if (subAxis === axis) {
              return;
            }

            if (axis._mean !== undefined) {
              var _width = (axis.getSpan()[1] - axis.getSpan()[0]) / (spanReference[1] - spanReference[0]) * _this6._baseWidthVal;
              axis.forceMin(axis._mean - _width / 2);
              axis.forceMax(axis._mean + _width / 2);
            }

            if (unit) {
              axis.forcePrimaryTickUnit(unit);
            }

            max = Math.max(max, axis.draw());
          });

          //    this.drawLabel();
          this.writeUnit();

          return max;
        }
      }, {
        key: 'setMinPx',
        value: function setMinPx(min) {

          _get(SplitAxis.prototype.__proto__ || Object.getPrototypeOf(SplitAxis.prototype), 'setMinPx', this).call(this, min);
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = this.axes[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var axis = _step5.value;

              axis.setMinPx(min);
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5.return) {
                _iterator5.return();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }
        }
      }, {
        key: 'setMaxPx',
        value: function setMaxPx(max) {

          _get(SplitAxis.prototype.__proto__ || Object.getPrototypeOf(SplitAxis.prototype), 'setMaxPx', this).call(this, max);

          var _iteratorNormalCompletion6 = true;
          var _didIteratorError6 = false;
          var _iteratorError6 = undefined;

          try {
            for (var _iterator6 = this.axes[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
              var axis = _step6.value;

              axis.setMaxPx(max);
            }
          } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion6 && _iterator6.return) {
                _iterator6.return();
              }
            } finally {
              if (_didIteratorError6) {
                throw _iteratorError6;
              }
            }
          }
        }
      }, {
        key: 'setShift',
        value: function setShift() {

          _get(SplitAxis.prototype.__proto__ || Object.getPrototypeOf(SplitAxis.prototype), 'setShift', this).apply(this, arguments);

          var _iteratorNormalCompletion7 = true;
          var _didIteratorError7 = false;
          var _iteratorError7 = undefined;

          try {
            for (var _iterator7 = this.axes[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
              var axis = _step7.value;

              axis.setShift.apply(axis, arguments);
            }
          } catch (err) {
            _didIteratorError7 = true;
            _iteratorError7 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion7 && _iterator7.return) {
                _iterator7.return();
              }
            } finally {
              if (_didIteratorError7) {
                throw _iteratorError7;
              }
            }
          }
        }
      }, {
        key: 'init',
        value: function init() {
          _get(SplitAxis.prototype.__proto__ || Object.getPrototypeOf(SplitAxis.prototype), 'init', this).apply(this, arguments);
          this.splitAxis();
        }
      }, {
        key: 'getAxisPosition',
        value: function getAxisPosition() {
          var max = 0;

          this.axes.map(function (axis) {
            max = Math.max(max, axis.getAxisPosition());
          });

          return max;
        }
      }, {
        key: 'getSubAxis',
        value: function getSubAxis(index) {

          if (this.axes.length <= index) {
            throw 'Impossible to reach axis. Index ' + index + ' is out of range';
          }

          return this.axes[index];
        }
      }, {
        key: 'splitNumber',
        get: function get() {
          return this._splits.length;
        }
      }]);

      return SplitAxis;
    }(mixin);

    delegateMethods.map(function (methodName) {

      cl.prototype[methodName] = function (method) {

        return function () {
          var _arguments = arguments;

          //super[ method ]( ...arguments )

          this.axes.map(function (axis) {
            axis[method].apply(axis, _arguments);
          });
          return this;
        };
      }(methodName);
    });

    return cl;
  };

  var SplitXAxis = function (_SplitAxis) {
    _inherits(SplitXAxis, _SplitAxis);

    function SplitXAxis(graph, topbottom, options) {
      _classCallCheck(this, SplitXAxis);

      var _this7 = _possibleConstructorReturn(this, (SplitXAxis.__proto__ || Object.getPrototypeOf(SplitXAxis)).apply(this, arguments));

      _this7.topbottom = topbottom;
      return _this7;
    }

    _createClass(SplitXAxis, [{
      key: 'getConstructor',
      value: function getConstructor() {
        return _graphAxisX2.default;
      }
    }, {
      key: 'getAxisPosition',
      value: function getAxisPosition() {
        var max = _get(SplitXAxis.prototype.__proto__ || Object.getPrototypeOf(SplitXAxis.prototype), 'getAxisPosition', this).apply(this, arguments);

        this.labelPosY = max;

        if (this.getLabel()) {
          max += this.graph.options.fontSize;
        }

        return max;
      }
    }, {
      key: 'drawLabel',
      value: function drawLabel() {
        _get(SplitXAxis.prototype.__proto__ || Object.getPrototypeOf(SplitXAxis.prototype), 'drawLabel', this).call(this);
        this.label.setAttribute('y', (this.top ? -1 : 1) * (this.graph.options.fontSize + this.labelPosY));
      }
    }, {
      key: 'draw',
      value: function draw() {
        var height = _get(SplitXAxis.prototype.__proto__ || Object.getPrototypeOf(SplitXAxis.prototype), 'draw', this).apply(this, arguments);
        this.drawLabel();
        return height;
      }
    }]);

    return SplitXAxis;
  }(SplitAxis(_graphAxisX2.default));

  var SplitYAxis = function (_SplitAxis2) {
    _inherits(SplitYAxis, _SplitAxis2);

    function SplitYAxis(graph, leftright, options) {
      _classCallCheck(this, SplitYAxis);

      return _possibleConstructorReturn(this, (SplitYAxis.__proto__ || Object.getPrototypeOf(SplitYAxis)).apply(this, arguments));
    }

    _createClass(SplitYAxis, [{
      key: 'getConstructor',
      value: function getConstructor() {
        return _graphAxisY2.default;
      }
    }, {
      key: 'drawLabel',
      value: function drawLabel() {
        _get(SplitYAxis.prototype.__proto__ || Object.getPrototypeOf(SplitYAxis.prototype), 'drawLabel', this).call(this);
      }
    }, {
      key: 'equalizePosition',
      value: function equalizePosition(width) {

        var widthAfter = width;

        if (this.getLabel()) {
          this.axes.map(function (axis) {
            widthAfter = Math.max(axis.equalizePosition(width), widthAfter);
          }); // Extra shift allowed for the label
          //this.setShift( this.graph.options.fontSize );
        }

        if (this.getLabel()) {
          this.placeLabel(this.left ? -widthAfter : widthAfter);
          return widthAfter + this.graph.options.fontSize;
        }
      }
    }]);

    return SplitYAxis;
  }(SplitAxis(_graphAxisY2.default));

  util.mix(SplitXAxis, new _graphAxisX2.default());
  util.mix(SplitYAxis, new _graphAxisY2.default());

  exports.default = PluginAxisSplitting;
  module.exports = exports['default'];
});

/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(5), __webpack_require__(29)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('../graph.util.js'), require('./graph.plugin.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphUtil, global.graphPlugin);
    global.graphPluginMakeTracesDifferent = mod.exports;
  }
})(this, function (module, exports, _graphUtil, _graphPlugin) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var util = _interopRequireWildcard(_graphUtil);

  var _graphPlugin2 = _interopRequireDefault(_graphPlugin);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    } else {
      return Array.from(arr);
    }
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var PluginMakeTracesDifferent = function (_Plugin) {
    _inherits(PluginMakeTracesDifferent, _Plugin);

    function PluginMakeTracesDifferent() {
      _classCallCheck(this, PluginMakeTracesDifferent);

      return _possibleConstructorReturn(this, (PluginMakeTracesDifferent.__proto__ || Object.getPrototypeOf(PluginMakeTracesDifferent)).apply(this, arguments));
    }

    _createClass(PluginMakeTracesDifferent, [{
      key: 'init',
      value: function init(graph, options) {
        _get(PluginMakeTracesDifferent.prototype.__proto__ || Object.getPrototypeOf(PluginMakeTracesDifferent.prototype), 'init', this).call(this, graph, options);
      }
    }, {
      key: 'checkHSL',
      value: function checkHSL(color) {

        var result = {},
            hue = void 0,
            saturation = void 0,
            lightness = void 0;

        if (hue = color.h || color.hue) {

          if (hue < 1) {
            hue = Math.round(hue * 360);
          }

          result.hue = hue;
        } else {
          result.h = 0;
        }

        if (saturation = color.s || color.saturation) {

          if (saturation > 1) {
            saturation /= 100;
          }

          result.saturation = saturation;
        } else {
          result.saturation = 0.75;
        }

        if (lightness = color.lightness || color.l) {

          if (lightness > 1) {
            lightness /= 100;
          }

          result.lightness = lightness;
        } else {
          result.lightness = 0.5;
        }

        return result;
      }
    }, {
      key: 'buildHSLString',
      value: function buildHSLString(hsl) {
        return 'hsl( ' + Math.round(hsl.h) + ', ' + Math.round(hsl.s * 100) + '%, ' + Math.round(hsl.l * 100) + '%)';
      }
    }, {
      key: 'colorizeAll',
      value: function colorizeAll(options) {
        var _this2 = this;

        var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;


        var series = void 0,
            seriesLength = void 0;

        if (options.serieTypes) {
          var _graph;

          if (!Array.isArray(options.serieTypes)) {
            options.serieTypes = [options.serieTypes];
          }

          series = (_graph = this.graph).allSeries.apply(_graph, _toConsumableArray(options.serieTypes));
        } else {
          series = this.graph.getSeries();
        }

        seriesLength = series.length;

        if (!options.startingColorHSL) {

          if (options.colorHSL) {
            options.startingColorHSL = this.checkHSL(options.colorHSL);
          } else {
            throw 'No starting color was provided. There must exist either options.colorHSL or options.startingColorHSL';
          }
        }

        if (!options.endingColorHSL) {

          if (!options.affect || !['h', 's', 'l', 'hue', 'saturation', 'lightness'].include(options.affect)) {
            options.affect = 'h';
          }

          switch (options.affect) {

            case 'h':
            case 'hue':
              options.endingColorHSL = {
                h: options.startingColorHSL.h + 300,
                s: options.startingColorHSL.s,
                l: options.startingColorHSL.l
              };
              break;

            case 'saturation':
            case 's':
              var endS = void 0;

              if (options.startingColorHSL.s > 0.5) {
                endS = 0;
              } else {
                endS = 1;
              }

              options.endingColorHSL = {
                h: options.startingColorHSL.h,
                s: endS,
                l: options.startingColorHSL.l
              };
              break;

            case 'lightness':
            case 'l':
              var endL = void 0;

              if (options.startingColorHSL.l > 0.5) {
                endL = 0;
              } else {
                endL = 0.75;
              }

              options.endingColorHSL = {
                h: options.startingColorHSL.h,
                s: options.startingColorHSL.s,
                l: endL
              };
              break;
          }
        } else {
          options.endingColorHSL = Object.assign({}, options.startingColorHSL, options.endingColorHSL);
        }

        return series.map(function (serie, index) {

          if (!serie.setLineColor) {
            throw 'The serie ' + serie.getName() + ' does not implement the method `startingColor`';
          }

          var colorString = void 0;

          if (seriesLength == 1) {

            colorString = _this2.buildHSLString({
              h: options.startingColorHSL.h,
              s: options.startingColorHSL.s,
              l: options.startingColorHSL.l
            });
          } else {

            colorString = _this2.buildHSLString({
              h: options.startingColorHSL.h + index / (seriesLength - 1) * (options.endingColorHSL.h - options.startingColorHSL.h),
              s: options.startingColorHSL.s + index / (seriesLength - 1) * (options.endingColorHSL.s - options.startingColorHSL.s),
              l: options.startingColorHSL.l + index / (seriesLength - 1) * (options.endingColorHSL.l - options.startingColorHSL.l)
            });
          }

          serie.setLineColor(colorString);

          if (typeof callback == 'function') {
            callback(index, colorString);
          }

          return colorString;
        });
      }
    }], [{
      key: 'default',
      value: function _default() {

        return {};
      }
    }]);

    return PluginMakeTracesDifferent;
  }(_graphPlugin2.default);

  exports.default = PluginMakeTracesDifferent;
  module.exports = exports['default'];
});

/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(5), __webpack_require__(29)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('../graph.util.js'), require('./graph.plugin.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphUtil, global.graphPlugin);
    global.graphPluginPeakpicking = mod.exports;
  }
})(this, function (module, exports, _graphUtil, _graphPlugin) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var util = _interopRequireWildcard(_graphUtil);

  var _graphPlugin2 = _interopRequireDefault(_graphPlugin);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var PluginPeakPicking = function (_Plugin) {
    _inherits(PluginPeakPicking, _Plugin);

    function PluginPeakPicking() {
      _classCallCheck(this, PluginPeakPicking);

      return _possibleConstructorReturn(this, (PluginPeakPicking.__proto__ || Object.getPrototypeOf(PluginPeakPicking)).apply(this, arguments));
    }

    _createClass(PluginPeakPicking, [{
      key: 'init',
      value: function init(graph, options) {
        _get(PluginPeakPicking.prototype.__proto__ || Object.getPrototypeOf(PluginPeakPicking.prototype), 'init', this).call(this, graph, options);
        this.picks = [];

        for (var n = 0, m = this.options.autoPeakPickingNb; n < m; n++) {
          var shape = this.graph.newShape({
            type: 'label',
            label: {
              text: '',
              position: {
                x: 0
              },
              anchor: 'middle'
            },

            selectable: true,

            shapeOptions: {
              minPosY: 15
            }
          });

          shape.draw();

          this.picks.push(shape);
        }
      }
    }, {
      key: 'setSerie',
      value: function setSerie(serie) {
        this.serie = serie;

        this.picks.map(function (pick) {
          pick.show();
        });
      }
    }, {
      key: 'serieRemoved',
      value: function serieRemoved(serie) {
        if (this.serie == serie) {
          this.picks.map(function (pick) {
            pick.hide();
          });
        }
      }
    }, {
      key: 'preDraw',
      value: function preDraw() {
        if (!this.serie) {
          return;
        }

        this.detectedPeaks = [];
        this.lastYPeakPicking = false;
      }
    }, {
      key: 'postDraw',
      value: function postDraw() {
        if (!this.serie) {
          return;
        }
        var lookForMaxima = true;
        var lookForMinima = false;
        var lastYPeakPicking = void 0;
        var peaks = [];

        var waveform = this.serie.getWaveform();

        if (!waveform) {
          throw 'The serie must have a waveform for the peak picking to work';
        }

        var length = waveform.getLength(),
            i = 0,
            y = void 0;

        for (; i < length; i++) {
          y = waveform.getY(i);

          if (this.serie.options.lineToZero) {
            peaks.push([waveform.getX(i), y]);
            continue;
          }

          if (!lastYPeakPicking) {
            lastYPeakPicking = [waveform.getX(i), y];
            continue;
          }

          if (y >= lastYPeakPicking[1] && lookForMaxima || y <= lastYPeakPicking[1] && lookForMinima) {
            lastYPeakPicking = [waveform.getX(i), y];
          } else if (y < lastYPeakPicking[1] && lookForMaxima || y > lastYPeakPicking[1] && lookForMinima) {
            if (lookForMinima) {
              lookForMinima = false;
              lookForMaxima = true;
            } else {
              lookForMinima = true;
              lookForMaxima = false;

              peaks.push(lastYPeakPicking);
              lastYPeakPicking = false;
            }

            lastYPeakPicking = [waveform.getX(i), y];
          }
        }

        var ys = peaks;
        var x,
            px,
            passed = [],
            px,
            l = ys.length,
            k,
            m,
            index;

        i = 0;

        var selected = this.graph.selectedShapes.map(function (shape) {
          return shape.getProp('xval');
        });

        ys.sort(function (a, b) {
          return b[1] - a[1];
        });

        m = 0;

        for (; i < l; i++) {
          x = ys[i][0];
          px = this.serie.getX(x);
          k = 0;
          y = this.serie.getY(ys[i][1]);

          if (px < this.serie.getXAxis().getMinPx() || px > this.serie.getXAxis().getMaxPx()) {
            continue;
          }

          if (!this.options.autoPeakPickingAllowAllY && (y > this.serie.getYAxis().getMinPx() || y < this.serie.getYAxis().getMaxPx())) {
            continue;
          }

          // Distance check
          for (; k < passed.length; k++) {
            if (Math.abs(passed[k] - px) < this.options.autoPeakPickingMinDistance) {
              break;
            }
          }
          if (k < passed.length) {
            continue;
          }

          // Distance check end

          // If the retained one has already been selected somewhere, continue;
          if ((index = selected.indexOf(x)) > -1) {
            passed.push(px);
            continue;
          }

          if (!this.picks[m]) {
            return;
          }

          //console.log( this.getYAxis().getDataMax(), this.getYAxis().getCurrentMin(), y );
          //    this.picks[ m ].show();

          if (this.serie.getYAxis().getPx(ys[i][1]) - 20 < 0) {
            this.picks[m].setLabelPosition({
              x: x,
              y: '5px'
            });

            this.picks[m].setLabelBaseline('hanging');
          } else {
            this.picks[m].setLabelBaseline('no-change');

            this.picks[m].setLabelPosition({
              x: x,
              y: ys[i][1],
              dy: '-15px'
            });
          }

          this.picks[m].setProp('xval', x);

          if (this.options.autoPeakPickingFormat) {
            this.picks[m].setLabelText(this.options.autoPeakPickingFormat.call(this.picks[m], x, m));
          } else {
            this.picks[m].setLabelText(String(Math.round(x * 1000) / 1000));
          }

          this.picks[m].makeLabels();

          m++;
          while (this.picks[m] && this.picks[m].isSelected()) {
            m++;
          }

          if (passed.length == this.options.autoPeakPickingNb) {
            break;
          }
        }
      }
    }, {
      key: 'hidePeakPicking',
      value: function hidePeakPicking(lock) {
        if (!this._hidePeakPickingLocked) {
          this._hidePeakPickingLocked = lock;
        }

        if (!this.picks) {
          return;
        }
        for (var i = 0; i < this.picks.length; i++) {
          this.picks[i].hide();
        }
      }
    }, {
      key: 'showPeakPicking',
      value: function showPeakPicking(unlock) {
        if (this._hidePeakPickingLocked && !unlock) {
          return;
        }

        if (!this.picks) {
          return;
        }

        for (var i = 0; i < this.picks.length; i++) {
          this.picks[i].show();
        }
      }
    }, {
      key: 'killPeakPicking',
      value: function killPeakPicking() {
        if (this.picks) {
          for (var i = 0, l = this.picks.length; i < l; i++) {
            this.picks[i].kill();
          }
        }
      }
    }, {
      key: 'getSerie',
      value: function getSerie() {
        return this.serie;
      }
    }], [{
      key: 'default',
      value: function _default() {
        return {
          autoPeakPicking: false,
          autoPeakPickingNb: 4,
          autoPeakPickingMinDistance: 10,
          autoPeakPickingFormat: false,
          autoPeakPickingAllowAllY: false
        };
      }
    }]);

    return PluginPeakPicking;
  }(_graphPlugin2.default);

  exports.default = PluginPeakPicking;
  module.exports = exports['default'];
});

/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(5), __webpack_require__(28)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('../graph.util.js'), require('./graph.shape.js'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.graphUtil, global.graphShape);
    global.graphShapeEllipse = mod.exports;
  }
})(this, function (module, exports, _graphUtil, _graphShape) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var util = _interopRequireWildcard(_graphUtil);

  var _graphShape2 = _interopRequireDefault(_graphShape);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var ShapeEllipse = function (_Shape) {
    _inherits(ShapeEllipse, _Shape);

    function ShapeEllipse(graph, options) {
      _classCallCheck(this, ShapeEllipse);

      return _possibleConstructorReturn(this, (ShapeEllipse.__proto__ || Object.getPrototypeOf(ShapeEllipse)).call(this, graph, options));
    }

    _createClass(ShapeEllipse, [{
      key: 'createDom',
      value: function createDom() {
        this._dom = document.createElementNS(this.graph.ns, 'ellipse');
      }
    }, {
      key: 'applyPosition',
      value: function applyPosition() {

        var pos = this.computePosition(0);

        this.setDom('cx', pos.x || 0);
        this.setDom('cy', pos.y || 0);

        var posR = this.graph.newPosition({

          dx: this.getProp('rx'),
          dy: this.getProp('ry') || this.getProp('rx')

        });

        var posComputed = this.calculatePosition(posR);

        this.setDom('rx', Math.abs(posComputed.x) || 0);
        this.setDom('ry', Math.abs(posComputed.y) || 0);
        return true;
      }
    }, {
      key: 'setR',
      value: function setR(rx, ry) {
        this.setProp('rx', rx);
        this.setProp('ry', ry);
        return this;
      }
    }, {
      key: 'handleMouseUpImpl',
      value: function handleMouseUpImpl() {
        this.triggerChange();
      }
    }, {
      key: 'handleMouseMoveImpl',
      value: function handleMouseMoveImpl(e, deltaX, deltaY, deltaXPx, deltaYPx) {}
    }]);

    return ShapeEllipse;
  }(_graphShape2.default);

  exports.default = ShapeEllipse;
  module.exports = exports['default'];
});

/***/ })
/******/ ]);
});